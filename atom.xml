<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jackie&#39;s blogs</title>
  
  <subtitle>佛系更新，欢迎交流</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://296245482.github.io/"/>
  <updated>2019-06-04T15:24:20.000Z</updated>
  <id>https://296245482.github.io/</id>
  
  <author>
    <name>Long Cheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《高性能MySQL》阅读笔记 第七章 MySQL高级特性</title>
    <link href="https://296245482.github.io/2019/06/04/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://296245482.github.io/2019/06/04/《高性能MySQL》阅读笔记-第七章-MySQL高级特性/</id>
    <published>2019-06-04T15:24:20.000Z</published>
    <updated>2019-06-04T15:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL从5.0和5.1开始引入了很多高级特性，分区、触发器等。除了分区之外大部分功能其实用到的场景都不是很多，从MySQL层面上使用这些高级特性说不定在后期的使用上会大大增加升级重构的成本，实际中这些高级特性的任务都在应用端层面完成了，这里这些高级特性能够做相关的了解。</p><h2 id="7-1-分区表"><a href="#7-1-分区表" class="headerlink" title="7.1 分区表"></a>7.1 分区表</h2><p>分区的主要目的是将数据按照一个较粗粒度、简易的分布在不同的表中。实现方式是对底层表的封装，意味着索引也是按照分区的字表定义的，没有全局的索引。在表创建时使用PARTITION BY子句定义各个分区存放数据。</p><p>分区表的主要应用场景如下：</p><ul><li>没有合适的索引。</li><li>表非常大无法全部放到内存，或者只在表最后有热点数据，其他全是历史数据。</li><li>批量删除大量数据。</li><li>分区表数据可以分布在不同的物理设备上。</li><li>可以避免某些索引互斥访问和锁竞争等。</li><li>独立的备份和恢复分区，在非常大的数据量场景下效果好。</li></ul><h3 id="7-1-1-分区表原理"><a href="#7-1-1-分区表原理" class="headerlink" title="7.1.1 分区表原理"></a>7.1.1 分区表原理</h3><p>分区表由多个底层表实现的，存储引擎管理分区的各个底层表和管理普通表一样，各个底层表使用的也是相同的存储引擎，各个底层表上的索引也是完全相同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p><ul><li>SELECT查询<br>分区别先打开并锁住所有的底层表，优化器判断是否可以过滤部分分区，然后再调用对应存储引擎的接口访问各个分区的数据。</li><li>INSERT操作<br>同上，先锁住，确定哪个分区接收这个数据，再将记录写入底层表。</li><li>DELETE操作<br>同上，先锁住，确定分区，进行删除。</li><li>UPDATE操作<br>同上先锁住所有底层表，找到需要更新的数据的分区，取出更新，判断新数据放在哪个分区，完成写入操作，然后进行原数据的删除。</li></ul><p>大部分操作时支持过滤的，确定了操作分区后无须对其他分区进行操作。虽然操作全都是“先打开并锁住所有底层表”，但如果存储引擎能够自己实现行级锁，则会在分区层释放对应的表锁，这个加锁解锁过程和普通的InnoDB上的查询类似。</p><h3 id="7-1-2-分区表类型"><a href="#7-1-2-分区表类型" class="headerlink" title="7.1.2 分区表类型"></a>7.1.2 分区表类型</h3><p>常见的分区类型：</p><ul><li>根据键值分区，减少互斥量竞争。</li><li>使用数学模函数进行分区，数据轮询放入不同的分区，例如对日期做模7的运算。</li></ul><h3 id="7-1-3-如果使用分区表"><a href="#7-1-3-如果使用分区表" class="headerlink" title="7.1.3 如果使用分区表"></a>7.1.3 如果使用分区表</h3><p>当数据量超大的时候，B-Tree索引就无法起作用了。除非是索引覆盖扫描，否则数据库需要根据索引扫描结果回表，这将会产生大量随机I/O，另外这样索引的维护代价也会非常高。</p><p>这种情况下就应该完全放弃B-Tree索引，选择一些更加粗粒度的方式检索，这也是分区要做的，以小代价定位数据在那一块区域，选定区域后，区域内可以建索引，可以顺序扫描，数据可以缓存到内存，只需要一个简单的表达式可以表达每个分区存放的是什么数据。</p><p>为了保证大数据量的可扩展性，一般有以下的策略：</p><ul><li>全量扫描数据，不需要索引<br>使用简单的分区方式存放表，不用任何索引，根据分区的规则简单运算大致定位需要的数据位置，将数据限制在少数分区中。</li><li>索引数据，分离热点<br>将热点数据单独放在一个分区里，让这个分区数据有机会缓存在内存中，这样很小的分区表能使用索引也能使用缓存。</li></ul><h3 id="7-1-4-分区表的坑"><a href="#7-1-4-分区表的坑" class="headerlink" title="7.1.4 分区表的坑"></a>7.1.4 分区表的坑</h3><ul><li>NULL值会使分区过滤失效<br>如果按照某个列值进行分区时，那么为NULL值或者是非法值的数据将会被存到一个它们不应该出现的分区中。可以创建一个“无用”分区或者直接使用列本身而不是列的函数进行分区。</li><li>分区列和索引列不匹配<br>定义索引的列和分区的列不匹配会导致无法进行分区的过滤。通过索引条件进行扫描时会扫描每一个分区内的索引。</li><li>选择分区的成本可能会很高<br>实现方式有多种，性能各不相同，随着分区数量的增加，成本会越来越高。（键分区和哈希分区就没有这样的问题）</li><li>打开并锁住所有底层表的成本很高<br>当查询分区表时MySQL需要打开并锁住所有的底层表，这个操作发生在分区过滤之前，这个开销无法通过分区过滤和分区类型来改善，对一些本身操作就非常快的操作会带来明显的额外开销。</li><li>维护分区的成本可能很高<br>新增和删除很快，但是例如重组分区或者ALTER会创建一个临时分区，复制然后删除旧分区。</li><li>分区必须使用相同的存储引擎。</li><li>某些引擎不支持分区表。</li><li>在MySQL 5.5分区表才开始趋于稳定。</li></ul><h3 id="7-1-5-查询优化"><a href="#7-1-5-查询优化" class="headerlink" title="7.1.5 查询优化"></a>7.1.5 查询优化</h3><p>分区优化最大的优点就是优化器可以过滤一些分区，当然这是需要在WHERE条件中带入分区列的。</p><p>EXPLAIN PARTITIONS可以观察优化器是否执行了分区过滤。</p><p>MySQL只能根据使用分区的列本身才能过滤分区，不能根据表达式的值来过滤分区（和查询中必须使用独立的列才能使用索引是一样的道理）。</p><h3 id="7-1-6-合并表"><a href="#7-1-6-合并表" class="headerlink" title="7.1.6 合并表"></a>7.1.6 合并表</h3><p>合并表是早期的、简单的分区实现，是一种将要被淘汰的技术，分区表和优化器的紧密结合才是未来的趋势。合并表这里不做过多记录。</p><h2 id="7-2-视图"><a href="#7-2-视图" class="headerlink" title="7.2 视图"></a>7.2 视图</h2><p>MySQL 5.0开始引入了视图，本身是一个虚拟表，数据由MySQL其他表中生成的，大多数地方MySQL对于视图和表是同等对待的。对于好几个表的复杂查询，使用视图有时候会大大简化问题。</p><p>最简单的使用方法是将SELECT语句的结果放到临时表中，当需要访问视图时直接访问这个临时表就可以了。这种情况也有两种处理视图的方算法，一种是合并算法，就视图的定义SQL直接包含进查询的SQL中（SELECT指定的字段）；另一种是临时表算法，先查出结果定一个临时表，再从临时表中选择特定的列。主要都采用合并的算法。</p><p>视图的性能很难预测，需要详细的测试。</p><p>可更新视图是指可以通过更新视图来更新视图涉及的相关表。如果视图中包含GROUP BY、UNION、聚合函数等就不能被更新。</p><p>不支持物化视图，不支持视图中创建索引，</p><h2 id="7-3-外键约束"><a href="#7-3-外键约束" class="headerlink" title="7.3 外键约束"></a>7.3 外键约束</h2><p>外键可以看做是一个确保系统完整性的额外的特性，但是会带来额外的复杂性和额外的索引消耗，一般人都会选择在应用中实现外键功能。</p><p>InnoDB是MySQL最后那个唯一支持外键的内置存储引擎，InnoDB强制外键使用索引。</p><p>外键的好处：如果要确保两个相关表始终有一直的数据，使用外键比在应用程序中检查性能要高得多。不足：外键约束是的查询时需要额外访问一些别的表，意味着其他表也要进行锁等待。</p><p>触发器可以代替外键，如果只是进行数值约束，触发器或者应用内实现该约束会更好</p><p><strong><em>外键会带来很大的额外消耗，使用前要仔细做好基准测试</em></strong></p><h2 id="7-4-在MySQL内部存储代码"><a href="#7-4-在MySQL内部存储代码" class="headerlink" title="7.4 在MySQL内部存储代码"></a>7.4 在MySQL内部存储代码</h2><p>MySQL允许通过触发器、存储过程、函数的形式来存储代码。存储代码帮助应用隐藏复杂性，使得应用开发更简单，不过性能可能更低，存在潜在的风险。</p><p>MySQL允许内部存储代码的形式：</p><ul><li>存储过程和函数</li><li>触发器</li><li>事件</li></ul><h2 id="7-5-游标"><a href="#7-5-游标" class="headerlink" title="7.5 游标"></a>7.5 游标</h2><p>MySQL在服务器端提供只读的、单向的游标，游标中指向的对象都是存储在临时表中。游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制，尽管能遍历结果中的所有行，但他一次只指向一行，主要作用就是对查询数据库所返回的记录进行遍历，以便进行相应的操作。</p><h2 id="7-6-绑定变量"><a href="#7-6-绑定变量" class="headerlink" title="7.6 绑定变量"></a>7.6 绑定变量</h2><p>绑定变量最大的用处在于创建一个绑定变量的SQL，客户端向服务器发送了一个SQL语句原型，服务器端收到这个SQL语句框架后解析并存储这个SQL语句的部分执行计划，返回给客户端一个SQL语句处理句柄。客户端可以通过像服务端发送各个参数取值和SQL语句句柄来执行一个具体的查询。</p><p>这样服务器只需解析一个SQL语句，执行计划会被缓存，发送的句柄和参数可以使用二进制传输，不用发送整个查询语句，效率更高。绑定变量相对更加安全，减少SQL注入。</p><p>服务器端的绑定变量是使用二进制协议将具体的参数值发给服务器端并执行，客户端模拟的绑定变量是客户端驱动程序接收一个带参数的SQL再将指定的值带入其中，最后将完整的查询发送到服务器端。</p><h2 id="7-7-用户自定义函数"><a href="#7-7-用户自定义函数" class="headerlink" title="7.7 用户自定义函数"></a>7.7 用户自定义函数</h2><p>User-define function，UDF是一种对MySQL扩展的途径，其用法与内置函数相同。</p><p>减少数据在数据库和应用服务器上的传输，提高数据处理的效率，在一些简单的操作上优势大。</p><p>MySQL版本升级时要特别注意UDF，有时需要重新编译UDF或者修改。</p><h2 id="7-8-插件"><a href="#7-8-插件" class="headerlink" title="7.8 插件"></a>7.8 插件</h2><p>MySQL支持各种各样的插件，使得无须修改源代码就可以大大扩展相关功能。</p><ul><li>存储过程插件</li><li>后台插件</li><li>全文解析插件</li><li>审计插件</li><li>认证插件</li></ul><h2 id="7-9-字符集和校对"><a href="#7-9-字符集和校对" class="headerlink" title="7.9 字符集和校对"></a>7.9 字符集和校对</h2><p>当服务器和客户端通信时，如果使用了不同的字符集，这时服务器端将进行必要的翻译转换工作。</p><p><img src="https://i.loli.net/2019/05/31/5cf0dae884d5b17964.png" alt="客户端和服务器的字符集.png" title="客户端和服务器的字符集.png"></p><p>MySQL在比较两个字符串大小时会将它们都转成同一个字符集再比较，MySQL 5.0之后支持这样的隐式转换。</p><h2 id="7-10-全文索引"><a href="#7-10-全文索引" class="headerlink" title="7.10 全文索引"></a>7.10 全文索引</h2><p>全文索引的使用场景是通过关键字的匹配来进行查询过滤，基于相似度的查询，而不是原来的精确的数值比较。是四大索引中的一种（普通索引、唯一索引、主键索引、全文索引）。</p><h3 id="7-10-1-自然语言的全文索引"><a href="#7-10-1-自然语言的全文索引" class="headerlink" title="7.10.1 自然语言的全文索引"></a>7.10.1 自然语言的全文索引</h3><p>自然语言上采用的是相关度来度量，基于匹配关键词的个数，以及关键词在文档中出现的次数，在整个索引中出现次数越少的词语，匹配时的相关度越高，例如一个词语在一大半的记录中都出现了，那么自然语言将不会搜索这类词语。</p><p>SQL中由MATCH()来完成，函数MATCH()将返回关键字匹配的相关度，在MATCH()中指定的列必须在和全问索引中指定的列完全相同。</p><h3 id="7-10-2-布尔全文索引"><a href="#7-10-2-布尔全文索引" class="headerlink" title="7.10.2 布尔全文索引"></a>7.10.2 布尔全文索引</h3><p>布尔搜索中可以指定查询中自定义某个词语的相关性，并且可以通过一些前缀修饰符定制搜索，此处不过多详细描述。</p><p>查询时会先把短语拆分成单个词语查询，然后取出这些记录进行精确的匹配短语，比LIKE操作快很多（在关键词不太常见的情况下）。</p><h3 id="7-10-3-全文索引的限制"><a href="#7-10-3-全文索引的限制" class="headerlink" title="7.10.3 全文索引的限制"></a>7.10.3 全文索引的限制</h3><p>关键字和文本的相关性判断只考虑了词频，词在字符串中的位置也就无法用在相关性的计算上。</p><p>内存如果不能装载全部全文索引会导致搜索的速度很慢。全文索引会有很多的碎片，需要做OPTIMIZE TABLE操作。</p><p>全文索引只能做全文搜索匹配，任何其他操作，比如WHERE条件比较都只能在完成全问搜索返回记录后进行。</p><p>全文索引不存储索引列的实际值，也就是没有索引覆盖扫描。</p><p>全文索引除了相关性排序外，如果还需要其他排序操作需要进行文件排序。</p><p>在使用全文索引时通常会产生大量随机I/O，再加上GROUP BY操作等会使用到临时表和文件排序，使用全文索引有时也会使得其他列的普通索引无法使用，在日常使用中多加注意。</p><h3 id="7-10-4-全文索引的配置和优化"><a href="#7-10-4-全文索引的配置和优化" class="headerlink" title="7.10.4 全文索引的配置和优化"></a>7.10.4 全文索引的配置和优化</h3><p>保证索引缓存足够大，是的全文索引都能够缓存在内存中。停用表需要经常更行，对一些高频词语及时更新进停用表中。忽略一些太短的词语，设置索引单词的最小长度。</p><h2 id="7-11-分布式（XA）事务"><a href="#7-11-分布式（XA）事务" class="headerlink" title="7.11 分布式（XA）事务"></a>7.11 分布式（XA）事务</h2><p>略</p><h2 id="7-12-查询缓存"><a href="#7-12-查询缓存" class="headerlink" title="7.12 查询缓存"></a>7.12 查询缓存</h2><p>MySQL有两类缓存，一是缓存查询计划，相同类型的SQL就可以跳过解析和执行计划生成阶段，二是查询结果的缓存，完整的SELECT查询结果将得到缓存。</p><p>很多时候还是推荐默认关闭查询缓存，后续将详细展开。</p><h3 id="7-12-1-MySQL如果判断缓存命中"><a href="#7-12-1-MySQL如果判断缓存命中" class="headerlink" title="7.12.1 MySQL如果判断缓存命中"></a>7.12.1 MySQL如果判断缓存命中</h3><p>缓存存放在一个引用表中，通过一个哈希值引用，所以任何的字符上的不同，空格、注释之类的，都会导致缓存不命中，因此使用缓存必须在SQL上保持统一的编码习惯。</p><p>查询语句包含不确定因素时不会被缓存，例如函数NOW()等，这类查询不会被缓存，除此之外还有用户自定义函数、存储函数、用户变量、临时表、MySQL中的系统表、任何包含列级别权限的表，都不会被缓存。</p><p>打开查询缓存后对数据库的读写操作都会带来额外的消耗，读开始之前就会检查是否命中缓存，读完若没有这个查询会将结果存入缓存，写操作必须将对应表的所有缓存都设置失效。</p><h3 id="7-12-2-查询缓存如果使用内存"><a href="#7-12-2-查询缓存如果使用内存" class="headerlink" title="7.12.2 查询缓存如果使用内存"></a>7.12.2 查询缓存如果使用内存</h3><p>查询结果完全存储在内存中。MySQL用于查询缓存的内存被分成一个个的数据块，大小时变长的，每个数据块存储了自己的类型、大小和存储的数据，外加一个指向前一个后一个数据块的指针。</p><h3 id="7-12-3-查询缓存发挥作用"><a href="#7-12-3-查询缓存发挥作用" class="headerlink" title="7.12.3 查询缓存发挥作用"></a>7.12.3 查询缓存发挥作用</h3><p>缓存是否对系统带来了更好的性能这个主要考察缓存带来的资源节约和其本身资源消耗的关系。</p><p>可参考的数据有缓存命中率，就是查询缓存返回结果占总查询的比例；INSERT/SELECT比例，查多改少较好。还有一个参考是“命中/写入”，当这个比例大于3:1时，最好10:1时，一般推荐以这个比例为准，到达这样的比例才能使得缓存的性能提升大于资源消耗。</p><h3 id="7-12-4-通用的查询缓存优化"><a href="#7-12-4-通用的查询缓存优化" class="headerlink" title="7.12.4 通用的查询缓存优化"></a>7.12.4 通用的查询缓存优化</h3><ul><li>多个小表代替一个大表</li><li>批量写入只需要做一次缓存失效</li><li>缓存空间过大会在过期操作时导致服务器僵死，可以对缓存空间大小稍作控制</li><li>写密集型应用应该禁用查询缓存</li><li>可以针对某些查询设置走查询缓存</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>BaronSchwartz, PeterZaitsev, VadimTkachenko, et al. 高性能MySQL[M]. 电子工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      MySQL从5.0和5.1开始引入了很多高级特性，分区、触发器等。除了分区之外大部分功能其实用到的场景都不是很多，从MySQL层面上使用这些高级特性说不定在后期的使用上会大大增加升级重构的成本，实际中这些高级特性的任务都在应用端层面完成了，这里这些高级特性能够做相关的了解。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》阅读笔记 第六章 查询性能优化</title>
    <link href="https://296245482.github.io/2019/05/25/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://296245482.github.io/2019/05/25/《高性能MySQL》阅读笔记-第六章-查询性能优化/</id>
    <published>2019-05-24T21:00:59.000Z</published>
    <updated>2019-05-24T21:00:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-慢查询原因"><a href="#6-1-慢查询原因" class="headerlink" title="6.1 慢查询原因"></a>6.1 慢查询原因</h2><p>查询任务由无数个子任务组成，需要优化或者消除其中的一些子任务，或者减少执行次数。这就需要我们了解查询的生命周期、清楚查询的时间消耗。这其中的时间消耗可能在网络、CPU计算、统计信息和执行计划的生成、锁等待，需要对查询进行剖析才能定位到优化点。</p><h2 id="6-2-慢查询基础：优化数据访问"><a href="#6-2-慢查询基础：优化数据访问" class="headerlink" title="6.2 慢查询基础：优化数据访问"></a>6.2 慢查询基础：优化数据访问</h2><p>分析低效查询从两个角度来看：①应用程序是否检索了大量的超过需要的数据量；②MySQL服务器是否分析了大量的超过需要的数据量。</p><h3 id="6-2-1-请求了不需要的数据"><a href="#6-2-1-请求了不需要的数据" class="headerlink" title="6.2.1 请求了不需要的数据"></a>6.2.1 请求了不需要的数据</h3><ul><li>尽量在查询后面加上limit限制；</li><li>多表关联查询时只返回特点的列；</li><li>减少使用SELECT *，让优化器能够实现索引覆盖扫描，减少修改带来的问题；</li><li>应用中多次查询同一个数据，可以改为初次查询时将数据缓存起来</li></ul><h3 id="6-2-2-MySQL扫描了额外的数据"><a href="#6-2-2-MySQL扫描了额外的数据" class="headerlink" title="6.2.2 MySQL扫描了额外的数据"></a>6.2.2 MySQL扫描了额外的数据</h3><ol><li>响应时间 = 服务时间 + 等待时间；</li><li>最理想的情况是扫描行数和返回行数相同。EXPLAIN语句中的type反映了访问类型，有全表扫描、扫描索引、范围访问、单值访问等；rows反映了预估访问行数。</li><li>MySQL应用WHERE的三种方式，从好到坏：①存储引擎层过滤不匹配的记录 ②使用索引覆盖扫描 ③在MySQL服务层先从数据表读出记录然后过滤</li></ol><h2 id="6-3-重构查询的方式"><a href="#6-3-重构查询的方式" class="headerlink" title="6.3 重构查询的方式"></a>6.3 重构查询的方式</h2><p>重构可以理解为转换一种写法，从应用角度完成修改。</p><ol><li>一个复杂的查询还是多个简单的查询？一个复杂的大查询，例如删除操作，一次性完成的话会一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的查询。</li><li>将复杂查询进行分解和切分可以带来很多好处：①单表缓存数据的使用 ②减少锁竞争 ③更容易对数据库进行拆分 ④使用IN ()代替原本的表关联更高效 ⑤关联查询会有冗余记录的查询</li></ol><h2 id="6-4-查询执行的基础"><a href="#6-4-查询执行的基础" class="headerlink" title="6.4 查询执行的基础"></a>6.4 查询执行的基础</h2><p><img src="https://i.loli.net/2019/05/06/5ccfebb488901.png"><br>MySQL执行一个查询的过程：</p><ol><li>客户端发送查询给服务器</li><li>服务器先查询缓存，命中则返回，未命中继续</li><li>解析SQL、预处理，送至查询优化器生成执行计划</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</li><li>结果返回客户端结果</li></ol><h3 id="6-4-1-客户端-服务器通信"><a href="#6-4-1-客户端-服务器通信" class="headerlink" title="6.4.1 客户端/服务器通信"></a>6.4.1 客户端/服务器通信</h3><p>通信是半双工的，双方都可以发送数据，但同一时刻只有一方可以发送。没法进行流量控制，因此会涉及到数据包很大必须全部传完才行的问题。</p><h3 id="6-4-2-查询缓存"><a href="#6-4-2-查询缓存" class="headerlink" title="6.4.2 查询缓存"></a>6.4.2 查询缓存</h3><p>查询缓存若打开会优先检查是否命中缓存中的数据，检查是通过一个大小写敏感的哈希查找实现。在缓存命中的情况下，查询的SQL语句都没有被解析，也不会生成执行计划，缓存中的结果直接返回给了客户端。</p><h3 id="6-4-3-查询优化处理"><a href="#6-4-3-查询优化处理" class="headerlink" title="6.4.3 查询优化处理"></a>6.4.3 查询优化处理</h3><p>这一步主要将SQL转换成一个执行计划，包含了几个子阶段：解析SQL、预处理、优化SQL的执行计划。</p><h4 id="6-4-3-1-语法解析器和预处理"><a href="#6-4-3-1-语法解析器和预处理" class="headerlink" title="6.4.3.1 语法解析器和预处理"></a>6.4.3.1 语法解析器和预处理</h4><p>通过关键字将SQL解析成一颗“解析树”，这一部主要检查解析树是否合法，例如表列是否存在等等。</p><h4 id="6-4-3-2-查询优化器"><a href="#6-4-3-2-查询优化器" class="headerlink" title="6.4.3.2 查询优化器"></a>6.4.3.2 查询优化器</h4><p>基于成本，预测多种执行计划的成本，并选择成本最小的那一个，计算依据有：表或索引的页面数、索引基数、索引和数据行的长度、索引分布情况；</p><p>优化策略又分为静态、动态优化，静态直接对解析树进行分析，只需要做一次，动态优化和上下文有关，每次执行时都需要评估。</p><p>MySQL能够处理的一些优化类型：重新定义关联表顺序；将外连接转化为内连接；等价条件变化，比较的合并和减少；MIN、MAX等可以依靠B-Tree索引特点快速获取，COUNT根据存储引擎单独存储的值直接获取；预估并参数化表达式；覆盖索引返回；条件得到满足就立即停止查询；关联查询的条件可以扩展到多个表上；IN条件进行二分查找优化。</p><h4 id="6-4-3-3-数据和索引的统计信息"><a href="#6-4-3-3-数据和索引的统计信息" class="headerlink" title="6.4.3.3 数据和索引的统计信息"></a>6.4.3.3 数据和索引的统计信息</h4><p>查询优化器在MySQL架构中的服务器层，但是服务器层没有保存数据和索引统计信息，存储引擎会提供给优化器表或索引的页面数、索引基数、数据行、索引长度和索引分布等等。</p><h4 id="6-4-3-4-MySQL如何关联查询"><a href="#6-4-3-4-MySQL如何关联查询" class="headerlink" title="6.4.3.4 MySQL如何关联查询"></a>6.4.3.4 MySQL如何关联查询</h4><p>关联查询不一定要两个表，每个查询都是一次关联，读取结果临时表也是一次关联。MySQL对任何关联都执行嵌套循环关联操作，也就是先从一个表中取出单条数据，嵌套到下一个表中寻找匹配的，直到找出所有的行，然后返回查询中需要的各个列，整体上都是一个”嵌套循环关联“。</p><p>可以通过如下很好的了解：</p><p><img src="https://i.loli.net/2019/05/13/5cd93e4dea4b168903.png" alt="多表关联的一种方式.png" title="多表关联的一种方式.png"></p><p>例如如上查询，MySQL实际执行时总是从一个表开始一直嵌套循环、回溯所有关联：</p><p><img src="https://i.loli.net/2019/05/13/5cd93e4dd8da082671.png" alt="MySQL如何多表关联.png" title="MySQL如何多表关联.png"></p><p>实际表之间的关联顺序也可以被MySQL优化，表的关联顺序不一定按照自己定的顺序决定，MySQL会根据索引、扫描的行数选出最合适的顺序来进行更少的嵌套循环和回溯操作。</p><h3 id="6-4-4-查询执行引擎"><a href="#6-4-4-查询执行引擎" class="headerlink" title="6.4.4 查询执行引擎"></a>6.4.4 查询执行引擎</h3><p>MySQL的查询计划是一个数据结构，不是其他关系型数据库那样的字节码。</p><h3 id="6-4-5-返回结果给客户端"><a href="#6-4-5-返回结果给客户端" class="headerlink" title="6.4.5 返回结果给客户端"></a>6.4.5 返回结果给客户端</h3><p>如果查询可以被缓存那么MySQL这个阶段也会将结果放到查询缓存中，返回过程是一个增量、逐步的过程，</p><h2 id="6-5-查询优化的局限性"><a href="#6-5-查询优化的局限性" class="headerlink" title="6.5 查询优化的局限性"></a>6.5 查询优化的局限性</h2><ul><li>关联子查询</li></ul><p>对于Exists和In中的子查询采用如下策略：</p><p>Exists执行顺序如下：①首先执行一次外部查询 ②对于外部查询中的每一行分别执行一次子查询，而且每次执行子查询时都会引用外部查询中当前行的值。 ③使用子查询的结果来确定外部查询的结果集。</p><p>IN的执行过程如下： ①首先运行子查询，获取子结果集 ②主查询再去结果集里去找符合要求的字段列表，符合要求的输出,反之则不输出。</p><p>一般情况下，自己在选择的时候子查询表相对较大时选择exist，相对小时选择in。但这肯定不是绝对的，在实际中要测试验证执行计划和相应时间的假设。</p><ul><li>UNION的限制</li></ul><p>MySQL无法将限制条件从“外层”推到“内层”，例如两表UNION操作，外层有一个limit操作，实际运行两表读取的行数不受limit影响，再两表组合成一个巨大的临时表后才会进行limit操作。</p><p>需要在UNION的两个子查询分别加上limit来解决。</p><ul><li>索引合并优化</li></ul><p>合并索引的特性在于查询一个表时，AND和OR条件两边对应的是两个不同的索引，MySQL会分别利用两个索引查出结果，然后相应的做交集并集操作。</p><p>当两个索引的值选择性较高时，各自返回的数据较少，交集并集的操作成本也低，但是如果选择性不高，各自数据量大，合并索引也会带来效率的负增长。实际工作上，多数会选择关闭合并索引功能，在实际需要使用时改写SQL，将需要合并索引的地方写为UNION操作。</p><ul><li>等值传递</li></ul><p>如果有一个非常大的IN()列表，当优化器发现存在WHERE、ON或者USING子句时，会将这个列表的值和另一个表的某个列相关联，会将IN()列表都复制应用到关联的各个表中，列表很大时会导致优化和执行都变慢。（问题出现很少见）</p><ul><li>并行执行</li></ul><p>MySQL无法利用多核并行执行查询</p><ul><li>哈希关联</li></ul><p>MySQL不支持哈希关联，MySQL所有的关联都是嵌套循环关联。</p><ul><li>松散索引</li></ul><p>MySQL不支持松散索引扫描，无法按照不连续的方式扫描一个索引。简单来说也就是不支持跳过组合索引的前部分，必须使用全表扫描来获取数据。</p><ul><li>最大值和最小值化</li></ul><p>例如在查询一个主键的最小值时，在全表扫描的情况下，理论上读到的第一个满足条件的数据就是主键的最小值，因为主键是严格按照大小顺序排列，但是MySQL这时只会做全表扫描。</p><ul><li>在同一个表上查询和更新</li></ul><p>MySQL不允许同一张表同时做查询和更新，但有一种情况可以解决这样的问题，将此表作为一个临时表，在查询之后和需要更新的表做关联操作，使得更新到表只是一个临时表。</p><h2 id="6-6-查询优化器的提示"><a href="#6-6-查询优化器的提示" class="headerlink" title="6.6 查询优化器的提示"></a>6.6 查询优化器的提示</h2><p>这部分介绍了若干的执行计划调整方法，如果对优化器给出的执行计划不满意的话可以在SQL语句上加上一些提示语句，通过提示提供给优化器一些特殊情况下选择某种查询计划的指导，规划一个比优化器自己选择的更好的执行计划。</p><h2 id="6-7-优化特定类型的查询"><a href="#6-7-优化特定类型的查询" class="headerlink" title="6.7 优化特定类型的查询"></a>6.7 优化特定类型的查询</h2><h3 id="6-7-1-优化COUNT"><a href="#6-7-1-优化COUNT" class="headerlink" title="6.7.1 优化COUNT()"></a>6.7.1 优化COUNT()</h3><p>统计行数时COUNT(*)的性能会优于括号内指定了一个列。</p><p>COUNT在统计列值时要求列值不能为null。</p><p>偶尔也可以考虑使用近似值，例如统计COUNT值时采用EXPLAIN的优化器扫描值，或者去掉一些DISTINCT之列的约束来大大减少运行时间，得到几乎相同的运行结果。</p><p>更好的优化点还有选择索引覆盖扫描，新增加一个汇总表，增加一个外部缓存等等。</p><h3 id="6-7-2-优化关联查询"><a href="#6-7-2-优化关联查询" class="headerlink" title="6.7.2 优化关联查询"></a>6.7.2 优化关联查询</h3><p>表A，B关联时，如果优化器的关联顺序是B、A，那么在ON或者USING上的列就只需要在A表上创建索引。</p><p>GROUP BY和ORDER BY尽可能只使用一个列，这样才有可能使用索引优化。</p><p>注意关联类型。</p><p>对于存在子查询的情况是，记得同时考察下转化为使用关联查询替代，说不定会有更好的效率。</p><h3 id="6-7-3-优化GROUP-BY和DISTINCT"><a href="#6-7-3-优化GROUP-BY和DISTINCT" class="headerlink" title="6.7.3 优化GROUP BY和DISTINCT"></a>6.7.3 优化GROUP BY和DISTINCT</h3><p>当GROUP BY无法使用索引时会使用临时表或者文件排序来完成分组。</p><p>如果GROUP BY后没有通过ORDER BY显示指定排序列，默认排序会使用文件排序自动按照分组的字段进行排序，如果不需要排序可以使用ORDER BY NULL不使用文件排序。</p><h3 id="6-7-4-LIMIT分页优化"><a href="#6-7-4-LIMIT分页优化" class="headerlink" title="6.7.4 LIMIT分页优化"></a>6.7.4 LIMIT分页优化</h3><p>如果在进行分页查询时，如果偏移量非常大（翻页翻到非常后面的页），代价会非常大。较简单的方法就是尽可能使用索引覆盖扫描，然后做一次关联操作，这样就避免了前面在翻页时查询所有的列，也叫做“延迟关联”，先定位到要访问的记录然后关联列会原表查询所有的列。</p><h3 id="6-7-5-优化UNION操作"><a href="#6-7-5-优化UNION操作" class="headerlink" title="6.7.5 优化UNION操作"></a>6.7.5 优化UNION操作</h3><p>UNION操作都是创建并填充临时表的方式来操作，如果不是确定要取出重复的行话可以使用UNION ALL代替，因为没有ALL的话MySQL会给临时表加上DISTINCT操作，代价会非常高。</p><h3 id="6-7-6-语句中的自定义变量"><a href="#6-7-6-语句中的自定义变量" class="headerlink" title="6.7.6 语句中的自定义变量"></a>6.7.6 语句中的自定义变量</h3><p>有这些场景不能使用自定义变量：</p><ul><li>使用了自定义变量不能查询缓存</li><li>不能在常量或者标示符的地方使用自定义变量（表、列名，LIMIT子句中）</li><li>自定义变量的生命周期是一个数据库连接中</li><li>自定义变量在MySQL 5.0之前对大小写敏感</li></ul><p>如果用MySQL构建队列表，历史已完成消息归档、和未处理的消息分表。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好好理解解析优化过程的知识，可以帮助更好的理解表和索引的内容。优化的三点建议：不做、少做、快速的做。例如，不做-查缓存，少做-减少扫描等等这些。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>BaronSchwartz, PeterZaitsev, VadimTkachenko, et al. 高性能MySQL[M]. 电子工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      第五章主要介绍了怎么设计良好的库表结构、如何建立良好的索引，这些只是高性能的前提，完整的高效还需要优秀的查询。本章主要将会介绍MySQL优化器的内部机制，如何执行查询，介绍查询的执行计划，同时也讨论了MySQL优化器的不足。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》阅读笔记 第五章 创建高性能索引</title>
    <link href="https://296245482.github.io/2019/04/30/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/"/>
    <id>https://296245482.github.io/2019/04/30/《高性能MySQL》阅读笔记-第五章-创建高性能索引/</id>
    <published>2019-04-30T15:50:17.000Z</published>
    <updated>2019-04-30T15:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-1-索引基础"><a href="#5-1-索引基础" class="headerlink" title="5.1 索引基础"></a>5.1 索引基础</h2><p>索引类型：B-Tree，哈希索引，空间数据索引，全文索引….</p><ol><li><p>同样是使用B-Tree索引，MyISAM使用前缀压缩技术使得索引更小，但InnoDB按原数据进行存储。MyISAM索引通过数据的物理位置引用被索引的行，InnoDB根据主键引用被索引的行。</p></li><li><p>对于多个索引，必须严格按从左到右顺序使用，缺一不可，并且， 如果中间某个列使用的是范围查询，其索引右边的列都无法使用到索引。</p></li><li><p>哈希索引主要基于哈希表的实现，只有精确匹配索引所有列的查询才有效。</p></li><li><p>哈希索引数据不是按照索引值顺序存储的，无法用于排序。</p></li><li><p>哈希索引不支持部分索引列匹配查找，哈希索引始终是使用索引列的全部内容来计算哈希值，例如（A,B）上的索引，如果查询条件只有A则无法使用索引。</p></li><li><p>哈希索引同样也只支持等值比较，范围查找无法使用哈希索引。</p></li></ol><h2 id="5-2-索引的优点"><a href="#5-2-索引的优点" class="headerlink" title="5.2 索引的优点"></a>5.2 索引的优点</h2><p>略</p><h2 id="5-3-高性能索引策略（重点阅读）"><a href="#5-3-高性能索引策略（重点阅读）" class="headerlink" title="5.3 高性能索引策略（重点阅读）"></a>5.3 高性能索引策略（重点阅读）</h2><h3 id="5-3-1-独立的列："><a href="#5-3-1-独立的列：" class="headerlink" title="5.3.1 独立的列："></a>5.3.1 独立的列：</h3><p>查询中索引不能是表达式的一部分，不能是函数的参数，应该始终将索引单独放在比较符号一侧。</p><h3 id="5-3-2-前缀索引："><a href="#5-3-2-前缀索引：" class="headerlink" title="5.3.2 前缀索引："></a>5.3.2 前缀索引：</h3><p>索引的选择性 = 不重复的值（distinct后的值） / 数据表的总记录数，在选择前缀索引时这个比值越大说明性能越接近全字段索引，效果最优。</p><p>在处理BLOB、TEXT或者VARCHAR类型的列时，如果他们本身的长度很长，MySQL是不允许索引这些列的完整长度的，这里必须使用前缀索引，所以我们只选取这些值的前缀建立索引，具体选择多长的长度需要考察这个前缀的选择性，让其尽量接近完整列的选择性。</p><p>前缀索引可以使索引更小、更快，但是使用前缀索引后就不能对该列做ORDER BY和GROUP BY了。</p><p>不同的情况下也可以考虑后缀索引，依靠MySQL内的字符串转向实现。</p><p>总结来说使用前缀索引的情况有： ①字符串的列 ②字符串本身就比较长，并且字符串开始的几个字符差异比较大，能够进行很好的区分 ③只是前一半的字符的选择性就已经接近了全字段索引的选择性了。</p><h3 id="5-3-3-多列索引"><a href="#5-3-3-多列索引" class="headerlink" title="5.3.3 多列索引"></a>5.3.3 多列索引</h3><p>在多个列上分别建立索引，然后一起使用实际都可能会是全盘扫描。例如：SELECT xxx FROM xxx WHERE a = 1 OR b = 1; 但在新版本的MySQL中会自动处理好这两个单列索引，OR条件转化为union、AND查询转化为intersection的两表查询(这种合并的优化策略并不可取，只是说明索引建的很糟糕，MySQL会稍作修正)。</p><p>查询之前explain看看是否有索引合并，看看自己的索引是否建的足够好。</p><h3 id="5-3-4-索引的组合顺序"><a href="#5-3-4-索引的组合顺序" class="headerlink" title="5.3.4 索引的组合顺序"></a>5.3.4 索引的组合顺序</h3><p>对于一个单个查询，查询条件是A=1和B=2，创建索引应该是(A,B)还是(B,A)呢？单单对这条SQL，可以考察WHERE条件中列的选择性，选择性越高、数据基数越少越靠前。</p><p>这里定的顺序只是针对这单条SQL，并且是特定的查询值，这样对其他查询不公平，可能会使得某些查询不如预期，甚至影响服务器的整体性能。</p><p>具体在实际中如何选择顺序我们主要依靠经验，往往选择性更高的列放在前面，如果对于WHERE子句中的数据固定就考察数据基数，当然这些方法也不是一概而论，都需要具体分析。</p><h3 id="5-3-5-聚簇索引"><a href="#5-3-5-聚簇索引" class="headerlink" title="5.3.5 聚簇索引"></a>5.3.5 聚簇索引</h3><p>这里谈论InnoDB中的聚簇索引，简单理解就是数据行实际上存在索引的叶子页上，所以一个表只能有一个聚簇索引,也可以理解为聚簇索引就是“表”。InnoDB通过主键建立聚簇索引，没有定义主键则选择一个唯一的为空索引替代，如果没有唯一非空索引就会隐式定义一个主键。InnoDB的每一个叶子页占的空间是指定的。</p><p>聚簇索引优点：①数据查询时只需要一次的磁盘I/O。 ②索引和数据保存在一起，因此获取数据的速度会更快。 ③如果使用覆盖索引，就可以直接在取到的页中值，不需要再次回表查询。</p><p>缺点：①聚簇索引的分页设计，对于I/O密集的有性能提升，但是数据存在内存中就没有优势了。 ②数据插入如果不是按照主键顺序插入会慢。 ③更新聚簇索引的代价大。 ④插入一条数据到一个满页时，会导致页分裂，占用更多空间。 ⑤页分裂多了数据不连续带来查询慢的问题。 ⑥非聚簇索引访问需要两次索引查找，因为这类索引叶子中保存的不是指向物理地址的指针，而是行的主键值。</p><p>和MyISAM引擎的区别主要在于：MyISAM的索引和普通索引没有太大区别，叶子节点上就是索引值；InnoDB的叶子节点包含主键值、事务ID、事务和MVCC的回滚指针、以及剩余的列，相当于包含了表，还有一点不同上面也提到过，InnoDB中非聚簇索引叶子指向的是主键值，不是一般索引的“行指针”（设计目的是减少行移动、数据页分裂的维护工作）。</p><p>从下面这张图很容易可以看出区别：</p><div align="center"><img src="https://i.loli.net/2019/04/29/5cc69b670e276.png"></div><p>最好避免随机的聚簇索引，特别是I/O密集的应用，最好是索引数据和应用无关，最简单的方式是使用AUTO_INCREMENT的列。实际中也推荐按照主键顺序插入数据，并且尽可能的使用单条增加的聚簇值来插入新行。</p><p>如下两个图：</p><div align="center"><img src="https://i.loli.net/2019/04/29/5cc69f835877e.png"></div><br><div align="center"><img src="https://i.loli.net/2019/04/29/5cc69f98422c3.png"></div><p>索引值是否是顺序的决定了聚簇索引插入的效率，顺序的话就直接插入到后面，达到页大小时就往后放；非顺序的情况的话就会出现新行随机插入已有的位置之间，这会导致频繁的页分裂，页也会变得稀疏不规则，如果插入过程中目标页已刷到磁盘不在缓存中的话就还需要从磁盘读取到内存中，会有大量的随机I/O。</p><h3 id="5-3-6-覆盖索引"><a href="#5-3-6-覆盖索引" class="headerlink" title="5.3.6 覆盖索引"></a>5.3.6 覆盖索引</h3><p>简单来说就是突破单纯考虑WHERE条件来创建索引，考虑到整个查询，<strong>让MySQL可以使用索引就直接获取到数据</strong>。如果一个索引包含（覆盖）所有需要查询的字段，就可以称为覆盖索引。查询只需要扫描索引不需要回表。</p><p>优势：①I/O数据量减少，数据更容易放入内存 ②聚簇索引是按值顺序存储的，范围查询会有更少的I/O ③如MyISAM引擎，内存只缓存索引，数据要依赖操作系统来缓存，一次数据访问就需要一次系统调用 ④对于聚簇索引如InnoDB中，通过非聚簇索引查询时得到主键，进一步要对主键索引进行查询，如果将二级主键做到覆盖查询，可以减少查询次数。</p><h3 id="5-3-7-使用索引扫描来排序"><a href="#5-3-7-使用索引扫描来排序" class="headerlink" title="5.3.7 使用索引扫描来排序"></a>5.3.7 使用索引扫描来排序</h3><p>EXPLAIN语句中type为index才使用索引，不要被Extra中的“Using index”搞混淆了。</p><p>MySQL有两种方式生成有序的结果，通过排序操作，或者按索引顺序扫描。只有当索引的顺序和ORDER BY子句的顺序完全一致时，MySQL才能够使用索引来对结果排序。</p><h3 id="5-3-8-压缩（前缀压缩）索引"><a href="#5-3-8-压缩（前缀压缩）索引" class="headerlink" title="5.3.8 压缩（前缀压缩）索引"></a>5.3.8 压缩（前缀压缩）索引</h3><p>稍作了解，MyISAM压缩索引的机制是，先保存索引块的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分。</p><p>压缩块使用更少的空间，但是每个索引都依赖于前面的值，所以MyISAM查找时只能从头开始扫描，这也是一个CPU内存资源和磁盘之间的一个资源权衡。</p><h3 id="5-3-9-冗余和重复索引"><a href="#5-3-9-冗余和重复索引" class="headerlink" title="5.3.9 冗余和重复索引"></a>5.3.9 冗余和重复索引</h3><p>MySQL允许创建冗余或者重复索引，但是这是很不推荐的，因为优化器都会单独进行处理，严重影响性能，因此在表创建时要避免这种情况。</p><p>例如已有索引(A,B)再创建(A)就是冗余索引，只要索引效果不同，或者是相同覆盖、不同类型也不算是冗余索引。</p><p>有种特殊情况也需要冗余索引，比如已有索引已经很大了，扩展会影响其他的使用该索引的查询性能。</p><h3 id="5-3-10-未使用的索引"><a href="#5-3-10-未使用的索引" class="headerlink" title="5.3.10 未使用的索引"></a>5.3.10 未使用的索引</h3><p>服务器有一些永远都用不到的索引，一些常见的服务器工具可以帮我们定位，例如Percona Server或者MariaDB中的userstates变量的开启，可以查询每个索引的使用频率，Percona Toolkit中的pt-index-usage了解每天查询的报告。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>大多数情况还是使用B-Tree索引，其他索引都还是要依据特殊情况来考察。</p></li><li><p>总体来看，查询时尽可能选择合适的索引避免单行查询，尽量使用数据的原始顺序避免排序，尽可能使用索引覆盖查询消除回表查询。</p></li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>BaronSchwartz, PeterZaitsev, VadimTkachenko, et al. 高性能MySQL[M]. 电子工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      这个笔记主要是写一些自己原来理解不足、可能在以后可能会遇到的一些点，做下记录，日后自己也能回顾重温。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL单SQL查询剖析</title>
    <link href="https://296245482.github.io/2019/03/28/MySQL%E5%8D%95%E6%9D%A1SQL%E6%80%A7%E8%83%BD%E6%9F%A5%E8%AF%A2/"/>
    <id>https://296245482.github.io/2019/03/28/MySQL单条SQL性能查询/</id>
    <published>2019-03-28T08:32:36.000Z</published>
    <updated>2019-03-28T08:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL单SQL查询剖析"><a href="#MySQL单SQL查询剖析" class="headerlink" title="MySQL单SQL查询剖析"></a>MySQL单SQL查询剖析</h1><h2 id="SHOW-PROFILE"><a href="#SHOW-PROFILE" class="headerlink" title="SHOW PROFILE"></a>SHOW PROFILE</h2><p>SHOW PROFILE命令是在MySQL 5.1之后引入的，相对于通常来说我们使用的EXPLAIN、slow query log指令来说，SHOW PROFILE可以给出SQL语句执行中各个资源的消耗情况，比如CPU、IO等，如果打开会对服务器上执行的所有语句在他们执行的过程中记录服务器的具体工作时间。这个内部工具默认是关闭的，如下指令查询打开状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| @@profiling |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|           0 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>需要如下指令打开：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET profiling = 1;</span><br></pre></td></tr></table></figure><p>开启之后这个工具会将所有的运行信息记录到一张临时表，并且给接下里的查询赋予一个编号，记录的信息包括运行的具体语句，每个语句在各个部分消耗的时间信息。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW PROFILES;</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line">| Query_ID | Duration   | Query                                             |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line">|        1 | 0.02267950 | <span class="keyword">show</span> <span class="keyword">tables</span>                                       |</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.00135350</span> | <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> studentId = <span class="number">1</span> <span class="keyword">limit</span> <span class="number">1</span> |</span><br><span class="line">|        <span class="number">3</span> | <span class="number">0.00134375</span> | <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> studentId = <span class="number">2</span> <span class="keyword">limit</span> <span class="number">1</span> |</span><br><span class="line">|        <span class="number">4</span> | <span class="number">0.00008225</span> | <span class="keyword">show</span> profils                                      |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到，这个工具给每个运行过的查询语句都给了一个编号，并且可以看到精度很高的响应时间，可这样的时间对于分析一个查询的效率来说还是不够的，进一步的话我们有SHOW PROFILE指令，可以进一步确认更加细节的时间消耗：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 3;</span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line">| Status               | Duration |</span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line">| starting             | 0.000092 |</span><br><span class="line">| checking permissions | 0.000008 |</span><br><span class="line">| Opening tables       | 0.000021 |</span><br><span class="line">| init                 | 0.000039 |</span><br><span class="line">| System <span class="keyword">lock</span>          | <span class="number">0.000010</span> |</span><br><span class="line">| optimizing           | <span class="number">0.000011</span> |</span><br><span class="line">| <span class="keyword">statistics</span>           | <span class="number">0.114235</span> |</span><br><span class="line">| preparing            | <span class="number">0.000033</span> |</span><br><span class="line">| executing            | <span class="number">0.000004</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>         | <span class="number">0.019880</span> |</span><br><span class="line">| <span class="keyword">end</span>                  | <span class="number">0.000014</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>            | <span class="number">0.000016</span> |</span><br><span class="line">| closing <span class="keyword">tables</span>       | <span class="number">0.000015</span> |</span><br><span class="line">| freeing items        | <span class="number">0.000036</span> |</span><br><span class="line">| cleaning up          | <span class="number">0.000031</span> |</span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>这里仅仅只是运行时间的展示，要获取更加细节的信息展示可以在SHOW PROFILE指令中加入更多的细节部分：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io,memory,swaps for query 3;</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+-------+</span></span><br><span class="line">| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out | Swaps |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+-------+</span></span><br><span class="line">| starting             | 0.000092 | 0.000000 |   0.000000 |            0 |             0 |     0 |</span><br><span class="line">| checking permissions | 0.000008 | 0.000000 |   0.000000 |            0 |             0 |     0 |</span><br><span class="line">| Opening tables       | 0.000021 | 0.000000 |   0.000000 |            0 |             0 |     0 |</span><br><span class="line">| init                 | 0.000039 | 0.000000 |   0.000000 |            0 |             0 |     0 |</span><br><span class="line">| System <span class="keyword">lock</span>          | <span class="number">0.000010</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| optimizing           | <span class="number">0.000011</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| <span class="keyword">statistics</span>           | <span class="number">0.114235</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |          <span class="number">856</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| preparing            | <span class="number">0.000033</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| executing            | <span class="number">0.000004</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>         | <span class="number">0.019880</span> | <span class="number">0.004000</span> |   <span class="number">0.000000</span> |         <span class="number">1248</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| <span class="keyword">end</span>                  | <span class="number">0.000014</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>            | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| closing <span class="keyword">tables</span>       | <span class="number">0.000015</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| freeing items        | <span class="number">0.000036</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| cleaning up          | <span class="number">0.000031</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+-------+</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>这里仅仅只是我的一个示例，详细展示了这条SQL在哪部分花费时间比较多，让我们可以有针对的去优化我们的数据库或者SQL。</p><p>但SHOW PROFILE只告诉了我们哪些活动花费了最多的时间，但并没有告诉我们为什么导致这样，至于怎么优化就要继续进一步研究这个子任务。</p><h2 id="SHOW-STATUS"><a href="#SHOW-STATUS" class="headerlink" title="SHOW STATUS"></a>SHOW STATUS</h2><p>SHOW STATUS命令的作用是计数器，可以从服务器级别看到MySQL从启动开始计算的各类操作的运行次数。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS;</span><br></pre></td></tr></table></figure><p>这么听起来SHOW STATUS并不是一个SQL运行的剖析工具，他无法给出一个操作的具体消耗时间，他的作用在于运行完某条SQL之后，可以观察各个计数器的数量变化，也就是说在运行完一条指令后，可以知道它各类活动的频繁程度，例如读索引、创建临时表等，缺点也就在于无法给出每个的时间消耗。</p><p>重置大多数状态变量到0：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; FLUSH STATUS;</span><br></pre></td></tr></table></figure><p>EXPLAIN指令也可以获取很多类似的信息，但是EXPLAIN只是一个估计的结果，SHOW STATUS是实际结果的统计。</p><p>进一步的用法中，SHOW STATUS还可以对结果进行模糊搜索，例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE 'qcache%';</span><br></pre></td></tr></table></figure><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>慢查询日志是比较常见的剖析单条SQL效率的方法，开启之后在数据库运行过程中，会根据相关的慢查询设置将查询较慢的SQL语句进行记录。</p><p>可以通过查看MySQL变量的方法，查看慢查询的打开关闭情况：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLE LIKE '%slow_query_log&amp;';</span><br></pre></td></tr></table></figure><p>其中slow_query_log表示的慢查询的开关状态，slow_query_log_file表示慢查询日志的记录位置。</p><p>开启慢查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>日志中记录的慢查询是时间低于某个配置的时间来的，配置的时间也是个MySQL的变量值：long_query_time，查看和设置这个配置值。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%long_query_time%'</span><br><span class="line"></span><br><span class="line">mysql&gt; set global long_query_time = 4;</span><br></pre></td></tr></table></figure><h2 id="Performance-Schema"><a href="#Performance-Schema" class="headerlink" title="Performance Schema"></a>Performance Schema</h2><p>Performance Schema是一个功能强大、较为底层的性能监控工具，可以自定义信息收集粒度，对于查找MySQL的性能瓶颈，查找long-SQL原因都有相关帮助。</p><p>这个功能是MySQL自带的，5.6.6版本中默认打开，可以使用如下指令查看打开情况。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'performance_schema'</span><br></pre></td></tr></table></figure><p>关于精细化控制主要通过performance_schema库下的各个setup表来进行配置，具体不在此描述。</p><p>日常可能使用的比较多的功能可能有：</p><ul><li>获取执行最多的SQL语句</li><li>单条执行时间最常的SQL语句</li><li>操作最频繁的表</li><li>从未被使用过的索引</li><li>文件IO消耗</li></ul><p>performance schema的统计数据非常强大，具体在此不展开描述，如有想法进一步了解可以Google相关的文章进一步了解。</p><p>ref:</p><ol><li><a href="http://keithlan.github.io/2015/07/17/22_performance_schema/" target="_blank" rel="noopener">http://keithlan.github.io/2015/07/17/22_performance_schema/</a></li><li><a href="https://cloud.tencent.com/developer/article/1072598" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1072598</a></li><li><a href="https://allenhu0320.iteye.com/blog/2186156" target="_blank" rel="noopener">https://allenhu0320.iteye.com/blog/2186156</a></li></ol>]]></content>
    
    <summary type="html">
    
      在定位了具体需要优化的单条SQL之后，我们可以有针对的对这条查询详细探究，获悉这条SQL为什么慢，这里主要介绍MySQL自带的相关方法，帮助我们很方便的测量各个部分花费的时间，这里简要介绍几个获取方法SHOW STATUS、SHOW PROFILE、慢查询日志、Performance Schema，具体的如何优化优化方法将在其他文章中阐述。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>Java实现LRU算法</title>
    <link href="https://296245482.github.io/2018/09/24/Java%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95/"/>
    <id>https://296245482.github.io/2018/09/24/Java实现LRU算法/</id>
    <published>2018-09-24T08:09:29.000Z</published>
    <updated>2018-09-24T08:09:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java里自带LinkedHashMap实现"><a href="#Java里自带LinkedHashMap实现" class="headerlink" title="Java里自带LinkedHashMap实现"></a>Java里自带LinkedHashMap实现</h2><p>Java里的LinkedHashMap就是以一个双向链表来实现的，可以制定按查询排序或者是插入排序，使用时继承改集合，初始化时指定好一些参数、重写删除最老元素的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Java自带的LinkedHashMap实现LRU缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseLinkedHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserLinkedHashMap&lt;Integer, String&gt; LRUCache = <span class="keyword">new</span> UserLinkedHashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        LRUCache.put(<span class="number">1</span>, <span class="string">"One"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">4</span>, <span class="string">"four"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = LRUCache.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; item = it.next();</span><br><span class="line">            System.out.println(<span class="string">"key: "</span> + item.getKey() + <span class="string">" / value: "</span> + item.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserLinkedHashMap</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.removeEldestEntry(eldest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><p>数组实现比较简单，元素用数组存储，有涉及到顺序修改时，将数组整体移位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组实现的LRU算法，刚使用的放在数组最后，主要考察元素是否已经存在和缓存是否已满这两种情况，使用与否只考察了set，没考察get</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayLRU</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已有元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用数组存储元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] listArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayLRU</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        listArray = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="keyword">this</span>.maxSize = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listArray[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveArrayElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步查看是否已存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> existLocation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item == listArray[i]) &#123;</span><br><span class="line">                exist = <span class="keyword">true</span>;</span><br><span class="line">                existLocation = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分情况查看是否已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; maxSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existLocation &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                    moveArrayElement(listArray, existLocation, size - <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                listArray[size - <span class="number">1</span>] = item;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listArray[size] = item;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!exist || item == listArray[<span class="number">0</span>]) &#123;</span><br><span class="line">                moveArrayElement(listArray, <span class="number">0</span>, maxSize - <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item != listArray[maxSize - <span class="number">1</span>]) &#123;</span><br><span class="line">                moveArrayElement(listArray, existLocation, maxSize - <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            listArray[maxSize - <span class="number">1</span>] = item;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cacheSize = <span class="number">5</span>;</span><br><span class="line">        MyArrayLRU lru = <span class="keyword">new</span> MyArrayLRU(cacheSize);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lru.insert(<span class="number">1</span>);</span><br><span class="line">            lru.insert(<span class="number">2</span>);</span><br><span class="line">            lru.insert(<span class="number">3</span>);</span><br><span class="line">            lru.insert(<span class="number">4</span>);</span><br><span class="line">            lru.insert(<span class="number">5</span>);</span><br><span class="line">            lru.insert(<span class="number">2</span>);</span><br><span class="line">            lru.insert(<span class="number">3</span>);</span><br><span class="line">            lru.insert(<span class="number">5</span>);</span><br><span class="line">            lru.insert(<span class="number">4</span>);</span><br><span class="line">            lru.insert(<span class="number">4</span>);</span><br><span class="line">            lru.insert(<span class="number">5</span>);</span><br><span class="line">            lru.insert(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cacheSize; i++) &#123;</span><br><span class="line">                System.out.println(lru.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"成功插入"</span> + count + <span class="string">"次元素."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><p>上述的数组实现在需要改变顺序的时候需要数组整体复制移位，资源消耗较大，链表在元素的增删上效率较高，对于存储的key-value节点的链表，链表的外部还套了一层key与节点一一对应，这个key可以用来判断元素是否已经存在，用于获取节点，获取链表大小等操作，弥补了链表一定功能的缺失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的实现思路，Node形成的链表外部再加一层，用于弥补链表的随机查找，链表头部为最近使用的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedLRU</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录头尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外层套一层HashMap，内部使用以Node为节点的链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; keyNodeMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedLRU</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        head = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        <span class="keyword">this</span>.keyNodeMap = <span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node node = keyNodeMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">            node = keyNodeMap.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            <span class="keyword">if</span> (keyNodeMap.size() == maxSize) &#123;</span><br><span class="line">                keyNodeMap.remove(removeTail());</span><br><span class="line">            &#125;</span><br><span class="line">            keyNodeMap.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将该节点移动到头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.pre != <span class="keyword">null</span> || node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到尾部节点（最没被使用）的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastKey = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tail.pre != head) &#123;</span><br><span class="line">            Node lastNode = tail.pre;</span><br><span class="line">            lastKey = lastNode.key;</span><br><span class="line">            lastNode.pre.next = tail;</span><br><span class="line">            tail.pre = lastNode.pre;</span><br><span class="line">            lastNode = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写toString()，按链表顺序打印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        Node item = head;</span><br><span class="line">        <span class="keyword">while</span> (item != tail.pre) &#123;</span><br><span class="line">            res += <span class="string">"["</span> + item.next.key + <span class="string">", "</span> + item.next.value + <span class="string">"] "</span>;</span><br><span class="line">            item = item.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLinkedLRU lru = <span class="keyword">new</span> MyLinkedLRU(<span class="number">5</span>);</span><br><span class="line">        lru.set(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lru.set(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        lru.set(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        lru.set(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        lru.set(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        lru.set(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">        lru.set(<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">        lru.set(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lru.set(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        lru.set(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        lru.set(<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">        lru.get(<span class="number">5</span>);</span><br><span class="line">        System.out.println(lru.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node pre;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        key = k;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有任何疑问欢迎随时讨论，关于LRU的算法实现思路肯定不止这么几种，应该还会有效率更高的思路</strong></p>]]></content>
    
    <summary type="html">
    
      操作系统里的LRU算法，Least Recently Used大家都很熟悉，在操作系统里学习过，Java里的LinkedHashMap已经就是LRU的典型应用.
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="Java" scheme="https://296245482.github.io/tags/Java/"/>
    
      <category term="OS" scheme="https://296245482.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>数据库、缓存与事务的一些学习</title>
    <link href="https://296245482.github.io/2018/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%BC%93%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"/>
    <id>https://296245482.github.io/2018/07/31/数据库、缓存与事务的一些学习/</id>
    <published>2018-07-30T16:02:06.000Z</published>
    <updated>2018-07-30T16:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存同步的两个主流策略"><a href="#缓存同步的两个主流策略" class="headerlink" title="缓存同步的两个主流策略"></a>缓存同步的两个主流策略</h2><p>在不同的请求并行的向缓存请求和更新数据时，因为一些诡异的时序安排，很容易引起某一个请求读到脏数据的情况</p><ul><li><h3 id="Set策略"><a href="#Set策略" class="headerlink" title="Set策略"></a>Set策略</h3><blockquote><p>查询时，先查缓存，命中直接返回，不命中查数据库，并将数据库的值<strong>set</strong>到缓存中<br>更新时，先更新数据库，再将值<strong>set</strong>到缓存中</p></blockquote></li></ul><p>这种方法只适合读多写少的情况，保持缓存在大多数时间都是可以取得到值的。其他情况下经常会出现缓存不一致问题，该方法还是需要慎用。</p><ul><li><h3 id="Delete策略"><a href="#Delete策略" class="headerlink" title="Delete策略"></a>Delete策略</h3></li></ul><p>Delete策略分为两种，主要的区别在于淘汰缓存的时机：</p><blockquote><p>查询时，和set策略一致，先查缓存，不命中查数据库，并将值写到缓存</p></blockquote><p>第一种：</p><blockquote><p>更新时，先淘汰缓存，再更新数据库</p></blockquote><p>这种情况下，会有A淘汰缓存后，B缓存不命中，从数据库中将值更新到缓存，A再更新数据库的情况。这种情况下，有一种叫<strong>延时淘汰</strong>机制，在更新情况下，可以设计一个异步操作，休眠1s再次淘汰缓存，但如果第二次淘汰发生错误了，依旧还是会产生不一致的问题。</p><p>第二种：</p><blockquote><p>更新时，先更新数据库，再淘汰缓存</p></blockquote><p>这种策略解决了delete策略第一种提到的问题，但也有新的问题，比如A查询没命中缓存去查数据库，读到一个旧值，此时B将新值写入数据库，然后淘汰缓存，此时A再将读到的值更新到缓存，同样产生了不一致。但此时的情况比上面的情况好很多，因为出现的概率会小很多，A的查询数据库时间是远小于B的写数据库的时间。</p><p>但是，如果一定要解决这个问题，同样可以参考delete策略中的第一种里面的延时删除策略，每次发起更新时，更新数据库并且淘汰缓存后，添加一个异步的消息队列，在一定的延时后再次淘汰缓存即可解决问题。</p><p><strong>值得一提的是，现在比较公认的更新策略最后一种，来自于<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">Cache-Aside pattern</a>，并且有如下缓存数据库同步策略的定义：</strong></p><ol><li>失效：从cache读取，没命中，读数据库，成功后将值放入缓存。</li><li>命中：从cache读取，命中并返回。</li><li>更新：把要更新的数据先存到数据库，成功后让缓存失效。</li></ol><h2 id="缓存的使用事项"><a href="#缓存的使用事项" class="headerlink" title="缓存的使用事项"></a>缓存的使用事项</h2><ul><li><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3></li></ul><p>一个写多读少的业务流程，需要经常更新数据库并且淘汰缓存，在做查询的时候，大多数时候都是缓存未命中，导致大部分请求全部打到数据库上。</p><ul><li><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3></li></ul><p>一批缓存使用了相同的过期时间，导致某一个时刻，一大批缓存过期失效，请求全部转发到数据库，导致数据库压力徒增。</p><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>原子性、一致性、隔离性、持久性</p><h3 id="数据库并发的问题"><a href="#数据库并发的问题" class="headerlink" title="数据库并发的问题"></a>数据库并发的问题</h3><blockquote><h4 id="丢失更新："><a href="#丢失更新：" class="headerlink" title="丢失更新："></a>丢失更新：</h4><p>第一类丢失更新：在没有事务隔离的情况下，AB同时操作某个值，同时读取，B做出修改并且提交更改，A发生异常回滚数据，导致B已完成的数据更新丢失。</p><p>第二类丢失更新：同上述例子，AB同时更新某值，在B提交更新之后，A也提交更新，B提交的更新就被A提交的覆盖。</p></blockquote><blockquote><h4 id="脏读："><a href="#脏读：" class="headerlink" title="脏读："></a>脏读：</h4><p>A对某一数据进行了修改，但是该修改还未提交数据库，这时B也访问该数据，然后使用了这个还没有成功更新的新数据，读到了脏数据。</p></blockquote><blockquote><h4 id="不可重复读："><a href="#不可重复读：" class="headerlink" title="不可重复读："></a>不可重复读：</h4><p>AB同时操作一段数据，A在一次操作中需要多次读取该数据，但是在这期间，B修改了该值并且完成了提交，这样A下次读到的数据就不一样。</p></blockquote><blockquote><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>同样也是AB同时操作一段数据，但和不可重复读不同的是，B不是对某数据的值进行修改，而是新增或者删除了某数据，A在这前后读取到的数据记录数发生了变化，这要区别于不可重复读。</p></blockquote><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>READ_UNCOMMITTED 未提交读</li></ul><p>允许其他事物读到未提交的数据</p><ul><li>READ_COMMITTED 提交读</li></ul><p>保证数据得到提交后才能被另一个事务读取到</p><ul><li>REPEATABLE_READ 可重复读</li></ul><p>保证一个事务在前后两次获取到的数据都是一样的</p><ul><li>SERIALIZABLE 顺序读</li></ul><p>事务的处理串行化</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">第一类丢失更新</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">第二类丢失更新</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">提交读</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">串行化</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><p><strong>MySQL采用的默认隔离级别是可重复读级别</strong></p><h3 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h3><ol><li><a href="https://www.cnblogs.com/johnsblog/p/6426287.html" target="_blank" rel="noopener">https://www.cnblogs.com/johnsblog/p/6426287.html</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=404308725&amp;idx=1&amp;sn=1a25ce76dd1956014ceb8a011855268e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=404308725&amp;idx=1&amp;sn=1a25ce76dd1956014ceb8a011855268e&amp;scene=21#wechat_redirect</a></li><li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside</a></li><li><a href="https://blog.csdn.net/d8111/article/details/2595635" target="_blank" rel="noopener">https://blog.csdn.net/d8111/article/details/2595635</a></li></ol>]]></content>
    
    <summary type="html">
    
      在前段时间的开发中，遇到了关于数据库与缓存更新策略上的问题，在我的项目中可能不涉及多线程的高频读写和高一致性要求，但了解数据库的这些相关知识还是很有必要的。文中也包括一些数据库的事务隔离级别，缓存的一些使用等。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
      <category term="Redis" scheme="https://296245482.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句写法优化</title>
    <link href="https://296245482.github.io/2018/07/04/SQL%E8%AF%AD%E5%8F%A5%E5%86%99%E6%B3%95%E4%BC%98%E5%8C%96/"/>
    <id>https://296245482.github.io/2018/07/04/SQL语句写法优化/</id>
    <published>2018-07-04T09:26:36.000Z</published>
    <updated>2018-07-04T09:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EXPLAIN用法"><a href="#EXPLAIN用法" class="headerlink" title="EXPLAIN用法"></a>EXPLAIN用法</h2><p>在不清楚索引等情况下，对于自己效率不太确定的SELECT语句，在SQL语句前加入 <code>EXPLAIN</code> 关键字，该语句会返回你这条SQL语句的执行计划，比如有没有用索引，有没有全盘扫描，可供效率参考，<code>EXPLAIN</code>运行返回的结果如下(例如：<code>EXPLAIN SELECT id,name,score FROM student_score</code>)：</p><p><code>id</code>: SELECT编号，出现顺序排序<br><code>select_type</code>: 查询的类型，简单或复杂<br><code>table</code>: 表名，或者其他查询语句ID<br><code>partition</code>: 该表的分区信息<br><code>type</code>: 访问类型<br><code>possible_keys</code>: 查询可能会用到的索引<br><code>key</code>: 实际使用的索引<br><code>key_len</code>: 使用的索引长度<br><code>ref</code>: 哪些列或常量被用于查找索引列上的值<br><code>rows</code>: 估计读取的行数<br><code>filtered</code>: 返回结果的行数占需要度的航的百分比<br><code>Extra</code>: MySQL解决查询的额外信息</p><p>其中，访问类型：ALL, index,  range, ref, eq_ref, const, system, NULL，从左到右性能从差到好，当自己的语句出现靠左侧的type时要考虑优化自己的索引或者查询语句</p><p>注：MYSQL 5.6.3以前只能<code>EXPLAIN SELECT</code>； MYSQL5.6.3以后就可以<code>EXPLAIN SELECT、UPDATE、DELETE</code></p><p><strong>有了<code>EXPLAIN</code>语句，通过SQL语句的执行计划，我们可以很快定位到查询语句过慢的问题。</strong></p><h2 id="NULL与空值"><a href="#NULL与空值" class="headerlink" title="NULL与空值"></a>NULL与空值</h2><p>MySQL中的“空值”和“NULL”是有不同的，并且在对NULL进行 <strong>‘&lt;’、’&gt;’、’=’</strong> 操作时肯定很多人都遇到过坑，在对一些NULL值的判断若理解不到位可能会导致得到的查询结果和你所设想的SQL结果不一致的情况。</p><p>‘’ - 空值在MySQL中不占空间，而NULL是占用空间的，好比一个容器，空值代表容器内是真空的，NULL则代表容器内装满了空气。B树索引时不会存储NULL值，如果索引的字段可以为NULL，索引的效率会下降很多。</p><p><code>IS NOT NULL</code>和<code>!=NULL</code>是不一样的操作，对于 <strong>“=、&lt;、&gt;…”</strong> 等这些判断来说，<code>NULL</code>表示什么都不是，任何运算符的操作结果都是false，对于<code>NULL</code>的计算只能使用<code>IS NULL</code>来判断，一般情况下推荐使用<code>IS NOT NULL</code>，对于<code>!= NULL</code>来说返回的结果永远都是0行，并且不会有任何语法错误。</p><p>但是如果一定要使用<code>!= NULL</code>的话，可以通过set ANSI_NULLS off让<code>IS NOT NULL</code>和<code>!= NULL</code>等价。</p><h2 id="避免查询的全盘扫描，保证索引正确使用"><a href="#避免查询的全盘扫描，保证索引正确使用" class="headerlink" title="避免查询的全盘扫描，保证索引正确使用"></a>避免查询的全盘扫描，保证索引正确使用</h2><ol><li>在所有的SQL中尽量避免type为ALL的全盘扫描，在<code>WHERE</code>和<code>ORDER BY</code>涉及的字段上建立索引，否则数据量过大时经常会导致超时。</li></ol><ol start="2"><li><code>WHERE</code>子句中尽量减少<code>!=</code>和<code>&lt;&gt;</code>操作符，这种情况下索引可能不会被使用进而进行全盘扫描。</li></ol><ol start="3"><li><p>尽量避免将会在<code>WHERE</code>子句中涉及的字段设置可以为null，索引中有NULL值时索引效率会下降很多，例如还有如下情况：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,score <span class="keyword">FROM</span> STUDENT_SCORE <span class="keyword">WHERE</span> score <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p> <code>is null</code>语句的使用会放弃使用索引，进而进行全盘扫描，在设计中可以将null值替换为默认值”0”，上述语句<code>WHERE</code>后的语句可以改为<code>score = 0</code>。</p></li></ol><ol start="4"><li><p>将<code>WHERE</code>子句中的<code>OR</code>条件改写，拆成两条语句的<code>UNION</code>操作，例如下列语句将会进行全表扫描：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score = <span class="number">100</span> <span class="keyword">OR</span> socre = <span class="number">0</span></span><br></pre></td></tr></table></figure><p> 可以改成这样的查询提升查询效率：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score = <span class="number">100</span></span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score = <span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><p>若查询中经常涉及<code>LIKE</code>与通配符<code>%</code>的查询可以考虑在原表中加入全文索引，如下：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%long%'</span></span><br></pre></td></tr></table></figure><p> 这句SQL语句若要考虑优化可以将<code>name</code>字段设置成全文索引，提高效率。全文索引的使用方法参考<a href="https://blog.csdn.net/u011734144/article/details/52817766/" target="_blank" rel="noopener">MySQL使用全文索引</a></p></li></ol><ol start="6"><li><p><code>IN</code>和<code>NOT IN</code>的使用大多也会放弃使用索引，进行全表扫描，对于连续值的情况，使用<code>BETWEEN</code>代替<code>IN</code>,例如：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score <span class="keyword">IN</span> (<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p> 改写为：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score <span class="keyword">BETWEEN</span> <span class="number">98</span> <span class="keyword">and</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></li><li><p>如果在<code>WHERE</code>子句中有参数，也会导致全表扫描，例如：下述SQL语句：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> <span class="keyword">name</span>=@<span class="keyword">name</span></span><br></pre></td></tr></table></figure><p> 因为SQL只有在运行时才会解析局部变量，SQL执行计划在编译时生成，可这个时候变量的值还是未知的，因而无法作为索引的输入项，实际执行时只能进行全表扫描。可以改为强制查询使用索引：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WITH</span>(<span class="keyword">INDEX</span>(<span class="string">"索引名"</span>)) <span class="keyword">WHERE</span> <span class="keyword">name</span>=@<span class="keyword">name</span></span><br></pre></td></tr></table></figure></li><li><p>避免在<code>WHERE</code>子句中进行表达式操作，例如：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score/<span class="number">2</span>=<span class="number">50</span></span><br></pre></td></tr></table></figure><p> 为了避免放弃索引而全表扫描，应改为</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score=<span class="number">2</span>*<span class="number">50</span></span><br></pre></td></tr></table></figure></li><li><p>避免在<code>WHERE</code>子句中的函数操作，如下：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=<span class="string">'cheng'</span> <span class="comment">--name以cheng开头</span></span><br></pre></td></tr></table></figure><p> 为了避免放弃索引，而全表扫描改写为name字段添加全文索引的通配符匹配，或者使用<code>WHERE name LIKE &#39;cheng%&#39;</code>。</p></li></ol><ol start="10"><li>除了上述的8和9外，我们尽量避免在<code>WHERE</code>子句中的<code>=</code>左边进行函数、算数运算或其他表达式的运算，保证索引的正确使用。</li></ol><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><ol><li><code>WHERE</code>子句中的条件是<code>OR</code>关系的话，加索引将不会有任何作用。考虑改写为两条SQL语句的<code>UNION ALL</code>操作。</li></ol><ol start="2"><li>数据重复并且分布均匀的表字段建了索引一般不会对查询效率的提升有很大影响。</li></ol><ol start="3"><li>符合索引从左到右使用索引中的字段，可以只是用一部分，但必须是最左侧的部分。所以复合索引把最常用的字段放在最左边，重要程度一次递减。</li></ol><ol start="4"><li>复合索引中任何字段含有NULL值，那么该字段对复合索引是无效的。</li></ol><ol start="5"><li><code>LIKE &#39;%abc%&#39;</code>不会使用索引而<code>LIKE &#39;abc%&#39;</code>会使用索引。</li></ol><ol start="6"><li>使用<code>EXISTS</code>和<code>NOT EXISTS</code>代替<code>IN</code>和<code>NOT IN</code>，后者不会使用索引而进行全表扫描。</li></ol><h2 id="其他Tips"><a href="#其他Tips" class="headerlink" title="其他Tips"></a>其他Tips</h2><ol><li>能设计成数字型的字段就不设计成字符型。因为在处理查询等操作时字符型会挨个比较没一个字符，而数字型比较一次就够了。</li></ol><ol start="2"><li>使用<code>varchar/nvarchar</code>代替<code>char/nchar</code>，前者是边长字段，可以节省空间，并且字段越小搜索效率越高。</li></ol><h3 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h3><ol><li><a href="https://blog.csdn.net/wendy432/article/details/52319908" target="_blank" rel="noopener">https://blog.csdn.net/wendy432/article/details/52319908</a></li><li><a href="https://blog.csdn.net/u011734144/article/details/52817766/" target="_blank" rel="noopener">https://blog.csdn.net/u011734144/article/details/52817766/</a></li><li><a href="https://www.cnblogs.com/softidea/p/5977860.html" target="_blank" rel="noopener">https://www.cnblogs.com/softidea/p/5977860.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      本文从SQL语句的层面上介绍了SQL语句的优化写法，当数据量达到一定程度时将会提高查询效率。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>Java容器源码阅读记录</title>
    <link href="https://296245482.github.io/2018/06/12/Java%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>https://296245482.github.io/2018/06/12/Java容器源码阅读记录/</id>
    <published>2018-06-12T02:32:36.000Z</published>
    <updated>2018-06-12T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先还是要放出这张大图，想要详细理解容器源码，他们之间的继承实现关系必须了熟于心。</p><div align="center"><img src="https://i.loli.net/2018/06/12/5b1f39ccf3c6a.png" width="500"></div><h2 id="ArrayList相关"><a href="#ArrayList相关" class="headerlink" title="ArrayList相关"></a>ArrayList相关</h2><h3 id="ArrayList初始化"><a href="#ArrayList初始化" class="headerlink" title="ArrayList初始化"></a>ArrayList初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的EMPTY_ELEMENTDATA值为0，初始化ArrayList时默认长度为零，不拥有默认大小</p><h3 id="ArrayList的扩容"><a href="#ArrayList的扩容" class="headerlink" title="ArrayList的扩容"></a>ArrayList的扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if</span></span><br><span class="line"><span class="comment"> * necessary, to ensure that it can hold at least the number of elements</span></span><br><span class="line"><span class="comment"> * specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if real element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for empty table. It's already supposed to be</span></span><br><span class="line">        <span class="comment">// at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensureCapacity方法可由开发者调用，当调整的容量低于DEFAULT_CAPACITY时，只要有容量扩大需求，都会至少保证DEFAULT_CAPACITY=10的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际扩容时调用的是grow()方法，可以看到，ArrayList在有扩容需求时会将原来的数组中的元素使用Arrays.copyOf方法复制到一个新的数组中，并且每次容量的增长为原来容量的1.5倍。</p><p><strong>因此在使用ArrayList时，因为扩容代价较高，应尽量指定容量</strong></p><h3 id="ArrayList中的modCount"><a href="#ArrayList中的modCount" class="headerlink" title="ArrayList中的modCount"></a>ArrayList中的modCount</h3><p>modCount变量用于记录该ArrayList的变更次数，包括add,remove,addAll,removeRange,clear方法，每操作一次这些方法，modCount的值就++。</p><p>modCount继承自AbstractList，该类中有iterator()方法使用了一个私有内部成员类Itr，Itr中有一个属性expectedModCount，在初始化的时候expectedModCount = modCount。</p><p>在对一个集合对象进行迭代操作时，如果不限制集合元素的操作，那么一些add或者remove操作可能会引起迭代错误，因此在AbstractList中使用了判断modCount和expectedModCount是否相等来规避这些风险。</p><h2 id="HashMap相关"><a href="#HashMap相关" class="headerlink" title="HashMap相关"></a>HashMap相关</h2><h3 id="HashMap容量"><a href="#HashMap容量" class="headerlink" title="HashMap容量"></a>HashMap容量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap的构造函数，参数一是桶容量大小，参数二是扩容阈值，默认0.75，即使只传桶容量，也会调用上述构造方法，loadFactor=0.75。还有一个变量叫threshold，threshold = loadFactor * capacity，就是扩容的阈值，当达到这个容量的时候就需要出发扩容机制，0.75时可以理解为装满四分之三就触发扩容。</p><p>HashMap的初始化在不指定容量大小的时候是16，并且保证初始化时容量大小总是2的n次方大小，根据HashCode查找数组位置的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns index for hash code h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>length设置成2的n次方是有意义的，比如这里和HashCode的“与”运算，和2的n次方-1这样的全1二进制做与，可以保证数组的每个位置的index都有，比如1110，那么HashMap的数组1位置就永远不可能有值能放过来，因为没有数能和1110做“与”结果为1。（）</p><h3 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new entry with the specified key, value and hash code to</span></span><br><span class="line"><span class="comment"> * the specified bucket.  It is the responsibility of this</span></span><br><span class="line"><span class="comment"> * method to resize the table if appropriate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Subclass overrides this to alter the behavior of put method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 大小超过threshold，扩容两倍</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为HashMap的容量设置成2的n次方有利于提高利用率，所以当map中包含的Entry的数量大于等于threshold，触发扩容时扩大的容量倍数也是2倍。</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet底层使用HashMap实现，构造方法上使用HashMap基本也是使用HashMap的，主要的区别在于HashMap存储键值对，HashSet仅仅存储对象，因为HashMap中的key是惟一的，所以这个特性被HashSet使用来保证存储对象的唯一性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span></span><br><span class="line"><span class="comment"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * If this set already contains the element, the call leaves the set</span></span><br><span class="line"><span class="comment"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span></span><br><span class="line"><span class="comment"> * element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在往HashSet里插入元素时，调用HashMap的put方法，如果该元素已经存在就返回false，不存在就返回true。</p><p>在我们日常使用HashSet时，要注意自己重写hashCode()和equal()方法，这样才能确保自己的比较的正确性。</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable基本可以等价于HashMap，大体上只有这些区别：</p><ol><li><p>HashTable是线程安全的，多个线程可以共享一个HashTable，HashMap不是synchronized的，但是ConcurrentHashMap是HashTable的一种替代，并且扩展性比HashTable更好。</p></li><li><p>HashMap的迭代器是Iterator，是fail-fast迭代器，当有其他线程改变HashMap的结构时就会抛出ConcurrentModificationException，而HashTable使用的是enumerator迭代器，不是fail-fast的。</p></li><li><p>单线程环境下，HashMap的性能比HashTable好。</p></li></ol><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h3 id="LinkedHashMap的有序性"><a href="#LinkedHashMap的有序性" class="headerlink" title="LinkedHashMap的有序性"></a>LinkedHashMap的有序性</h3><p>LinkedHashMap和HashMao的主要区别在于前者的Entry是用一个双向链表维护的，这个链接列表定义了迭代的顺序，并且该迭代顺序是由插入顺序或者访问顺序决定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>LinkedHashMap中的accessOrder()来决定迭代顺序，为true则按访问顺序排序，越近访问的位置越靠后，false为按照插入顺序，最近插入的位置越靠后。</p><p>基本的初始化等操作全部与HashMap原理一致，只是多了recordAccess方法，在每次操作时重新排序，将最近操作的Entry放到最后。因为链表的移位操作，增加、删除操作都是常量级别的消耗，所以不会带来性能的损失。</p><h3 id="LinkedHashMap与LRU缓存"><a href="#LinkedHashMap与LRU缓存" class="headerlink" title="LinkedHashMap与LRU缓存"></a>LinkedHashMap与LRU缓存</h3><p>LRU - Last Recent Use，由于LinkedHashMap能存储最近访问的功能，我们可以使用它来设计缓存，LinkedHashMap本身已经把最常读取的放在链表的最后。</p><p>在实现一个简单的LRU缓存功能时，我们只需要设置一个阈值，重写LinkedHashMap的removeEldestEntry方法，去除那些很久没有访问的Entry就行。</p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>继承自HashSet，基于LinkedHashMap，存的内容只有值，并且也维护着一个运行所有条目的双重链接列表。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基于链表实现，和ArrayList的主要区别就在于访问的性能，LinkedList的插入删除操作更好，但是随即访问操作要比ArrayList差。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><p>看源码过程中看到了很多transient关键字，简单了解了一下：</p><p>Java中的序列化和反序列化：</p><ol><li>序列化：将一个对象转换成一串二进制表示的字节数组，通过保存或转移这些自己数据来达到持久化的目的，例如写到文件中等。</li><li>反序列化：将字节数组重新构造成对象。</li></ol><p>java的transient关键字在序列化过程中为我们提供了便利，对需要通过序列化实现持久化的对象，首先实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><p>这样HashMap等容器在序列化的时候，其容量大小，扩容阈值等这些容器内部变量就不会被序列化存储。</p>]]></content>
    
    <summary type="html">
    
      了解Java中的容器，仅仅了解一些显著的区别和特性是不太够的，更应该了解每个容器的具体实现机制，初始化机制，扩容机制，了解一些常见操作中他们的性能情况，本文在阅读个容器源码的过程中记录下这方面的一些特性
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="Java" scheme="https://296245482.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>避免嵌套条件式</title>
    <link href="https://296245482.github.io/2018/05/31/%E9%81%BF%E5%85%8D%E5%B5%8C%E5%A5%97%E6%9D%A1%E4%BB%B6%E5%BC%8F/"/>
    <id>https://296245482.github.io/2018/05/31/避免嵌套条件式/</id>
    <published>2018-05-31T15:11:36.000Z</published>
    <updated>2018-05-31T15:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="嵌套条件式"><a href="#嵌套条件式" class="headerlink" title="嵌套条件式"></a>嵌套条件式</h2><p>今天在面对一个一般复杂的业务情况时，对着活动图写了一个嵌套三层的逻辑判断，review代码时被别人提醒了，在指导下也将嵌套三层的逻辑判断压缩到约等于两层，顿时代码整体简洁已读，结构也很清晰，不禁感慨如果处处注意代码的优美和易读性，写代码其实也可以是很美的事情。</p><p>写代码经常会遇到逻辑稍微复杂点的情况，比如逻辑分支众多，直接理解来写代码可能会出现嵌套多个 “if-else” 的情况，嵌套层数大于两层以后代码对于后人来看增加了很多成本。</p><p>遇到复杂逻辑的流程时，需要分解成简单易懂的逻辑代码，我能想到的方法有：拆分代码逻辑使功能模块化、使用卫语句。</p><h2 id="使用函数模块化"><a href="#使用函数模块化" class="headerlink" title="使用函数模块化"></a>使用函数模块化</h2><p>对一些嵌套的逻辑，可以提取出其中的一部分代码，封装成一个函数来使用，对于多种情况下可能涉及到的差不多的操作，也可以直接提取出其中相同的部分来模块化实现。</p><h2 id="卫语句"><a href="#卫语句" class="headerlink" title="卫语句"></a>卫语句</h2><p>卫语句的核心在于：在多层逻辑判断中，如果某个分支出现的请看股较于其他分支比较特殊，给它提出来单独处理，如果它真的发生了，做一些必要的整理工作，然后返回退出。</p><p>一下是一个卫语句的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isHuman())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个人"</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(isAlien())&#123;</span><br><span class="line">         System.out.println(<span class="string">"是个外星人"</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(isChenglong())&#123;</span><br><span class="line">            System.out.println(<span class="string">"是成龙"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码如果再多几层嵌套，给他人看起来的时候可能需要花不少时间理清楚你这里面不同情况的分支是什么条件过来的。</p><p>使用卫语句来改造就能在保持逻辑的情况下更加清晰明了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isHuman())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个人"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(isMan())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个外星人"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(isChenglong())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是成龙"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>卫语句可以把我们的视线从异常处理中解放出来，集中精力到正常处理的代码中。</p><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p><strong>想要自己的代码在复杂逻辑下依旧保持美感和清晰的结构，关键还是理解整个代码逻辑，能清楚的认识到每一个情况的输入输出，充分认识到其中每个情况的条件出现概率，例如提取出出现概率罕见的情况直接单独检查，及早的依据结果返回。</strong></p>]]></content>
    
    <summary type="html">
    
      写代码经常会遇到逻辑稍微复杂点的情况，比如分支众多，直接理解来写代码可能会出现嵌套多个 &quot;if-else&quot; 的情况，嵌套层数大于两层以后代码对于后人来看增加了很多成本，我们要学会让自己的代码保持美感
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="Java" scheme="https://296245482.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP/UDP &amp; 可靠的传输</title>
    <link href="https://296245482.github.io/2018/05/08/TCP:UDP%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BC%A0%E8%BE%93/"/>
    <id>https://296245482.github.io/2018/05/08/TCP:UDP实现可靠的传输/</id>
    <published>2018-05-08T15:58:00.000Z</published>
    <updated>2018-05-08T15:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>春招的面试被问到过UDP怎么实现可靠的传输，当时都是仅仅凭着自己对TCP三次握手四次挥手的理解自己瞎说，面试官的反馈肯定都是不满意，说起来自己其实对TCP的理解也不深入，它是如何保证可靠传输的几个机制都都只知道这几个模糊的概念，花点时间好好看看，写下这篇文章让自己加深印象</p><h1 id="TCP实现可靠传输的几个机制"><a href="#TCP实现可靠传输的几个机制" class="headerlink" title="TCP实现可靠传输的几个机制"></a>TCP实现可靠传输的几个机制</h1><h2 id="确认机制"><a href="#确认机制" class="headerlink" title="确认机制"></a>确认机制</h2><p>序号——序号的增加是和传输的字节相关的。TCP在传输数据时的序列号（Sequence Number）不是以报文段来进行编号的，而是将该连接生存周期内的所有数据当做一个字节流，按照字节流中的每个字节进行编号。每个TCP数据包中的数据大小不一定相同。在三次握手的连接建立之初，双方都会规定好初始的序号x和y，TCP每次传送的序号字段值表示所要传送的本报文中的第一个字节的序号。</p><p>确认——TCP的数据确认送达（ACK），是对接收到的数据的最高序列号的确认，并向发送方返回下一次期望的TCP数据包的序列号。如A-&gt;B，A当前序号是100，数据长度是50，B返回的确认号就是151给A。</p><p>效率提高——提高网络利用率和传输效率，例如TCP可以一次确认多个数据报，如果接收方接收到了151，201，301，那么只需要对301数据报确认即可，收到301意味着前面的都已经确认过。</p><p>不能跳着确认——接收端在确认时，只能确认最大的连续收到的包，例如发送端发了1，2，3，4，接收端收到了1，2，4，只能回3，回复连续收到的最大包+1的序号。</p><p>如果发送方在规定的时间内没有收到返回，超过规定时间后就将未被确认的数据重新发送，接收方如果收到的数据存在差错，也会直接丢弃此报文，不返回确认信息。更多详细的重传机制后面细讲。</p><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>有了前面的确认机制，在数据报传送发生错误时，需要重传机制来保证传输完整。</p><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>如果是阻塞式传输的话，意味着没有收到确认就一直四等，造成巨大的资源浪费，所以设定一个时间timeout，分为两种，一种是只重传超过timeout的包，另一种是重传timeout之后的所有包。</p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>相对于超时重传，这种机制不以时间驱动而以数据驱动，前一种方法是超过一定时间未收到就重传，快速重传是连续收到几次相同的ACK就重传，例如A-&gt;B，连续发1、2、3、4、5，假设期间2数据报因为某些原因没有到达，则B在收到3、4、5的时候继续返回序号为2的ACK，A在连续收到3次序号为2的ACK后，得知序号为2的包没有到达，马上重传2。</p><p><div align="center"><img src="https://i.loli.net/2018/05/19/5affe6a70cfdd.png"></div><br>但也存在问题，A并不知道2之后的是不是被对方收到了其他的数据，不知道三次返回的序号2是谁传回来的。</p><h3 id="Selective-Acknowledgment-SACK"><a href="#Selective-Acknowledgment-SACK" class="headerlink" title="Selective Acknowledgment(SACK)"></a>Selective Acknowledgment(SACK)</h3><p>这种方式基于快速重传的方法，只是在TCP头里加一个叫SACK的东西，接收方在接收缓冲区中记录好我当前缺少的部分，返回时向发送方汇报缺失内容。</p><p><div align="center"><img src="https://i.loli.net/2018/05/19/5affeda69255a.jpg" width="500"></div><br>这种优化的快速重传需要两方协议都支持才行。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>TCP主要解决的是可靠的传输和包乱序的问题，滑动窗口是TCP引入的一种网络控流技术，TCP必须要知道网络传输中实际的数据处理带宽或者说是数据处理速度，这样才不会引起网络拥塞导致丢包。</p><h3 id="AdvertisedWindow"><a href="#AdvertisedWindow" class="headerlink" title="AdvertisedWindow"></a>AdvertisedWindow</h3><p>Sliding Window是一个被设计来做网络流控的技术，TCP头里有一个字段叫Advertised-Window，这个字段是接收端返回给发送端告诉发送端自己还有多少的缓冲区可以接收数据，下次发送端发送数据就会按照这个接收端的处理能力来发送数据。要理解滑动窗口先看一下TCP缓冲区：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0cd52d370b0.jpg" width="400"></div></p><blockquote><p>接收端里的LastByteRead表示上层应用正在读的地方，NextByteExpected表示收到的连续包的最后一个位置，LastByteRcved表示收到的包最后的一个位置，连续包和最后位置的包之间是有间隙的，表示中间还是有数据没有到达</p><p>发送端中LastByteRead表示被接收端Ack过的位置，LastByteSent表示发送出去了，但是还没收到成功确认的Ack，LastByteWritten表示上层应用正在写的地方。</p></blockquote><p>因此，前面说到过的AdvertisedWindows的计算方式为:</p><blockquote><p>AdvertiedWindow = MaxRcvBuffer - LastByteRcvd - 1<br>这个窗口就是用来控制发送数据大小的，确保接收方可以处理</p></blockquote><h3 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h3><p>下面是发送方的滑动窗口的示意图：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0ce040420bf.png" width="600"></div></p><blockquote><p>黑框部分也就是滑动窗口</p><ol><li>Category#1代表的是已经收到Ack确认的数据</li><li>Category#2代表已经发送但是还未收到Ack的数据</li><li>Category#3代表按照接收方缓冲区大小计划发出的数据</li><li>Category#4代表窗口以外的数据，接收方空间不足以现在发送</li></ol></blockquote><p>下面是一个接收端使用滑动窗口控制发送端的过程，结合上述描述和AdvertiedWindow配合理解：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0ce2072bdd7.png" width="600"></div></p><h3 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h3><p>在上图中，可以看到接收端数据处理很缓慢，返回的Window大小越来越小，最后一次返回的Window = 0，这种情况下，发送端知道接收端缓冲区已经没有地方了就不会再发送数据了，这就有个问题，发送端不发数据了接收方也没法通知发送方Window Size可用了。</p><p>为了解决这个问题，TCP使用了Zero Window Probe技术，在Window = 0之后，发送方会发ZWP包给接收方，让接收方来Ack他现在的Window大小，不同的实现情况下会设置不同的次数和不同的时间。</p><p><strong>PS：*</strong>该技术可能会被DDoS攻击，攻击者在TCP连接建立完成后向发送方不断的发送带有Window = 0的Ack，发送方就停止发送并且发送ZWP包，服务器资源就被渐渐耗尽*</p><h3 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h3><p>像上面的那种情况，如果接收方太忙，不能及时取走Receive Window里的数据，会导致最后只有几个字节的Window来传输数据，而一次传输只传这么少量的数据很不划算，如果数据包用不满整个带宽的话会浪费大量的资源。</p><p>这个问题的解决思路从接收端和发送端两边都有解决思路，接收端设置一个阈值，小于该阈值的情况下都是Ack(0)把Window关了，等到处理后大小够大了以后再重设Window；发送端主要思路是做延时处理，设置阈值，或者是收到Ack才发数据，其他时间段都是做数据积累</p><h2 id="拥塞算法"><a href="#拥塞算法" class="headerlink" title="拥塞算法"></a>拥塞算法</h2><p>TCP利用滑动窗口做到了流控还是不够，还需要知道整个网络上的事。例如如果网络延时增加，导致大量丢包，没有拥塞处理的情况下，TCP只会重传数据，这样只会导致网络的负担更加重，甚至拖垮一个网络。因此TCP必须知道整个网络的情况，而且主体的设计思想为：<strong>TCP不是一个自私的协议，当拥塞发生时，做出自我牺牲，让出资源出来，不抢占少占有。</strong></p><p>拥塞算法主要是四个部分：</p><ol><li>慢启动</li><li>拥塞避免</li><li>拥塞发生时快速重传</li><li>快速恢复</li></ol><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>慢启动的过程很好理解，就是在加入连接的过程中，一点点提速。如下图所示，连接建立好以后，cwnd慢慢增加，每当收到一个Ack，cwnd线性上升，每隔一个RTT，cwnd指数上升。上升也不是无止境的，有一个slow start threshold，当cwnd &gt; ssthresh时进入“拥塞避免算法”。</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0cfaa95150d.jpg" width="500"></div></p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>慢启动在双重递增的情况下可以达到无限增长，因此设置了一个ssthresh，cwnd到达ssthresh后，每当收到一个Ack：cwnd增加一个自己的倒数，每过一个RTT：cwnd自增1。</p><h3 id="拥塞时状态"><a href="#拥塞时状态" class="headerlink" title="拥塞时状态"></a>拥塞时状态</h3><p>当发生丢包时，有两种解决思路：</p><p>第一种是降低sshthresh的值（sshthresh = cwnd / 2），重置cwnd为1，重新开始慢启动的过程；</p><p>第二点是快速重传的方法，cwnd保留一半（cwnd = cwnd / 2），sshthresh = cwnd，进入快速恢复方法。</p><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>快速重传和快速恢复一般一起使用，前面说过快速重传有3次Duplicated Acks。</p><p>当发送方连续收到三个重复确认时，就把慢开始门限减半（cwnd = cwnd / 2），这是为了预防网络发生拥塞。注意，接下来不执行慢开始算法。</p><p>由于发送方现在认为网络很可能没有发生特别严重的阻塞（如果发生了严重阻塞的话，就不会一连有好几个报文段到达接收方，就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口的值不设为1个MSSS），而是把拥塞窗口的值设为慢开始门限减半后的值，而后开始执行拥塞避免算法，线性地增大拥塞窗口。</p><hr><h1 id="UDP实现可靠传输的思路"><a href="#UDP实现可靠传输的思路" class="headerlink" title="UDP实现可靠传输的思路"></a>UDP实现可靠传输的思路</h1><p>UDP不属于连接型协议，且资源消耗小，处理速度快，通常音频、视频传输时用的比较多，因为即使偶尔丢失一两个数据包，也不会对结果产生太大影响。</p><p>UDP要实现可靠传输，在传输层已经无法保证可靠传输了，只能依靠应用层来实现，实现的要点主要是确认机制、重传机制、窗口确认等。目前已经有的开源项目基于UDP实现了可靠的数据传输：RUDP、RTP、UDT。</p><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><p>RUDP：提供拥塞控制的改进、重发机制及淡化服务器算法等机制，允许TCP方式下的流控行为。</p><p>RTP：该协议被用来解决音频和视频传输的功能，解决了TCP在这些应用上“慢”启动带来的问题，传输模型可以单点和多点传输。RTP协议在应用层工作，利用多路复用和校验，消除丢包带来的影响。RTP提供的服务包括有效的负载识别、序列编号、时间戳和投递监听。</p><p>UDT：主要目的是支持高速广域网上的海量数据传输，引入了拥塞控制和数据可靠性控制机制，面向连接的双向应用协议，发送方依据流量控制和速率控制来发送应用数据，接收者接受数据包和控制包，根据接收到的包发送控制包。</p><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>主要解决两个问题：丢包和包的顺序的问题</p><p>解决思路：</p><ol><li>给每个包编号，按照包的顺序接收并存储</li><li>增加确认机制</li><li>重传机制</li><li>窗口流量控制机制</li></ol><p>-&gt; ①UDP数据包+序列号 ②UDP数据包+时间戳 ③应答确认</p><p>TCP已经足够复杂了，用UDP来实现TCP其实是个很没意义的事情，如果不考虑完整实现TCP的功能，从这个角度来想，依据特定的需求来看，如果希望在某些情况下UDP优于TCP，一定是放弃了一些TCP重要的东西，比如以下两种情况：</p><ol><li>业务逻辑上允许信息丢失，例如在同步状态中，状态信息是有实效性，那么过期的信息是可以允许丢失的，每个新的状态信息都可以取代旧的信息，只是允许这样操作的业务场景非常少。</li><li>允许包乱序，只要和TCP一样在每个包上加上个序号即可，这样的复杂程度也很高，和TCP对比起来唯一的优势也就是在即使中间有包晚到了，业务层也可以先开始处理后面先到的包开始处理。</li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/ns_code/article/details/32707721" target="_blank" rel="noopener">https://blog.csdn.net/ns_code/article/details/32707721</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11609.html</a></li><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11564.html</a></li><li><a href="https://blog.csdn.net/pangyemeng/article/details/50387078" target="_blank" rel="noopener">https://blog.csdn.net/pangyemeng/article/details/50387078</a></li><li><a href="https://blog.csdn.net/kennyrose/article/details/7557917" target="_blank" rel="noopener">https://blog.csdn.net/kennyrose/article/details/7557917</a></li></ol>]]></content>
    
    <summary type="html">
    
      春招的面试被问到过两次UDP怎么实现可靠的传输，说起来自己对TCP是如何保证可靠传输的几个机制都不太熟，写下这篇文章让自己加深印象
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="网络" scheme="https://296245482.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown学习，一些常用小技巧</title>
    <link href="https://296245482.github.io/2018/04/24/Markdown%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://296245482.github.io/2018/04/24/Markdown一些不常见的小技巧/</id>
    <published>2018-04-24T07:43:47.000Z</published>
    <updated>2018-04-24T07:43:47.000Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为本博客的创作都是使用的Markdown，把自己平时用的比较多的Markdown语法做一个简单的记录，方便以后的取用。</p><p>本文省略了一些基本的语法，例如标题、文本强调、无序有序列表、表格绘制等内容</p><h2 id="详细技巧"><a href="#详细技巧" class="headerlink" title="详细技巧"></a>详细技巧</h2><h3 id="图片位置大小"><a href="#图片位置大小" class="headerlink" title="图片位置大小"></a>图片位置大小</h3><p>使用标准的图片插入方法<code>![]()</code>不能对图片进行位置和大小进行控制，默认居左并且按图片大小显示。</p><p>使用的方法是借助HTML标签来实现，在<code>&lt;div&gt;</code>标签中使用<code>align</code>、<code>width</code>、<code>height</code>等来控制，如下所示：</p><p><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 默认显示效果</span><br><span class="line">![](../imgs/20180424_1.jpeg)</span><br><span class="line">2. 位置大小控制效果</span><br><span class="line">&lt;div align = &quot;center&quot;&gt;&lt;img src = &quot;https://i.loli.net/2018/04/24/5adf182dd449f.jpeg&quot; width = &quot;100&quot;/&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><strong>默认效果</strong><br><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" alt=""><br><strong>控制后的效果</strong></p><div align="center"><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" width="100"></div><p><em>PS</em>: 在文中插入图片除了可以将照片放在本地直接获取外，可以使用一些免费的CDN，例如<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>，可以将图片传到线上，使用链接获取。</p><hr><h3 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h3><p>图文混合编排也可以使用HTML中的标签来实现，如下所示的文字靠左，图片靠右的实现方式：</p><p><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src = &quot;https://i.loli.net/2018/04/24/5adf182dd449f.jpeg&quot; align = &quot;right&quot; width = &quot;300&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><strong>实例效果</strong></p><div><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" align="right" width="300"></div><p>描述1</p><p>描述2</p><p>描述3</p><p>描述4</p><p>这是一个表情表的介绍，为了凑字数多写一点，让在不同的屏幕大小的情况下都能看得出他的自动换行效果，紫薯布丁紫薯布丁紫薯布丁…..</p><hr><h3 id="段前缩进"><a href="#段前缩进" class="headerlink" title="段前缩进"></a>段前缩进</h3><p>在Markdown里，在一个空格或者TAB之后的其他缩进会默认被无视，因此需要使用<code>&amp;ensp;</code> - 半角空格 或者 <code>&amp;emsp;</code> - 全角空格来实现缩进<br><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这&amp;ensp;中&amp;ensp;间&amp;ensp;有&amp;ensp;半&amp;ensp;角&amp;ensp;空&amp;ensp;格</span><br><span class="line">&amp;emsp;&amp;emsp;这之前有全角空格</span><br></pre></td></tr></table></figure></p><p><strong>实例效果</strong></p><p>这&ensp;中&ensp;间&ensp;有&ensp;半&ensp;角&ensp;空&ensp;格</p><p>&emsp;&emsp;这之前有全角空格</p><hr><h3 id="加强代码块"><a href="#加强代码块" class="headerlink" title="加强代码块"></a>加强代码块</h3><p>将需要高亮的代码块包裹在如下的格式内即可：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;```语言名</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>Python效果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> somefunc(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><p>在hexo中的 <code>front-matter</code> 中填入 <code>toc: true</code> 即可</p><p>目录生成效果如本文所示</p><hr><h3 id="插入公式-MathJax方法"><a href="#插入公式-MathJax方法" class="headerlink" title="插入公式 MathJax方法"></a>插入公式 MathJax方法</h3><p>网上有很多教程的方法，大多数都是在hexo中安装上MathJax，这里介绍一种较为简洁的方法，在你文章的<code>front-matter</code>中插入一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/x-mathjax-config"</span>&gt;</span><br><span class="line">MathJax.Hub.Config(&#123;</span><br><span class="line">tex2jax: &#123;<span class="attr">inlineMath</span>: [[<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">'\\('</span>,<span class="string">'\\)'</span>]]&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">" async</span></span><br><span class="line"><span class="string">  src="</span>https:<span class="comment">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"&gt;</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>之后，文中的公式两边加上$符号即可显示出公式，如下的<code>$E=mc^2$</code>和<code>$f(x) = x^2$</code>分别显示出了两个公式：</p><p>$E=mc^2$</p><p>$f(x) = x^2$</p><hr><h3 id="插入LaTeX公式"><a href="#插入LaTeX公式" class="headerlink" title="插入LaTeX公式"></a>插入LaTeX公式</h3><p>首先一个简单的示例，下述公式写法为：<code>$f&#39;(x\_0)=\lim_{\Delta x\to 0} \frac{f(x\_0+\Delta x) - f(x\_0)}{\Delta x}$</code></p><p>$f’(x_0)=\lim_{\Delta x\to 0} \frac{f(x_0+\Delta x) - f(x_0)}{\Delta x}$</p><p>常见的总结如下：</p><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center"><code>\\(x^y\\)</code></td><td style="text-align:center">\(x^y\)</td></tr><tr><td style="text-align:center"><code>\\(x^{y^z}\\)</code></td><td style="text-align:center">\(x^{y^z}\)</td></tr><tr><td style="text-align:center"><code>\\(x_i\\)</code></td><td style="text-align:center">\(x_i\)</td></tr><tr><td style="text-align:center"><code>\\(\alpha\\)</code></td><td style="text-align:center">\(\alpha\)</td></tr><tr><td style="text-align:center"><code>\\(\beta\\)</code></td><td style="text-align:center">\(\beta\)</td></tr><tr><td style="text-align:center"><code>\\(\Delta\\)</code></td><td style="text-align:center">\(\Delta\)</td></tr><tr><td style="text-align:center"><code>$$\sum_{i=0}^n$$</code></td><td style="text-align:center">$$\sum_{i=0}^n$$</td></tr><tr><td style="text-align:center"><code>$\frac{x}{y}$</code></td><td style="text-align:center">$\frac{x}{y}$</td></tr><tr><td style="text-align:center"><code>\\(\sqrt 3\\)</code></td><td style="text-align:center">\(\sqrt 3\)</td></tr><tr><td style="text-align:center"><code>\\(\sqrt[3] 5\\)</code></td><td style="text-align:center">\(\sqrt[3] 5\)</td></tr><tr><td style="text-align:center"><code>$$\lim_{x \to 0}$$</code></td><td style="text-align:center">$$\lim_{x \to 0}$$</td></tr><tr><td style="text-align:center"><code>$$f(x): \begin{cases} x, x&gt;0 \\\ \\\ -x,x&lt;0 \end{cases}$$</code></td><td style="text-align:center">$$f(x): \begin{cases} x, x&gt;0 \\ \\ -x,x&lt;0 \end{cases}$$</td></tr></tbody></table><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="http://daniellaah.github.io/2016/Mathmatical-Formula-within-Markdown.html" target="_blank" rel="noopener">http://daniellaah.github.io/2016/Mathmatical-Formula-within-Markdown.html</a></li><li><a href="https://www.jianshu.com/p/0b257de21eb5" target="_blank" rel="noopener">https://www.jianshu.com/p/0b257de21eb5</a></li><li><a href="https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener">https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/</a></li><li><a href="http://blog.mobing.net/content/hexo/hexo-mathjax.html" target="_blank" rel="noopener">http://blog.mobing.net/content/hexo/hexo-mathjax.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      简单的学习一波Markdown，将自己平时写博客用的比较多的Markdown语法做做记录
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="个人" scheme="https://296245482.github.io/tags/%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="blog" scheme="https://296245482.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Page的个人博客搭建</title>
    <link href="https://296245482.github.io/2018/04/18/Hexo-Github-Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://296245482.github.io/2018/04/18/Hexo-Github-Page的个人博客搭建/</id>
    <published>2018-04-18T08:03:21.000Z</published>
    <updated>2018-04-18T08:03:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近开始各种地方准备春招，投递了不少简历，经历了不少面试，着实感觉自己很多地方的积累还是不够，后端研发或者是Java研发这一块，还有太多的细节没有弄清楚，很多框架的一些原理没有很好的理解，因此决定开一个博客，在平时的学习过程中不断积累，不断总结知识点。</p><p>除去hexo配置完成后的“Hello World”文章，个人博客的第一篇文章就以“Hexo+Github Page配置个人博客”为主题了。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>配置过程参考了很多现有的网站的一些过程</p><p>完成的效果是在本地创建了一份Hexo工程，通过MarkDown创作，每次生成博客网站的内容，通过SSH方式远程部署到自己的USERNAME.GitHub.io的repo上。</p><p>Hexo的初步配置参考： <a href="https://www.jianshu.com/p/e5f95eb990ad" target="_blank" rel="noopener">Mac下使用Hexo+Github搭建个人博客</a> 。</p><p>初步完成后使用了 <a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">Maupassant</a> 主题，该主题很简洁，算是我比较喜欢的类型。</p><p>初步配置完成之后，后期有很多主题内评论、语言等配置，参考了<a href="https://github.com/handsdirty/hexo_blog" target="_blank" rel="noopener">Zhesong的配置过程</a> 。</p><p><strong>详细的步骤在上述几个教程中都已经有了完备的描述</strong></p><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd [hexo本地工程路径下]</span><br><span class="line">hexo new post &apos;文章标题&apos;</span><br></pre></td></tr></table></figure><p>打开工程路径下的<code>/source/_posts/</code>路径，找到自己刚新建出来的文章，打开编辑内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate / hexo g</span><br><span class="line">hexo deploy / hexo d</span><br></pre></td></tr></table></figure></p><p>这样的操作即可将新文章内容更新到个人的博客网站上。</p><p>PS: 有一种方法可以在deploy之前预览到更新后的样子，执行完 <code>hexo generate</code> 后执行 <code>hexo server / hexo s</code> ，在浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看预览结果</p><h2 id="立个Flag"><a href="#立个Flag" class="headerlink" title="立个Flag"></a>立个Flag</h2><p>每隔几天学习完一段时间后，坚持写个人的技术博客，在详细理解之后坚持原创，记录好自己的思路和理解，坚持！</p>]]></content>
    
    <summary type="html">
    
      本文介绍了本博客的搭建方法，基于GitHub的免费page服务搭建Hexo项目，有任何问题欢迎留言讨论~
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="个人" scheme="https://296245482.github.io/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://296245482.github.io/2018/04/17/hello-world/"/>
    <id>https://296245482.github.io/2018/04/17/hello-world/</id>
    <published>2018-04-17T14:26:19.000Z</published>
    <updated>2018-04-18T08:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
