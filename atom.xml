<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jackie&#39;s blogs</title>
  
  <subtitle>佛系更新，欢迎交流</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://296245482.github.io/"/>
  <updated>2018-09-24T08:09:29.000Z</updated>
  <id>https://296245482.github.io/</id>
  
  <author>
    <name>Long Cheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java实现LRU算法</title>
    <link href="https://296245482.github.io/2018/09/24/Java%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95/"/>
    <id>https://296245482.github.io/2018/09/24/Java实现LRU算法/</id>
    <published>2018-09-24T08:09:29.000Z</published>
    <updated>2018-09-24T08:09:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java里自带LinkedHashMap实现"><a href="#Java里自带LinkedHashMap实现" class="headerlink" title="Java里自带LinkedHashMap实现"></a>Java里自带LinkedHashMap实现</h2><p>Java里的LinkedHashMap就是以一个双向链表来实现的，可以制定按查询排序或者是插入排序，使用时继承改集合，初始化时指定好一些参数、重写删除最老元素的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Java自带的LinkedHashMap实现LRU缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseLinkedHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserLinkedHashMap&lt;Integer, String&gt; LRUCache = <span class="keyword">new</span> UserLinkedHashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        LRUCache.put(<span class="number">1</span>, <span class="string">"One"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">4</span>, <span class="string">"four"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = LRUCache.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; item = it.next();</span><br><span class="line">            System.out.println(<span class="string">"key: "</span> + item.getKey() + <span class="string">" / value: "</span> + item.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserLinkedHashMap</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.removeEldestEntry(eldest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><p>数组实现比较简单，元素用数组存储，有涉及到顺序修改时，将数组整体移位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组实现的LRU算法，刚使用的放在数组最后，主要考察元素是否已经存在和缓存是否已满这两种情况，使用与否只考察了set，没考察get</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayLRU</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已有元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用数组存储元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] listArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayLRU</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        listArray = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="keyword">this</span>.maxSize = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listArray[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveArrayElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步查看是否已存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> existLocation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item == listArray[i]) &#123;</span><br><span class="line">                exist = <span class="keyword">true</span>;</span><br><span class="line">                existLocation = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分情况查看是否已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; maxSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existLocation &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                    moveArrayElement(listArray, existLocation, size - <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                listArray[size - <span class="number">1</span>] = item;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listArray[size] = item;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!exist || item == listArray[<span class="number">0</span>]) &#123;</span><br><span class="line">                moveArrayElement(listArray, <span class="number">0</span>, maxSize - <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item != listArray[maxSize - <span class="number">1</span>]) &#123;</span><br><span class="line">                moveArrayElement(listArray, existLocation, maxSize - <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            listArray[maxSize - <span class="number">1</span>] = item;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cacheSize = <span class="number">5</span>;</span><br><span class="line">        MyArrayLRU lru = <span class="keyword">new</span> MyArrayLRU(cacheSize);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lru.insert(<span class="number">1</span>);</span><br><span class="line">            lru.insert(<span class="number">2</span>);</span><br><span class="line">            lru.insert(<span class="number">3</span>);</span><br><span class="line">            lru.insert(<span class="number">4</span>);</span><br><span class="line">            lru.insert(<span class="number">5</span>);</span><br><span class="line">            lru.insert(<span class="number">2</span>);</span><br><span class="line">            lru.insert(<span class="number">3</span>);</span><br><span class="line">            lru.insert(<span class="number">5</span>);</span><br><span class="line">            lru.insert(<span class="number">4</span>);</span><br><span class="line">            lru.insert(<span class="number">4</span>);</span><br><span class="line">            lru.insert(<span class="number">5</span>);</span><br><span class="line">            lru.insert(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cacheSize; i++) &#123;</span><br><span class="line">                System.out.println(lru.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"成功插入"</span> + count + <span class="string">"次元素."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><p>上述的数组实现在需要改变顺序的时候需要数组整体复制移位，资源消耗较大，链表在元素的增删上效率较高，对于存储的key-value节点的链表，链表的外部还套了一层key与节点一一对应，这个key可以用来判断元素是否已经存在，用于获取节点，获取链表大小等操作，弥补了链表一定功能的缺失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的实现思路，Node形成的链表外部再加一层，用于弥补链表的随机查找，链表头部为最近使用的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedLRU</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录头尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外层套一层HashMap，内部使用以Node为节点的链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; keyNodeMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedLRU</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        head = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        <span class="keyword">this</span>.keyNodeMap = <span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node node = keyNodeMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">            node = keyNodeMap.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            <span class="keyword">if</span> (keyNodeMap.size() == maxSize) &#123;</span><br><span class="line">                keyNodeMap.remove(removeTail());</span><br><span class="line">            &#125;</span><br><span class="line">            keyNodeMap.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将该节点移动到头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.pre != <span class="keyword">null</span> || node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到尾部节点（最没被使用）的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastKey = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tail.pre != head) &#123;</span><br><span class="line">            Node lastNode = tail.pre;</span><br><span class="line">            lastKey = lastNode.key;</span><br><span class="line">            lastNode.pre.next = tail;</span><br><span class="line">            tail.pre = lastNode.pre;</span><br><span class="line">            lastNode = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写toString()，按链表顺序打印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        Node item = head;</span><br><span class="line">        <span class="keyword">while</span> (item != tail.pre) &#123;</span><br><span class="line">            res += <span class="string">"["</span> + item.next.key + <span class="string">", "</span> + item.next.value + <span class="string">"] "</span>;</span><br><span class="line">            item = item.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLinkedLRU lru = <span class="keyword">new</span> MyLinkedLRU(<span class="number">5</span>);</span><br><span class="line">        lru.set(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lru.set(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        lru.set(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        lru.set(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        lru.set(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        lru.set(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">        lru.set(<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">        lru.set(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lru.set(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        lru.set(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        lru.set(<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">        lru.get(<span class="number">5</span>);</span><br><span class="line">        System.out.println(lru.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node pre;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        key = k;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有任何疑问欢迎随时讨论，关于LRU的算法实现思路肯定不止这么几种，应该还会有效率更高的思路</strong></p>]]></content>
    
    <summary type="html">
    
      操作系统里的LRU算法，Least Recently Used大家都很熟悉，在操作系统里学习过，Java里的LinkedHashMap已经就是LRU的典型应用.
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="Java" scheme="https://296245482.github.io/tags/Java/"/>
    
      <category term="OS" scheme="https://296245482.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>数据库、缓存与事务的一些学习</title>
    <link href="https://296245482.github.io/2018/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%BC%93%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"/>
    <id>https://296245482.github.io/2018/07/31/数据库、缓存与事务的一些学习/</id>
    <published>2018-07-30T16:02:06.000Z</published>
    <updated>2018-07-30T16:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存同步的两个主流策略"><a href="#缓存同步的两个主流策略" class="headerlink" title="缓存同步的两个主流策略"></a>缓存同步的两个主流策略</h2><p>在不同的请求并行的向缓存请求和更新数据时，因为一些诡异的时序安排，很容易引起某一个请求读到脏数据的情况</p><ul><li><h3 id="Set策略"><a href="#Set策略" class="headerlink" title="Set策略"></a>Set策略</h3><blockquote><p>查询时，先查缓存，命中直接返回，不命中查数据库，并将数据库的值<strong>set</strong>到缓存中<br>更新时，先更新数据库，再将值<strong>set</strong>到缓存中</p></blockquote></li></ul><p>这种方法只适合读多写少的情况，保持缓存在大多数时间都是可以取得到值的。其他情况下经常会出现缓存不一致问题，该方法还是需要慎用。</p><ul><li><h3 id="Delete策略"><a href="#Delete策略" class="headerlink" title="Delete策略"></a>Delete策略</h3></li></ul><p>Delete策略分为两种，主要的区别在于淘汰缓存的时机：</p><blockquote><p>查询时，和set策略一致，先查缓存，不命中查数据库，并将值写到缓存</p></blockquote><p>第一种：</p><blockquote><p>更新时，先淘汰缓存，再更新数据库</p></blockquote><p>这种情况下，会有A淘汰缓存后，B缓存不命中，从数据库中将值更新到缓存，A再更新数据库的情况。这种情况下，有一种叫<strong>延时淘汰</strong>机制，在更新情况下，可以设计一个异步操作，休眠1s再次淘汰缓存，但如果第二次淘汰发生错误了，依旧还是会产生不一致的问题。</p><p>第二种：</p><blockquote><p>更新时，先更新数据库，再淘汰缓存</p></blockquote><p>这种策略解决了delete策略第一种提到的问题，但也有新的问题，比如A查询没命中缓存去查数据库，读到一个旧值，此时B将新值写入数据库，然后淘汰缓存，此时A再将读到的值更新到缓存，同样产生了不一致。但此时的情况比上面的情况好很多，因为出现的概率会小很多，A的查询数据库时间是远小于B的写数据库的时间。</p><p>但是，如果一定要解决这个问题，同样可以参考delete策略中的第一种里面的延时删除策略，每次发起更新时，更新数据库并且淘汰缓存后，添加一个异步的消息队列，在一定的延时后再次淘汰缓存即可解决问题。</p><p><strong>值得一提的是，现在比较公认的更新策略最后一种，来自于<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">Cache-Aside pattern</a>，并且有如下缓存数据库同步策略的定义：</strong></p><ol><li>失效：从cache读取，没命中，读数据库，成功后将值放入缓存。</li><li>命中：从cache读取，命中并返回。</li><li>更新：把要更新的数据先存到数据库，成功后让缓存失效。</li></ol><h2 id="缓存的使用事项"><a href="#缓存的使用事项" class="headerlink" title="缓存的使用事项"></a>缓存的使用事项</h2><ul><li><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3></li></ul><p>一个写多读少的业务流程，需要经常更新数据库并且淘汰缓存，在做查询的时候，大多数时候都是缓存未命中，导致大部分请求全部打到数据库上。</p><ul><li><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3></li></ul><p>一批缓存使用了相同的过期时间，导致某一个时刻，一大批缓存过期失效，请求全部转发到数据库，导致数据库压力徒增。</p><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>原子性、一致性、隔离性、持久性</p><h3 id="数据库并发的问题"><a href="#数据库并发的问题" class="headerlink" title="数据库并发的问题"></a>数据库并发的问题</h3><blockquote><h4 id="丢失更新："><a href="#丢失更新：" class="headerlink" title="丢失更新："></a>丢失更新：</h4><p>第一类丢失更新：在没有事务隔离的情况下，AB同时操作某个值，同时读取，B做出修改并且提交更改，A发生异常回滚数据，导致B已完成的数据更新丢失。</p><p>第二类丢失更新：同上述例子，AB同时更新某值，在B提交更新之后，A也提交更新，B提交的更新就被A提交的覆盖。</p></blockquote><blockquote><h4 id="脏读："><a href="#脏读：" class="headerlink" title="脏读："></a>脏读：</h4><p>A对某一数据进行了修改，但是该修改还未提交数据库，这时B也访问该数据，然后使用了这个还没有成功更新的新数据，读到了脏数据。</p></blockquote><blockquote><h4 id="不可重复读："><a href="#不可重复读：" class="headerlink" title="不可重复读："></a>不可重复读：</h4><p>AB同时操作一段数据，A在一次操作中需要多次读取该数据，但是在这期间，B修改了该值并且完成了提交，这样A下次读到的数据就不一样。</p></blockquote><blockquote><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>同样也是AB同时操作一段数据，但和不可重复读不同的是，B不是对某数据的值进行修改，而是新增或者删除了某数据，A在这前后读取到的数据记录数发生了变化，这要区别于不可重复读。</p></blockquote><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>READ_UNCOMMITTED 未提交读</li></ul><p>允许其他事物读到未提交的数据</p><ul><li>READ_COMMITTED 提交读</li></ul><p>保证数据得到提交后才能被另一个事务读取到</p><ul><li>REPEATABLE_READ 可重复读</li></ul><p>保证一个事务在前后两次获取到的数据都是一样的</p><ul><li>SERIALIZABLE 顺序读</li></ul><p>事务的处理串行化</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">第一类丢失更新</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">第二类丢失更新</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">提交读</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">串行化</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><p><strong>MySQL采用的默认隔离级别是可重复读级别</strong></p><h3 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h3><ol><li><a href="https://www.cnblogs.com/johnsblog/p/6426287.html" target="_blank" rel="noopener">https://www.cnblogs.com/johnsblog/p/6426287.html</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=404308725&amp;idx=1&amp;sn=1a25ce76dd1956014ceb8a011855268e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=404308725&amp;idx=1&amp;sn=1a25ce76dd1956014ceb8a011855268e&amp;scene=21#wechat_redirect</a></li><li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside</a></li><li><a href="https://blog.csdn.net/d8111/article/details/2595635" target="_blank" rel="noopener">https://blog.csdn.net/d8111/article/details/2595635</a></li></ol>]]></content>
    
    <summary type="html">
    
      在前段时间的开发中，遇到了关于数据库与缓存更新策略上的问题，在我的项目中可能不涉及多线程的高频读写和高一致性要求，但了解数据库的这些相关知识还是很有必要的。文中也包括一些数据库的事务隔离级别，缓存的一些使用等。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="DataBase" scheme="https://296245482.github.io/tags/DataBase/"/>
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
      <category term="Redis" scheme="https://296245482.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句写法优化</title>
    <link href="https://296245482.github.io/2018/07/04/SQL%E8%AF%AD%E5%8F%A5%E5%86%99%E6%B3%95%E4%BC%98%E5%8C%96/"/>
    <id>https://296245482.github.io/2018/07/04/SQL语句写法优化/</id>
    <published>2018-07-04T09:26:36.000Z</published>
    <updated>2018-07-04T09:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EXPLAIN用法"><a href="#EXPLAIN用法" class="headerlink" title="EXPLAIN用法"></a>EXPLAIN用法</h2><p>在不清楚索引等情况下，对于自己效率不太确定的SELECT语句，在SQL语句前加入 <code>EXPLAIN</code> 关键字，该语句会返回你这条SQL语句的执行计划，比如有没有用索引，有没有全盘扫描，可供效率参考，<code>EXPLAIN</code>运行返回的结果如下(例如：<code>EXPLAIN SELECT id,name,score FROM student_score</code>)：</p><p><code>id</code>: SELECT编号，出现顺序排序<br><code>select_type</code>: 查询的类型，简单或复杂<br><code>table</code>: 表名，或者其他查询语句ID<br><code>partition</code>: 该表的分区信息<br><code>type</code>: 访问类型<br><code>possible_keys</code>: 查询可能会用到的索引<br><code>key</code>: 实际使用的索引<br><code>key_len</code>: 使用的索引长度<br><code>ref</code>: 哪些列或常量被用于查找索引列上的值<br><code>rows</code>: 估计读取的行数<br><code>filtered</code>: 返回结果的行数占需要度的航的百分比<br><code>Extra</code>: MySQL解决查询的额外信息</p><p>其中，访问类型：ALL, index,  range, ref, eq_ref, const, system, NULL，从左到右性能从差到好，当自己的语句出现靠左侧的type时要考虑优化自己的索引或者查询语句</p><p>注：MYSQL 5.6.3以前只能<code>EXPLAIN SELECT</code>； MYSQL5.6.3以后就可以<code>EXPLAIN SELECT、UPDATE、DELETE</code></p><p><strong>有了<code>EXPLAIN</code>语句，通过SQL语句的执行计划，我们可以很快定位到查询语句过慢的问题。</strong></p><h2 id="NULL与空值"><a href="#NULL与空值" class="headerlink" title="NULL与空值"></a>NULL与空值</h2><p>MySQL中的“空值”和“NULL”是有不同的，并且在对NULL进行 <strong>‘&lt;’、’&gt;’、’=’</strong> 操作时肯定很多人都遇到过坑，在对一些NULL值的判断若理解不到位可能会导致得到的查询结果和你所设想的SQL结果不一致的情况。</p><p>‘’ - 空值在MySQL中不占空间，而NULL是占用空间的，好比一个容器，空值代表容器内是真空的，NULL则代表容器内装满了空气。B树索引时不会存储NULL值，如果索引的字段可以为NULL，索引的效率会下降很多。</p><p><code>IS NOT NULL</code>和<code>!=NULL</code>是不一样的操作，对于 <strong>“=、&lt;、&gt;…”</strong> 等这些判断来说，<code>NULL</code>表示什么都不是，任何运算符的操作结果都是false，对于<code>NULL</code>的计算只能使用<code>IS NULL</code>来判断，一般情况下推荐使用<code>IS NOT NULL</code>，对于<code>!= NULL</code>来说返回的结果永远都是0行，并且不会有任何语法错误。</p><p>但是如果一定要使用<code>!= NULL</code>的话，可以通过set ANSI_NULLS off让<code>IS NOT NULL</code>和<code>!= NULL</code>等价。</p><h2 id="避免查询的全盘扫描，保证索引正确使用"><a href="#避免查询的全盘扫描，保证索引正确使用" class="headerlink" title="避免查询的全盘扫描，保证索引正确使用"></a>避免查询的全盘扫描，保证索引正确使用</h2><ol><li>在所有的SQL中尽量避免type为ALL的全盘扫描，在<code>WHERE</code>和<code>ORDER BY</code>涉及的字段上建立索引，否则数据量过大时经常会导致超时。</li></ol><ol start="2"><li><code>WHERE</code>子句中尽量减少<code>!=</code>和<code>&lt;&gt;</code>操作符，这种情况下索引可能不会被使用进而进行全盘扫描。</li></ol><ol start="3"><li><p>尽量避免将会在<code>WHERE</code>子句中涉及的字段设置可以为null，索引中有NULL值时索引效率会下降很多，例如还有如下情况：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,score <span class="keyword">FROM</span> STUDENT_SCORE <span class="keyword">WHERE</span> score <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p> <code>is null</code>语句的使用会放弃使用索引，进而进行全盘扫描，在设计中可以将null值替换为默认值”0”，上述语句<code>WHERE</code>后的语句可以改为<code>score = 0</code>。</p></li></ol><ol start="4"><li><p>将<code>WHERE</code>子句中的<code>OR</code>条件改写，拆成两条语句的<code>UNION</code>操作，例如下列语句将会进行全表扫描：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score = <span class="number">100</span> <span class="keyword">OR</span> socre = <span class="number">0</span></span><br></pre></td></tr></table></figure><p> 可以改成这样的查询提升查询效率：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score = <span class="number">100</span></span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score = <span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><p>若查询中经常涉及<code>LIKE</code>与通配符<code>%</code>的查询可以考虑在原表中加入全文索引，如下：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%long%'</span></span><br></pre></td></tr></table></figure><p> 这句SQL语句若要考虑优化可以将<code>name</code>字段设置成全文索引，提高效率。全文索引的使用方法参考<a href="https://blog.csdn.net/u011734144/article/details/52817766/" target="_blank" rel="noopener">MySQL使用全文索引</a></p></li></ol><ol start="6"><li><p><code>IN</code>和<code>NOT IN</code>的使用大多也会放弃使用索引，进行全表扫描，对于连续值的情况，使用<code>BETWEEN</code>代替<code>IN</code>,例如：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score <span class="keyword">IN</span> (<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p> 改写为：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score <span class="keyword">BETWEEN</span> <span class="number">98</span> <span class="keyword">and</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></li><li><p>如果在<code>WHERE</code>子句中有参数，也会导致全表扫描，例如：下述SQL语句：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> <span class="keyword">name</span>=@<span class="keyword">name</span></span><br></pre></td></tr></table></figure><p> 因为SQL只有在运行时才会解析局部变量，SQL执行计划在编译时生成，可这个时候变量的值还是未知的，因而无法作为索引的输入项，实际执行时只能进行全表扫描。可以改为强制查询使用索引：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WITH</span>(<span class="keyword">INDEX</span>(<span class="string">"索引名"</span>)) <span class="keyword">WHERE</span> <span class="keyword">name</span>=@<span class="keyword">name</span></span><br></pre></td></tr></table></figure></li><li><p>避免在<code>WHERE</code>子句中进行表达式操作，例如：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score/<span class="number">2</span>=<span class="number">50</span></span><br></pre></td></tr></table></figure><p> 为了避免放弃索引而全表扫描，应改为</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score=<span class="number">2</span>*<span class="number">50</span></span><br></pre></td></tr></table></figure></li><li><p>避免在<code>WHERE</code>子句中的函数操作，如下：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=<span class="string">'cheng'</span> <span class="comment">--name以cheng开头</span></span><br></pre></td></tr></table></figure><p> 为了避免放弃索引，而全表扫描改写为name字段添加全文索引的通配符匹配，或者使用<code>WHERE name LIKE &#39;cheng%&#39;</code>。</p></li></ol><ol start="10"><li>除了上述的8和9外，我们尽量避免在<code>WHERE</code>子句中的<code>=</code>左边进行函数、算数运算或其他表达式的运算，保证索引的正确使用。</li></ol><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><ol><li><code>WHERE</code>子句中的条件是<code>OR</code>关系的话，加索引将不会有任何作用。考虑改写为两条SQL语句的<code>UNION ALL</code>操作。</li></ol><ol start="2"><li>数据重复并且分布均匀的表字段建了索引一般不会对查询效率的提升有很大影响。</li></ol><ol start="3"><li>符合索引从左到右使用索引中的字段，可以只是用一部分，但必须是最左侧的部分。所以复合索引把最常用的字段放在最左边，重要程度一次递减。</li></ol><ol start="4"><li>复合索引中任何字段含有NULL值，那么该字段对复合索引是无效的。</li></ol><ol start="5"><li><code>LIKE &#39;%abc%&#39;</code>不会使用索引而<code>LIKE &#39;abc%&#39;</code>会使用索引。</li></ol><ol start="6"><li>使用<code>EXISTS</code>和<code>NOT EXISTS</code>代替<code>IN</code>和<code>NOT IN</code>，后者不会使用索引而进行全表扫描。</li></ol><h2 id="其他Tips"><a href="#其他Tips" class="headerlink" title="其他Tips"></a>其他Tips</h2><ol><li>能设计成数字型的字段就不设计成字符型。因为在处理查询等操作时字符型会挨个比较没一个字符，而数字型比较一次就够了。</li></ol><ol start="2"><li>使用<code>varchar/nvarchar</code>代替<code>char/nchar</code>，前者是边长字段，可以节省空间，并且字段越小搜索效率越高。</li></ol><h3 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h3><ol><li><a href="https://blog.csdn.net/wendy432/article/details/52319908" target="_blank" rel="noopener">https://blog.csdn.net/wendy432/article/details/52319908</a></li><li><a href="https://blog.csdn.net/u011734144/article/details/52817766/" target="_blank" rel="noopener">https://blog.csdn.net/u011734144/article/details/52817766/</a></li><li><a href="https://www.cnblogs.com/softidea/p/5977860.html" target="_blank" rel="noopener">https://www.cnblogs.com/softidea/p/5977860.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      本文从SQL语句的层面上介绍了SQL语句的优化写法，当数据量达到一定程度时将会提高查询效率。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="DataBase" scheme="https://296245482.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>Java容器源码阅读记录</title>
    <link href="https://296245482.github.io/2018/06/12/Java%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>https://296245482.github.io/2018/06/12/Java容器源码阅读记录/</id>
    <published>2018-06-12T02:32:36.000Z</published>
    <updated>2018-06-12T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先还是要放出这张大图，想要详细理解容器源码，他们之间的继承实现关系必须了熟于心。</p><div align="center"><img src="https://i.loli.net/2018/06/12/5b1f39ccf3c6a.png" width="500"></div><h2 id="ArrayList相关"><a href="#ArrayList相关" class="headerlink" title="ArrayList相关"></a>ArrayList相关</h2><h3 id="ArrayList初始化"><a href="#ArrayList初始化" class="headerlink" title="ArrayList初始化"></a>ArrayList初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的EMPTY_ELEMENTDATA值为0，初始化ArrayList时默认长度为零，不拥有默认大小</p><h3 id="ArrayList的扩容"><a href="#ArrayList的扩容" class="headerlink" title="ArrayList的扩容"></a>ArrayList的扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if</span></span><br><span class="line"><span class="comment"> * necessary, to ensure that it can hold at least the number of elements</span></span><br><span class="line"><span class="comment"> * specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if real element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for empty table. It's already supposed to be</span></span><br><span class="line">        <span class="comment">// at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensureCapacity方法可由开发者调用，当调整的容量低于DEFAULT_CAPACITY时，只要有容量扩大需求，都会至少保证DEFAULT_CAPACITY=10的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际扩容时调用的是grow()方法，可以看到，ArrayList在有扩容需求时会将原来的数组中的元素使用Arrays.copyOf方法复制到一个新的数组中，并且每次容量的增长为原来容量的1.5倍。</p><p><strong>因此在使用ArrayList时，因为扩容代价较高，应尽量指定容量</strong></p><h3 id="ArrayList中的modCount"><a href="#ArrayList中的modCount" class="headerlink" title="ArrayList中的modCount"></a>ArrayList中的modCount</h3><p>modCount变量用于记录该ArrayList的变更次数，包括add,remove,addAll,removeRange,clear方法，每操作一次这些方法，modCount的值就++。</p><p>modCount继承自AbstractList，该类中有iterator()方法使用了一个私有内部成员类Itr，Itr中有一个属性expectedModCount，在初始化的时候expectedModCount = modCount。</p><p>在对一个集合对象进行迭代操作时，如果不限制集合元素的操作，那么一些add或者remove操作可能会引起迭代错误，因此在AbstractList中使用了判断modCount和expectedModCount是否相等来规避这些风险。</p><h2 id="HashMap相关"><a href="#HashMap相关" class="headerlink" title="HashMap相关"></a>HashMap相关</h2><h3 id="HashMap容量"><a href="#HashMap容量" class="headerlink" title="HashMap容量"></a>HashMap容量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap的构造函数，参数一是桶容量大小，参数二是扩容阈值，默认0.75，即使只传桶容量，也会调用上述构造方法，loadFactor=0.75。还有一个变量叫threshold，threshold = loadFactor * capacity，就是扩容的阈值，当达到这个容量的时候就需要出发扩容机制，0.75时可以理解为装满四分之三就触发扩容。</p><p>HashMap的初始化在不指定容量大小的时候是16，并且保证初始化时容量大小总是2的n次方大小，根据HashCode查找数组位置的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns index for hash code h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>length设置成2的n次方是有意义的，比如这里和HashCode的“与”运算，和2的n次方-1这样的全1二进制做与，可以保证数组的每个位置的index都有，比如1110，那么HashMap的数组1位置就永远不可能有值能放过来，因为没有数能和1110做“与”结果为1。（）</p><h3 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new entry with the specified key, value and hash code to</span></span><br><span class="line"><span class="comment"> * the specified bucket.  It is the responsibility of this</span></span><br><span class="line"><span class="comment"> * method to resize the table if appropriate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Subclass overrides this to alter the behavior of put method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 大小超过threshold，扩容两倍</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为HashMap的容量设置成2的n次方有利于提高利用率，所以当map中包含的Entry的数量大于等于threshold，触发扩容时扩大的容量倍数也是2倍。</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet底层使用HashMap实现，构造方法上使用HashMap基本也是使用HashMap的，主要的区别在于HashMap存储键值对，HashSet仅仅存储对象，因为HashMap中的key是惟一的，所以这个特性被HashSet使用来保证存储对象的唯一性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span></span><br><span class="line"><span class="comment"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * If this set already contains the element, the call leaves the set</span></span><br><span class="line"><span class="comment"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span></span><br><span class="line"><span class="comment"> * element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在往HashSet里插入元素时，调用HashMap的put方法，如果该元素已经存在就返回false，不存在就返回true。</p><p>在我们日常使用HashSet时，要注意自己重写hashCode()和equal()方法，这样才能确保自己的比较的正确性。</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable基本可以等价于HashMap，大体上只有这些区别：</p><ol><li><p>HashTable是线程安全的，多个线程可以共享一个HashTable，HashMap不是synchronized的，但是ConcurrentHashMap是HashTable的一种替代，并且扩展性比HashTable更好。</p></li><li><p>HashMap的迭代器是Iterator，是fail-fast迭代器，当有其他线程改变HashMap的结构时就会抛出ConcurrentModificationException，而HashTable使用的是enumerator迭代器，不是fail-fast的。</p></li><li><p>单线程环境下，HashMap的性能比HashTable好。</p></li></ol><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h3 id="LinkedHashMap的有序性"><a href="#LinkedHashMap的有序性" class="headerlink" title="LinkedHashMap的有序性"></a>LinkedHashMap的有序性</h3><p>LinkedHashMap和HashMao的主要区别在于前者的Entry是用一个双向链表维护的，这个链接列表定义了迭代的顺序，并且该迭代顺序是由插入顺序或者访问顺序决定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>LinkedHashMap中的accessOrder()来决定迭代顺序，为true则按访问顺序排序，越近访问的位置越靠后，false为按照插入顺序，最近插入的位置越靠后。</p><p>基本的初始化等操作全部与HashMap原理一致，只是多了recordAccess方法，在每次操作时重新排序，将最近操作的Entry放到最后。因为链表的移位操作，增加、删除操作都是常量级别的消耗，所以不会带来性能的损失。</p><h3 id="LinkedHashMap与LRU缓存"><a href="#LinkedHashMap与LRU缓存" class="headerlink" title="LinkedHashMap与LRU缓存"></a>LinkedHashMap与LRU缓存</h3><p>LRU - Last Recent Use，由于LinkedHashMap能存储最近访问的功能，我们可以使用它来设计缓存，LinkedHashMap本身已经把最常读取的放在链表的最后。</p><p>在实现一个简单的LRU缓存功能时，我们只需要设置一个阈值，重写LinkedHashMap的removeEldestEntry方法，去除那些很久没有访问的Entry就行。</p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>继承自HashSet，基于LinkedHashMap，存的内容只有值，并且也维护着一个运行所有条目的双重链接列表。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基于链表实现，和ArrayList的主要区别就在于访问的性能，LinkedList的插入删除操作更好，但是随即访问操作要比ArrayList差。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><p>看源码过程中看到了很多transient关键字，简单了解了一下：</p><p>Java中的序列化和反序列化：</p><ol><li>序列化：将一个对象转换成一串二进制表示的字节数组，通过保存或转移这些自己数据来达到持久化的目的，例如写到文件中等。</li><li>反序列化：将字节数组重新构造成对象。</li></ol><p>java的transient关键字在序列化过程中为我们提供了便利，对需要通过序列化实现持久化的对象，首先实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><p>这样HashMap等容器在序列化的时候，其容量大小，扩容阈值等这些容器内部变量就不会被序列化存储。</p>]]></content>
    
    <summary type="html">
    
      了解Java中的容器，仅仅了解一些显著的区别和特性是不太够的，更应该了解每个容器的具体实现机制，初始化机制，扩容机制，了解一些常见操作中他们的性能情况，本文在阅读个容器源码的过程中记录下这方面的一些特性
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="Java" scheme="https://296245482.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>避免嵌套条件式</title>
    <link href="https://296245482.github.io/2018/05/31/%E9%81%BF%E5%85%8D%E5%B5%8C%E5%A5%97%E6%9D%A1%E4%BB%B6%E5%BC%8F/"/>
    <id>https://296245482.github.io/2018/05/31/避免嵌套条件式/</id>
    <published>2018-05-31T15:11:36.000Z</published>
    <updated>2018-05-31T15:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="嵌套条件式"><a href="#嵌套条件式" class="headerlink" title="嵌套条件式"></a>嵌套条件式</h2><p>今天在面对一个一般复杂的业务情况时，对着活动图写了一个嵌套三层的逻辑判断，review代码时被别人提醒了，在指导下也将嵌套三层的逻辑判断压缩到约等于两层，顿时代码整体简洁已读，结构也很清晰，不禁感慨如果处处注意代码的优美和易读性，写代码其实也可以是很美的事情。</p><p>写代码经常会遇到逻辑稍微复杂点的情况，比如逻辑分支众多，直接理解来写代码可能会出现嵌套多个 “if-else” 的情况，嵌套层数大于两层以后代码对于后人来看增加了很多成本。</p><p>遇到复杂逻辑的流程时，需要分解成简单易懂的逻辑代码，我能想到的方法有：拆分代码逻辑使功能模块化、使用卫语句。</p><h2 id="使用函数模块化"><a href="#使用函数模块化" class="headerlink" title="使用函数模块化"></a>使用函数模块化</h2><p>对一些嵌套的逻辑，可以提取出其中的一部分代码，封装成一个函数来使用，对于多种情况下可能涉及到的差不多的操作，也可以直接提取出其中相同的部分来模块化实现。</p><h2 id="卫语句"><a href="#卫语句" class="headerlink" title="卫语句"></a>卫语句</h2><p>卫语句的核心在于：在多层逻辑判断中，如果某个分支出现的请看股较于其他分支比较特殊，给它提出来单独处理，如果它真的发生了，做一些必要的整理工作，然后返回退出。</p><p>一下是一个卫语句的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isHuman())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个人"</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(isAlien())&#123;</span><br><span class="line">         System.out.println(<span class="string">"是个外星人"</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(isChenglong())&#123;</span><br><span class="line">            System.out.println(<span class="string">"是成龙"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码如果再多几层嵌套，给他人看起来的时候可能需要花不少时间理清楚你这里面不同情况的分支是什么条件过来的。</p><p>使用卫语句来改造就能在保持逻辑的情况下更加清晰明了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isHuman())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个人"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(isMan())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个外星人"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(isChenglong())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是成龙"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>卫语句可以把我们的视线从异常处理中解放出来，集中精力到正常处理的代码中。</p><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p><strong>想要自己的代码在复杂逻辑下依旧保持美感和清晰的结构，关键还是理解整个代码逻辑，能清楚的认识到每一个情况的输入输出，充分认识到其中每个情况的条件出现概率，例如提取出出现概率罕见的情况直接单独检查，及早的依据结果返回。</strong></p>]]></content>
    
    <summary type="html">
    
      写代码经常会遇到逻辑稍微复杂点的情况，比如分支众多，直接理解来写代码可能会出现嵌套多个 &quot;if-else&quot; 的情况，嵌套层数大于两层以后代码对于后人来看增加了很多成本，我们要学会让自己的代码保持美感
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="Java" scheme="https://296245482.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP/UDP &amp; 可靠的传输</title>
    <link href="https://296245482.github.io/2018/05/08/TCP:UDP%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BC%A0%E8%BE%93/"/>
    <id>https://296245482.github.io/2018/05/08/TCP:UDP实现可靠的传输/</id>
    <published>2018-05-08T15:58:00.000Z</published>
    <updated>2018-05-08T15:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>春招的面试被问到过UDP怎么实现可靠的传输，当时都是仅仅凭着自己对TCP三次握手四次挥手的理解自己瞎说，面试官的反馈肯定都是不满意，说起来自己其实对TCP的理解也不深入，它是如何保证可靠传输的几个机制都都只知道这几个模糊的概念，花点时间好好看看，写下这篇文章让自己加深印象</p><h1 id="TCP实现可靠传输的几个机制"><a href="#TCP实现可靠传输的几个机制" class="headerlink" title="TCP实现可靠传输的几个机制"></a>TCP实现可靠传输的几个机制</h1><h2 id="确认机制"><a href="#确认机制" class="headerlink" title="确认机制"></a>确认机制</h2><p>序号——序号的增加是和传输的字节相关的。TCP在传输数据时的序列号（Sequence Number）不是以报文段来进行编号的，而是将该连接生存周期内的所有数据当做一个字节流，按照字节流中的每个字节进行编号。每个TCP数据包中的数据大小不一定相同。在三次握手的连接建立之初，双方都会规定好初始的序号x和y，TCP每次传送的序号字段值表示所要传送的本报文中的第一个字节的序号。</p><p>确认——TCP的数据确认送达（ACK），是对接收到的数据的最高序列号的确认，并向发送方返回下一次期望的TCP数据包的序列号。如A-&gt;B，A当前序号是100，数据长度是50，B返回的确认号就是151给A。</p><p>效率提高——提高网络利用率和传输效率，例如TCP可以一次确认多个数据报，如果接收方接收到了151，201，301，那么只需要对301数据报确认即可，收到301意味着前面的都已经确认过。</p><p>不能跳着确认——接收端在确认时，只能确认最大的连续收到的包，例如发送端发了1，2，3，4，接收端收到了1，2，4，只能回3，回复连续收到的最大包+1的序号。</p><p>如果发送方在规定的时间内没有收到返回，超过规定时间后就将未被确认的数据重新发送，接收方如果收到的数据存在差错，也会直接丢弃此报文，不返回确认信息。更多详细的重传机制后面细讲。</p><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>有了前面的确认机制，在数据报传送发生错误时，需要重传机制来保证传输完整。</p><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>如果是阻塞式传输的话，意味着没有收到确认就一直四等，造成巨大的资源浪费，所以设定一个时间timeout，分为两种，一种是只重传超过timeout的包，另一种是重传timeout之后的所有包。</p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>相对于超时重传，这种机制不以时间驱动而以数据驱动，前一种方法是超过一定时间未收到就重传，快速重传是连续收到几次相同的ACK就重传，例如A-&gt;B，连续发1、2、3、4、5，假设期间2数据报因为某些原因没有到达，则B在收到3、4、5的时候继续返回序号为2的ACK，A在连续收到3次序号为2的ACK后，得知序号为2的包没有到达，马上重传2。</p><p><div align="center"><img src="https://i.loli.net/2018/05/19/5affe6a70cfdd.png"></div><br>但也存在问题，A并不知道2之后的是不是被对方收到了其他的数据，不知道三次返回的序号2是谁传回来的。</p><h3 id="Selective-Acknowledgment-SACK"><a href="#Selective-Acknowledgment-SACK" class="headerlink" title="Selective Acknowledgment(SACK)"></a>Selective Acknowledgment(SACK)</h3><p>这种方式基于快速重传的方法，只是在TCP头里加一个叫SACK的东西，接收方在接收缓冲区中记录好我当前缺少的部分，返回时向发送方汇报缺失内容。</p><p><div align="center"><img src="https://i.loli.net/2018/05/19/5affeda69255a.jpg" width="500"></div><br>这种优化的快速重传需要两方协议都支持才行。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>TCP主要解决的是可靠的传输和包乱序的问题，滑动窗口是TCP引入的一种网络控流技术，TCP必须要知道网络传输中实际的数据处理带宽或者说是数据处理速度，这样才不会引起网络拥塞导致丢包。</p><h3 id="AdvertisedWindow"><a href="#AdvertisedWindow" class="headerlink" title="AdvertisedWindow"></a>AdvertisedWindow</h3><p>Sliding Window是一个被设计来做网络流控的技术，TCP头里有一个字段叫Advertised-Window，这个字段是接收端返回给发送端告诉发送端自己还有多少的缓冲区可以接收数据，下次发送端发送数据就会按照这个接收端的处理能力来发送数据。要理解滑动窗口先看一下TCP缓冲区：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0cd52d370b0.jpg" width="400"></div></p><blockquote><p>接收端里的LastByteRead表示上层应用正在读的地方，NextByteExpected表示收到的连续包的最后一个位置，LastByteRcved表示收到的包最后的一个位置，连续包和最后位置的包之间是有间隙的，表示中间还是有数据没有到达</p><p>发送端中LastByteRead表示被接收端Ack过的位置，LastByteSent表示发送出去了，但是还没收到成功确认的Ack，LastByteWritten表示上层应用正在写的地方。</p></blockquote><p>因此，前面说到过的AdvertisedWindows的计算方式为:</p><blockquote><p>AdvertiedWindow = MaxRcvBuffer - LastByteRcvd - 1<br>这个窗口就是用来控制发送数据大小的，确保接收方可以处理</p></blockquote><h3 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h3><p>下面是发送方的滑动窗口的示意图：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0ce040420bf.png" width="600"></div></p><blockquote><p>黑框部分也就是滑动窗口</p><ol><li>Category#1代表的是已经收到Ack确认的数据</li><li>Category#2代表已经发送但是还未收到Ack的数据</li><li>Category#3代表按照接收方缓冲区大小计划发出的数据</li><li>Category#4代表窗口以外的数据，接收方空间不足以现在发送</li></ol></blockquote><p>下面是一个接收端使用滑动窗口控制发送端的过程，结合上述描述和AdvertiedWindow配合理解：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0ce2072bdd7.png" width="600"></div></p><h3 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h3><p>在上图中，可以看到接收端数据处理很缓慢，返回的Window大小越来越小，最后一次返回的Window = 0，这种情况下，发送端知道接收端缓冲区已经没有地方了就不会再发送数据了，这就有个问题，发送端不发数据了接收方也没法通知发送方Window Size可用了。</p><p>为了解决这个问题，TCP使用了Zero Window Probe技术，在Window = 0之后，发送方会发ZWP包给接收方，让接收方来Ack他现在的Window大小，不同的实现情况下会设置不同的次数和不同的时间。</p><p><strong>PS：*</strong>该技术可能会被DDoS攻击，攻击者在TCP连接建立完成后向发送方不断的发送带有Window = 0的Ack，发送方就停止发送并且发送ZWP包，服务器资源就被渐渐耗尽*</p><h3 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h3><p>像上面的那种情况，如果接收方太忙，不能及时取走Receive Window里的数据，会导致最后只有几个字节的Window来传输数据，而一次传输只传这么少量的数据很不划算，如果数据包用不满整个带宽的话会浪费大量的资源。</p><p>这个问题的解决思路从接收端和发送端两边都有解决思路，接收端设置一个阈值，小于该阈值的情况下都是Ack(0)把Window关了，等到处理后大小够大了以后再重设Window；发送端主要思路是做延时处理，设置阈值，或者是收到Ack才发数据，其他时间段都是做数据积累</p><h2 id="拥塞算法"><a href="#拥塞算法" class="headerlink" title="拥塞算法"></a>拥塞算法</h2><p>TCP利用滑动窗口做到了流控还是不够，还需要知道整个网络上的事。例如如果网络延时增加，导致大量丢包，没有拥塞处理的情况下，TCP只会重传数据，这样只会导致网络的负担更加重，甚至拖垮一个网络。因此TCP必须知道整个网络的情况，而且主体的设计思想为：<strong>TCP不是一个自私的协议，当拥塞发生时，做出自我牺牲，让出资源出来，不抢占少占有。</strong></p><p>拥塞算法主要是四个部分：</p><ol><li>慢启动</li><li>拥塞避免</li><li>拥塞发生时快速重传</li><li>快速恢复</li></ol><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>慢启动的过程很好理解，就是在加入连接的过程中，一点点提速。如下图所示，连接建立好以后，cwnd慢慢增加，每当收到一个Ack，cwnd线性上升，每隔一个RTT，cwnd指数上升。上升也不是无止境的，有一个slow start threshold，当cwnd &gt; ssthresh时进入“拥塞避免算法”。</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0cfaa95150d.jpg" width="500"></div></p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>慢启动在双重递增的情况下可以达到无限增长，因此设置了一个ssthresh，cwnd到达ssthresh后，每当收到一个Ack：cwnd增加一个自己的倒数，每过一个RTT：cwnd自增1。</p><h3 id="拥塞时状态"><a href="#拥塞时状态" class="headerlink" title="拥塞时状态"></a>拥塞时状态</h3><p>当发生丢包时，有两种解决思路：</p><p>第一种是降低sshthresh的值（sshthresh = cwnd / 2），重置cwnd为1，重新开始慢启动的过程；</p><p>第二点是快速重传的方法，cwnd保留一半（cwnd = cwnd / 2），sshthresh = cwnd，进入快速恢复方法。</p><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>快速重传和快速恢复一般一起使用，前面说过快速重传有3次Duplicated Acks。</p><p>当发送方连续收到三个重复确认时，就把慢开始门限减半（cwnd = cwnd / 2），这是为了预防网络发生拥塞。注意，接下来不执行慢开始算法。</p><p>由于发送方现在认为网络很可能没有发生特别严重的阻塞（如果发生了严重阻塞的话，就不会一连有好几个报文段到达接收方，就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口的值不设为1个MSSS），而是把拥塞窗口的值设为慢开始门限减半后的值，而后开始执行拥塞避免算法，线性地增大拥塞窗口。</p><hr><h1 id="UDP实现可靠传输的思路"><a href="#UDP实现可靠传输的思路" class="headerlink" title="UDP实现可靠传输的思路"></a>UDP实现可靠传输的思路</h1><p>UDP不属于连接型协议，且资源消耗小，处理速度快，通常音频、视频传输时用的比较多，因为即使偶尔丢失一两个数据包，也不会对结果产生太大影响。</p><p>UDP要实现可靠传输，在传输层已经无法保证可靠传输了，只能依靠应用层来实现，实现的要点主要是确认机制、重传机制、窗口确认等。目前已经有的开源项目基于UDP实现了可靠的数据传输：RUDP、RTP、UDT。</p><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><p>RUDP：提供拥塞控制的改进、重发机制及淡化服务器算法等机制，允许TCP方式下的流控行为。</p><p>RTP：该协议被用来解决音频和视频传输的功能，解决了TCP在这些应用上“慢”启动带来的问题，传输模型可以单点和多点传输。RTP协议在应用层工作，利用多路复用和校验，消除丢包带来的影响。RTP提供的服务包括有效的负载识别、序列编号、时间戳和投递监听。</p><p>UDT：主要目的是支持高速广域网上的海量数据传输，引入了拥塞控制和数据可靠性控制机制，面向连接的双向应用协议，发送方依据流量控制和速率控制来发送应用数据，接收者接受数据包和控制包，根据接收到的包发送控制包。</p><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>主要解决两个问题：丢包和包的顺序的问题</p><p>解决思路：</p><ol><li>给每个包编号，按照包的顺序接收并存储</li><li>增加确认机制</li><li>重传机制</li><li>窗口流量控制机制</li></ol><p>-&gt; ①UDP数据包+序列号 ②UDP数据包+时间戳 ③应答确认</p><p>TCP已经足够复杂了，用UDP来实现TCP其实是个很没意义的事情，如果不考虑完整实现TCP的功能，从这个角度来想，依据特定的需求来看，如果希望在某些情况下UDP优于TCP，一定是放弃了一些TCP重要的东西，比如以下两种情况：</p><ol><li>业务逻辑上允许信息丢失，例如在同步状态中，状态信息是有实效性，那么过期的信息是可以允许丢失的，每个新的状态信息都可以取代旧的信息，只是允许这样操作的业务场景非常少。</li><li>允许包乱序，只要和TCP一样在每个包上加上个序号即可，这样的复杂程度也很高，和TCP对比起来唯一的优势也就是在即使中间有包晚到了，业务层也可以先开始处理后面先到的包开始处理。</li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/ns_code/article/details/32707721" target="_blank" rel="noopener">https://blog.csdn.net/ns_code/article/details/32707721</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11609.html</a></li><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11564.html</a></li><li><a href="https://blog.csdn.net/pangyemeng/article/details/50387078" target="_blank" rel="noopener">https://blog.csdn.net/pangyemeng/article/details/50387078</a></li><li><a href="https://blog.csdn.net/kennyrose/article/details/7557917" target="_blank" rel="noopener">https://blog.csdn.net/kennyrose/article/details/7557917</a></li></ol>]]></content>
    
    <summary type="html">
    
      春招的面试被问到过两次UDP怎么实现可靠的传输，说起来自己对TCP是如何保证可靠传输的几个机制都不太熟，写下这篇文章让自己加深印象
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="网络" scheme="https://296245482.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown学习，一些常用小技巧</title>
    <link href="https://296245482.github.io/2018/04/24/Markdown%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://296245482.github.io/2018/04/24/Markdown一些不常见的小技巧/</id>
    <published>2018-04-24T07:43:47.000Z</published>
    <updated>2018-04-24T07:43:47.000Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为本博客的创作都是使用的Markdown，把自己平时用的比较多的Markdown语法做一个简单的记录，方便以后的取用。</p><p>本文省略了一些基本的语法，例如标题、文本强调、无序有序列表、表格绘制等内容</p><h2 id="详细技巧"><a href="#详细技巧" class="headerlink" title="详细技巧"></a>详细技巧</h2><h3 id="图片位置大小"><a href="#图片位置大小" class="headerlink" title="图片位置大小"></a>图片位置大小</h3><p>使用标准的图片插入方法<code>![]()</code>不能对图片进行位置和大小进行控制，默认居左并且按图片大小显示。</p><p>使用的方法是借助HTML标签来实现，在<code>&lt;div&gt;</code>标签中使用<code>align</code>、<code>width</code>、<code>height</code>等来控制，如下所示：</p><p><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 默认显示效果</span><br><span class="line">![](../imgs/20180424_1.jpeg)</span><br><span class="line">2. 位置大小控制效果</span><br><span class="line">&lt;div align = &quot;center&quot;&gt;&lt;img src = &quot;https://i.loli.net/2018/04/24/5adf182dd449f.jpeg&quot; width = &quot;100&quot;/&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><strong>默认效果</strong><br><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" alt=""><br><strong>控制后的效果</strong></p><div align="center"><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" width="100"></div><p><em>PS</em>: 在文中插入图片除了可以将照片放在本地直接获取外，可以使用一些免费的CDN，例如<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>，可以将图片传到线上，使用链接获取。</p><hr><h3 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h3><p>图文混合编排也可以使用HTML中的标签来实现，如下所示的文字靠左，图片靠右的实现方式：</p><p><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src = &quot;https://i.loli.net/2018/04/24/5adf182dd449f.jpeg&quot; align = &quot;right&quot; width = &quot;300&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><strong>实例效果</strong></p><div><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" align="right" width="300"></div><p>描述1</p><p>描述2</p><p>描述3</p><p>描述4</p><p>这是一个表情表的介绍，为了凑字数多写一点，让在不同的屏幕大小的情况下都能看得出他的自动换行效果，紫薯布丁紫薯布丁紫薯布丁…..</p><hr><h3 id="段前缩进"><a href="#段前缩进" class="headerlink" title="段前缩进"></a>段前缩进</h3><p>在Markdown里，在一个空格或者TAB之后的其他缩进会默认被无视，因此需要使用<code>&amp;ensp;</code> - 半角空格 或者 <code>&amp;emsp;</code> - 全角空格来实现缩进<br><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这&amp;ensp;中&amp;ensp;间&amp;ensp;有&amp;ensp;半&amp;ensp;角&amp;ensp;空&amp;ensp;格</span><br><span class="line">&amp;emsp;&amp;emsp;这之前有全角空格</span><br></pre></td></tr></table></figure></p><p><strong>实例效果</strong></p><p>这&ensp;中&ensp;间&ensp;有&ensp;半&ensp;角&ensp;空&ensp;格</p><p>&emsp;&emsp;这之前有全角空格</p><hr><h3 id="加强代码块"><a href="#加强代码块" class="headerlink" title="加强代码块"></a>加强代码块</h3><p>将需要高亮的代码块包裹在如下的格式内即可：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;```语言名</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>Python效果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> somefunc(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><p>在hexo中的 <code>front-matter</code> 中填入 <code>toc: true</code> 即可</p><p>目录生成效果如本文所示</p><hr><h3 id="插入公式-MathJax方法"><a href="#插入公式-MathJax方法" class="headerlink" title="插入公式 MathJax方法"></a>插入公式 MathJax方法</h3><p>网上有很多教程的方法，大多数都是在hexo中安装上MathJax，这里介绍一种较为简洁的方法，在你文章的<code>front-matter</code>中插入一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/x-mathjax-config"</span>&gt;</span><br><span class="line">MathJax.Hub.Config(&#123;</span><br><span class="line">tex2jax: &#123;<span class="attr">inlineMath</span>: [[<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">'\\('</span>,<span class="string">'\\)'</span>]]&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">" async</span></span><br><span class="line"><span class="string">  src="</span>https:<span class="comment">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"&gt;</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>之后，文中的公式两边加上$符号即可显示出公式，如下的<code>$E=mc^2$</code>和<code>$f(x) = x^2$</code>分别显示出了两个公式：</p><p>$E=mc^2$</p><p>$f(x) = x^2$</p><hr><h3 id="插入LaTeX公式"><a href="#插入LaTeX公式" class="headerlink" title="插入LaTeX公式"></a>插入LaTeX公式</h3><p>首先一个简单的示例，下述公式写法为：<code>$f&#39;(x\_0)=\lim_{\Delta x\to 0} \frac{f(x\_0+\Delta x) - f(x\_0)}{\Delta x}$</code></p><p>$f’(x_0)=\lim_{\Delta x\to 0} \frac{f(x_0+\Delta x) - f(x_0)}{\Delta x}$</p><p>常见的总结如下：</p><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center"><code>\\(x^y\\)</code></td><td style="text-align:center">\(x^y\)</td></tr><tr><td style="text-align:center"><code>\\(x^{y^z}\\)</code></td><td style="text-align:center">\(x^{y^z}\)</td></tr><tr><td style="text-align:center"><code>\\(x_i\\)</code></td><td style="text-align:center">\(x_i\)</td></tr><tr><td style="text-align:center"><code>\\(\alpha\\)</code></td><td style="text-align:center">\(\alpha\)</td></tr><tr><td style="text-align:center"><code>\\(\beta\\)</code></td><td style="text-align:center">\(\beta\)</td></tr><tr><td style="text-align:center"><code>\\(\Delta\\)</code></td><td style="text-align:center">\(\Delta\)</td></tr><tr><td style="text-align:center"><code>$$\sum_{i=0}^n$$</code></td><td style="text-align:center">$$\sum_{i=0}^n$$</td></tr><tr><td style="text-align:center"><code>$\frac{x}{y}$</code></td><td style="text-align:center">$\frac{x}{y}$</td></tr><tr><td style="text-align:center"><code>\\(\sqrt 3\\)</code></td><td style="text-align:center">\(\sqrt 3\)</td></tr><tr><td style="text-align:center"><code>\\(\sqrt[3] 5\\)</code></td><td style="text-align:center">\(\sqrt[3] 5\)</td></tr><tr><td style="text-align:center"><code>$$\lim_{x \to 0}$$</code></td><td style="text-align:center">$$\lim_{x \to 0}$$</td></tr><tr><td style="text-align:center"><code>$$f(x): \begin{cases} x, x&gt;0 \\\ \\\ -x,x&lt;0 \end{cases}$$</code></td><td style="text-align:center">$$f(x): \begin{cases} x, x&gt;0 \\ \\ -x,x&lt;0 \end{cases}$$</td></tr></tbody></table><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="http://daniellaah.github.io/2016/Mathmatical-Formula-within-Markdown.html" target="_blank" rel="noopener">http://daniellaah.github.io/2016/Mathmatical-Formula-within-Markdown.html</a></li><li><a href="https://www.jianshu.com/p/0b257de21eb5" target="_blank" rel="noopener">https://www.jianshu.com/p/0b257de21eb5</a></li><li><a href="https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener">https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/</a></li><li><a href="http://blog.mobing.net/content/hexo/hexo-mathjax.html" target="_blank" rel="noopener">http://blog.mobing.net/content/hexo/hexo-mathjax.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      简单的学习一波Markdown，将自己平时写博客用的比较多的Markdown语法做做记录
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="个人" scheme="https://296245482.github.io/tags/%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="blog" scheme="https://296245482.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Page的个人博客搭建</title>
    <link href="https://296245482.github.io/2018/04/18/Hexo-Github-Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://296245482.github.io/2018/04/18/Hexo-Github-Page的个人博客搭建/</id>
    <published>2018-04-18T08:03:21.000Z</published>
    <updated>2018-04-18T08:03:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近开始各种地方准备春招，投递了不少简历，经历了不少面试，着实感觉自己很多地方的积累还是不够，后端研发或者是Java研发这一块，还有太多的细节没有弄清楚，很多框架的一些原理没有很好的理解，因此决定开一个博客，在平时的学习过程中不断积累，不断总结知识点。</p><p>除去hexo配置完成后的“Hello World”文章，个人博客的第一篇文章就以“Hexo+Github Page配置个人博客”为主题了。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>配置过程参考了很多现有的网站的一些过程</p><p>完成的效果是在本地创建了一份Hexo工程，通过MarkDown创作，每次生成博客网站的内容，通过SSH方式远程部署到自己的USERNAME.GitHub.io的repo上。</p><p>Hexo的初步配置参考： <a href="https://www.jianshu.com/p/e5f95eb990ad" target="_blank" rel="noopener">Mac下使用Hexo+Github搭建个人博客</a> 。</p><p>初步完成后使用了 <a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">Maupassant</a> 主题，该主题很简洁，算是我比较喜欢的类型。</p><p>初步配置完成之后，后期有很多主题内评论、语言等配置，参考了<a href="https://github.com/handsdirty/hexo_blog" target="_blank" rel="noopener">Zhesong的配置过程</a> 。</p><p><strong>详细的步骤在上述几个教程中都已经有了完备的描述</strong></p><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd [hexo本地工程路径下]</span><br><span class="line">hexo new post &apos;文章标题&apos;</span><br></pre></td></tr></table></figure><p>打开工程路径下的<code>/source/_posts/</code>路径，找到自己刚新建出来的文章，打开编辑内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate / hexo g</span><br><span class="line">hexo deploy / hexo d</span><br></pre></td></tr></table></figure></p><p>这样的操作即可将新文章内容更新到个人的博客网站上。</p><p>PS: 有一种方法可以在deploy之前预览到更新后的样子，执行完 <code>hexo generate</code> 后执行 <code>hexo server / hexo s</code> ，在浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看预览结果</p><h2 id="立个Flag"><a href="#立个Flag" class="headerlink" title="立个Flag"></a>立个Flag</h2><p>每隔几天学习完一段时间后，坚持写个人的技术博客，在详细理解之后坚持原创，记录好自己的思路和理解，坚持！</p>]]></content>
    
    <summary type="html">
    
      本文介绍了本博客的搭建方法，基于GitHub的免费page服务搭建Hexo项目，有任何问题欢迎留言讨论~
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="个人" scheme="https://296245482.github.io/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://296245482.github.io/2018/04/17/hello-world/"/>
    <id>https://296245482.github.io/2018/04/17/hello-world/</id>
    <published>2018-04-17T14:26:19.245Z</published>
    <updated>2018-04-18T08:04:58.298Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
