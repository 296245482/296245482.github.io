<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jackie blogs</title>
  
  <subtitle>Work through it, hang in three.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://296245482.github.io/"/>
  <updated>2018-05-31T15:11:36.000Z</updated>
  <id>https://296245482.github.io/</id>
  
  <author>
    <name>Long Cheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>避免嵌套条件式</title>
    <link href="https://296245482.github.io/2018/05/31/%E9%81%BF%E5%85%8D%E5%B5%8C%E5%A5%97%E6%9D%A1%E4%BB%B6%E5%BC%8F/"/>
    <id>https://296245482.github.io/2018/05/31/避免嵌套条件式/</id>
    <published>2018-05-31T15:11:36.000Z</published>
    <updated>2018-05-31T15:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="嵌套条件式"><a href="#嵌套条件式" class="headerlink" title="嵌套条件式"></a>嵌套条件式</h2><p>今天在面对一个一般复杂的业务情况时，对着活动图写了一个嵌套三层的逻辑判断，review代码时被别人提醒了，在指导下也将嵌套三层的逻辑判断压缩到约等于两层，顿时代码整体简洁已读，结构也很清晰，不禁感慨如果处处注意代码的优美和易读性，写代码其实也可以是很美的事情。</p><p>写代码经常会遇到逻辑稍微复杂点的情况，比如逻辑分支众多，直接理解来写代码可能会出现嵌套多个 “if-else” 的情况，嵌套层数大于两层以后代码对于后人来看增加了很多成本。</p><p>遇到复杂逻辑的流程时，需要分解成简单易懂的逻辑代码，我能想到的方法有：拆分代码逻辑使功能模块化、使用卫语句。</p><h2 id="使用函数模块化"><a href="#使用函数模块化" class="headerlink" title="使用函数模块化"></a>使用函数模块化</h2><p>对一些嵌套的逻辑，可以提取出其中的一部分代码，封装成一个函数来使用，对于多种情况下可能涉及到的差不多的操作，也可以直接提取出其中相同的部分来模块化实现。</p><h2 id="卫语句"><a href="#卫语句" class="headerlink" title="卫语句"></a>卫语句</h2><p>卫语句的核心在于：在多层逻辑判断中，如果某个分支出现的请看股较于其他分支比较特殊，给它提出来单独处理，如果它真的发生了，做一些必要的整理工作，然后返回退出。</p><p>一下是一个卫语句的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isHuman())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个人"</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(isAlien())&#123;</span><br><span class="line">         System.out.println(<span class="string">"是个外星人"</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(isChenglong())&#123;</span><br><span class="line">            System.out.println(<span class="string">"是成龙"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码如果再多几层嵌套，给他人看起来的时候可能需要花不少时间理清楚你这里面不同情况的分支是什么条件过来的。</p><p>使用卫语句来改造就能在保持逻辑的情况下更加清晰明了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isHuman())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个人"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(isMan())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个外星人"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(isChenglong())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是成龙"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>卫语句可以把我们的视线从异常处理中解放出来，集中精力到正常处理的代码中。</p><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p><strong>想要自己的代码在复杂逻辑下依旧保持美感和清晰的结构，关键还是理解整个代码逻辑，能清楚的认识到每一个情况的输入输出，充分认识到其中每个情况的条件出现概率，例如提取出出现概率罕见的情况直接单独检查，及早的依据结果返回。</strong></p>]]></content>
    
    <summary type="html">
    
      写代码经常会遇到逻辑稍微复杂点的情况，比如分支众多，直接理解来写代码可能会出现嵌套多个 &quot;if-else&quot; 的情况，嵌套层数大于两层以后代码对于后人来看增加了很多成本，我们要学会让自己的代码保持美感
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="Java" scheme="https://296245482.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP/UDP &amp; 可靠的传输</title>
    <link href="https://296245482.github.io/2018/05/08/TCP:UDP%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BC%A0%E8%BE%93/"/>
    <id>https://296245482.github.io/2018/05/08/TCP:UDP实现可靠的传输/</id>
    <published>2018-05-08T15:58:00.000Z</published>
    <updated>2018-05-08T15:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>春招的面试被问到过UDP怎么实现可靠的传输，当时都是仅仅凭着自己对TCP三次握手四次挥手的理解自己瞎说，面试官的反馈肯定都是不满意，说起来自己其实对TCP的理解也不深入，它是如何保证可靠传输的几个机制都都只知道这几个模糊的概念，花点时间好好看看，写下这篇文章让自己加深印象</p><h1 id="TCP实现可靠传输的几个机制"><a href="#TCP实现可靠传输的几个机制" class="headerlink" title="TCP实现可靠传输的几个机制"></a>TCP实现可靠传输的几个机制</h1><h2 id="确认机制"><a href="#确认机制" class="headerlink" title="确认机制"></a>确认机制</h2><p>序号——序号的增加是和传输的字节相关的。TCP在传输数据时的序列号（Sequence Number）不是以报文段来进行编号的，而是将该连接生存周期内的所有数据当做一个字节流，按照字节流中的每个字节进行编号。每个TCP数据包中的数据大小不一定相同。在三次握手的连接建立之初，双方都会规定好初始的序号x和y，TCP每次传送的序号字段值表示所要传送的本报文中的第一个字节的序号。</p><p>确认——TCP的数据确认送达（ACK），是对接收到的数据的最高序列号的确认，并向发送方返回下一次期望的TCP数据包的序列号。如A-&gt;B，A当前序号是100，数据长度是50，B返回的确认号就是151给A。</p><p>效率提高——提高网络利用率和传输效率，例如TCP可以一次确认多个数据报，如果接收方接收到了151，201，301，那么只需要对301数据报确认即可，收到301意味着前面的都已经确认过。</p><p>不能跳着确认——接收端在确认时，只能确认最大的连续收到的包，例如发送端发了1，2，3，4，接收端收到了1，2，4，只能回3，回复连续收到的最大包+1的序号。</p><p>如果发送方在规定的时间内没有收到返回，超过规定时间后就将未被确认的数据重新发送，接收方如果收到的数据存在差错，也会直接丢弃此报文，不返回确认信息。更多详细的重传机制后面细讲。</p><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>有了前面的确认机制，在数据报传送发生错误时，需要重传机制来保证传输完整。</p><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>如果是阻塞式传输的话，意味着没有收到确认就一直四等，造成巨大的资源浪费，所以设定一个时间timeout，分为两种，一种是只重传超过timeout的包，另一种是重传timeout之后的所有包。</p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>相对于超时重传，这种机制不以时间驱动而以数据驱动，前一种方法是超过一定时间未收到就重传，快速重传是连续收到几次相同的ACK就重传，例如A-&gt;B，连续发1、2、3、4、5，假设期间2数据报因为某些原因没有到达，则B在收到3、4、5的时候继续返回序号为2的ACK，A在连续收到3次序号为2的ACK后，得知序号为2的包没有到达，马上重传2。</p><p><div align="center"><img src="https://i.loli.net/2018/05/19/5affe6a70cfdd.png"></div><br>但也存在问题，A并不知道2之后的是不是被对方收到了其他的数据，不知道三次返回的序号2是谁传回来的。</p><h3 id="Selective-Acknowledgment-SACK"><a href="#Selective-Acknowledgment-SACK" class="headerlink" title="Selective Acknowledgment(SACK)"></a>Selective Acknowledgment(SACK)</h3><p>这种方式基于快速重传的方法，只是在TCP头里加一个叫SACK的东西，接收方在接收缓冲区中记录好我当前缺少的部分，返回时向发送方汇报缺失内容。</p><p><div align="center"><img src="https://i.loli.net/2018/05/19/5affeda69255a.jpg" width="500"></div><br>这种优化的快速重传需要两方协议都支持才行。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>TCP主要解决的是可靠的传输和包乱序的问题，滑动窗口是TCP引入的一种网络控流技术，TCP必须要知道网络传输中实际的数据处理带宽或者说是数据处理速度，这样才不会引起网络拥塞导致丢包。</p><h3 id="AdvertisedWindow"><a href="#AdvertisedWindow" class="headerlink" title="AdvertisedWindow"></a>AdvertisedWindow</h3><p>Sliding Window是一个被设计来做网络流控的技术，TCP头里有一个字段叫Advertised-Window，这个字段是接收端返回给发送端告诉发送端自己还有多少的缓冲区可以接收数据，下次发送端发送数据就会按照这个接收端的处理能力来发送数据。要理解滑动窗口先看一下TCP缓冲区：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0cd52d370b0.jpg" width="400"></div></p><blockquote><p>接收端里的LastByteRead表示上层应用正在读的地方，NextByteExpected表示收到的连续包的最后一个位置，LastByteRcved表示收到的包最后的一个位置，连续包和最后位置的包之间是有间隙的，表示中间还是有数据没有到达</p><p>发送端中LastByteRead表示被接收端Ack过的位置，LastByteSent表示发送出去了，但是还没收到成功确认的Ack，LastByteWritten表示上层应用正在写的地方。</p></blockquote><p>因此，前面说到过的AdvertisedWindows的计算方式为:</p><blockquote><p>AdvertiedWindow = MaxRcvBuffer - LastByteRcvd - 1<br>这个窗口就是用来控制发送数据大小的，确保接收方可以处理</p></blockquote><h3 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h3><p>下面是发送方的滑动窗口的示意图：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0ce040420bf.png" width="600"></div></p><blockquote><p>黑框部分也就是滑动窗口</p><ol><li>Category#1代表的是已经收到Ack确认的数据</li><li>Category#2代表已经发送但是还未收到Ack的数据</li><li>Category#3代表按照接收方缓冲区大小计划发出的数据</li><li>Category#4代表窗口以外的数据，接收方空间不足以现在发送</li></ol></blockquote><p>下面是一个接收端使用滑动窗口控制发送端的过程，结合上述描述和AdvertiedWindow配合理解：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0ce2072bdd7.png" width="600"></div></p><h3 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h3><p>在上图中，可以看到接收端数据处理很缓慢，返回的Window大小越来越小，最后一次返回的Window = 0，这种情况下，发送端知道接收端缓冲区已经没有地方了就不会再发送数据了，这就有个问题，发送端不发数据了接收方也没法通知发送方Window Size可用了。</p><p>为了解决这个问题，TCP使用了Zero Window Probe技术，在Window = 0之后，发送方会发ZWP包给接收方，让接收方来Ack他现在的Window大小，不同的实现情况下会设置不同的次数和不同的时间。</p><p><strong>PS：*</strong>该技术可能会被DDoS攻击，攻击者在TCP连接建立完成后向发送方不断的发送带有Window = 0的Ack，发送方就停止发送并且发送ZWP包，服务器资源就被渐渐耗尽*</p><h3 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h3><p>像上面的那种情况，如果接收方太忙，不能及时取走Receive Window里的数据，会导致最后只有几个字节的Window来传输数据，而一次传输只传这么少量的数据很不划算，如果数据包用不满整个带宽的话会浪费大量的资源。</p><p>这个问题的解决思路从接收端和发送端两边都有解决思路，接收端设置一个阈值，小于该阈值的情况下都是Ack(0)把Window关了，等到处理后大小够大了以后再重设Window；发送端主要思路是做延时处理，设置阈值，或者是收到Ack才发数据，其他时间段都是做数据积累</p><h2 id="拥塞算法"><a href="#拥塞算法" class="headerlink" title="拥塞算法"></a>拥塞算法</h2><p>TCP利用滑动窗口做到了流控还是不够，还需要知道整个网络上的事。例如如果网络延时增加，导致大量丢包，没有拥塞处理的情况下，TCP只会重传数据，这样只会导致网络的负担更加重，甚至拖垮一个网络。因此TCP必须知道整个网络的情况，而且主体的设计思想为：<strong>TCP不是一个自私的协议，当拥塞发生时，做出自我牺牲，让出资源出来，不抢占少占有。</strong></p><p>拥塞算法主要是四个部分：</p><ol><li>慢启动</li><li>拥塞避免</li><li>拥塞发生时快速重传</li><li>快速恢复</li></ol><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>慢启动的过程很好理解，就是在加入连接的过程中，一点点提速。如下图所示，连接建立好以后，cwnd慢慢增加，每当收到一个Ack，cwnd线性上升，每隔一个RTT，cwnd指数上升。上升也不是无止境的，有一个slow start threshold，当cwnd &gt; ssthresh时进入“拥塞避免算法”。</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0cfaa95150d.jpg" width="500"></div></p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>慢启动在双重递增的情况下可以达到无限增长，因此设置了一个ssthresh，cwnd到达ssthresh后，每当收到一个Ack：cwnd增加一个自己的倒数，每过一个RTT：cwnd自增1。</p><h3 id="拥塞时状态"><a href="#拥塞时状态" class="headerlink" title="拥塞时状态"></a>拥塞时状态</h3><p>当发生丢包时，有两种解决思路：</p><p>第一种是降低sshthresh的值（sshthresh = cwnd / 2），重置cwnd为1，重新开始慢启动的过程；</p><p>第二点是快速重传的方法，cwnd保留一半（cwnd = cwnd / 2），sshthresh = cwnd，进入快速恢复方法。</p><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>快速重传和快速恢复一般一起使用，前面说过快速重传有3次Duplicated Acks。</p><p>当发送方连续收到三个重复确认时，就把慢开始门限减半（cwnd = cwnd / 2），这是为了预防网络发生拥塞。注意，接下来不执行慢开始算法。</p><p>由于发送方现在认为网络很可能没有发生特别严重的阻塞（如果发生了严重阻塞的话，就不会一连有好几个报文段到达接收方，就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口的值不设为1个MSSS），而是把拥塞窗口的值设为慢开始门限减半后的值，而后开始执行拥塞避免算法，线性地增大拥塞窗口。</p><hr><h1 id="UDP实现可靠传输的思路"><a href="#UDP实现可靠传输的思路" class="headerlink" title="UDP实现可靠传输的思路"></a>UDP实现可靠传输的思路</h1><p>UDP不属于连接型协议，且资源消耗小，处理速度快，通常音频、视频传输时用的比较多，因为即使偶尔丢失一两个数据包，也不会对结果产生太大影响。</p><p>UDP要实现可靠传输，在传输层已经无法保证可靠传输了，只能依靠应用层来实现，实现的要点主要是确认机制、重传机制、窗口确认等。目前已经有的开源项目基于UDP实现了可靠的数据传输：RUDP、RTP、UDT。</p><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><p>RUDP：提供拥塞控制的改进、重发机制及淡化服务器算法等机制，允许TCP方式下的流控行为。</p><p>RTP：该协议被用来解决音频和视频传输的功能，解决了TCP在这些应用上“慢”启动带来的问题，传输模型可以单点和多点传输。RTP协议在应用层工作，利用多路复用和校验，消除丢包带来的影响。RTP提供的服务包括有效的负载识别、序列编号、时间戳和投递监听。</p><p>UDT：主要目的是支持高速广域网上的海量数据传输，引入了拥塞控制和数据可靠性控制机制，面向连接的双向应用协议，发送方依据流量控制和速率控制来发送应用数据，接收者接受数据包和控制包，根据接收到的包发送控制包。</p><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>主要解决两个问题：丢包和包的顺序的问题</p><p>解决思路：</p><ol><li>给每个包编号，按照包的顺序接收并存储</li><li>增加确认机制</li><li>重传机制</li><li>窗口流量控制机制</li></ol><p>-&gt; ①UDP数据包+序列号 ②UDP数据包+时间戳 ③应答确认</p><p>TCP已经足够复杂了，用UDP来实现TCP其实是个很没意义的事情，如果不考虑完整实现TCP的功能，从这个角度来想，依据特定的需求来看，如果希望在某些情况下UDP优于TCP，一定是放弃了一些TCP重要的东西，比如以下两种情况：</p><ol><li>业务逻辑上允许信息丢失，例如在同步状态中，状态信息是有实效性，那么过期的信息是可以允许丢失的，每个新的状态信息都可以取代旧的信息，只是允许这样操作的业务场景非常少。</li><li>允许包乱序，只要和TCP一样在每个包上加上个序号即可，这样的复杂程度也很高，和TCP对比起来唯一的优势也就是在即使中间有包晚到了，业务层也可以先开始处理后面先到的包开始处理。</li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/ns_code/article/details/32707721" target="_blank" rel="noopener">https://blog.csdn.net/ns_code/article/details/32707721</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11609.html</a></li><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11564.html</a></li><li><a href="https://blog.csdn.net/pangyemeng/article/details/50387078" target="_blank" rel="noopener">https://blog.csdn.net/pangyemeng/article/details/50387078</a></li><li><a href="https://blog.csdn.net/kennyrose/article/details/7557917" target="_blank" rel="noopener">https://blog.csdn.net/kennyrose/article/details/7557917</a></li></ol>]]></content>
    
    <summary type="html">
    
      春招的面试被问到过两次UDP怎么实现可靠的传输，说起来自己对TCP是如何保证可靠传输的几个机制都不太熟，写下这篇文章让自己加深印象
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="网络" scheme="https://296245482.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown学习，一些常用小技巧</title>
    <link href="https://296245482.github.io/2018/04/24/Markdown%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://296245482.github.io/2018/04/24/Markdown一些不常见的小技巧/</id>
    <published>2018-04-24T07:43:47.000Z</published>
    <updated>2018-04-24T07:43:47.000Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为本博客的创作都是使用的Markdown，把自己平时用的比较多的Markdown语法做一个简单的记录，方便以后的取用。</p><p>本文省略了一些基本的语法，例如标题、文本强调、无序有序列表、表格绘制等内容</p><h2 id="详细技巧"><a href="#详细技巧" class="headerlink" title="详细技巧"></a>详细技巧</h2><h3 id="图片位置大小"><a href="#图片位置大小" class="headerlink" title="图片位置大小"></a>图片位置大小</h3><p>使用标准的图片插入方法<code>![]()</code>不能对图片进行位置和大小进行控制，默认居左并且按图片大小显示。</p><p>使用的方法是借助HTML标签来实现，在<code>&lt;div&gt;</code>标签中使用<code>align</code>、<code>width</code>、<code>height</code>等来控制，如下所示：</p><p><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 默认显示效果</span><br><span class="line">![](../imgs/20180424_1.jpeg)</span><br><span class="line">2. 位置大小控制效果</span><br><span class="line">&lt;div align = &quot;center&quot;&gt;&lt;img src = &quot;https://i.loli.net/2018/04/24/5adf182dd449f.jpeg&quot; width = &quot;100&quot;/&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><strong>默认效果</strong><br><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" alt=""><br><strong>控制后的效果</strong></p><div align="center"><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" width="100"></div><p><em>PS</em>: 在文中插入图片除了可以将照片放在本地直接获取外，可以使用一些免费的CDN，例如<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>，可以将图片传到线上，使用链接获取。</p><hr><h3 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h3><p>图文混合编排也可以使用HTML中的标签来实现，如下所示的文字靠左，图片靠右的实现方式：</p><p><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src = &quot;https://i.loli.net/2018/04/24/5adf182dd449f.jpeg&quot; align = &quot;right&quot; width = &quot;300&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><strong>实例效果</strong></p><div><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" align="right" width="300"></div><p>描述1</p><p>描述2</p><p>描述3</p><p>描述4</p><p>这是一个表情表的介绍，为了凑字数多写一点，让在不同的屏幕大小的情况下都能看得出他的自动换行效果，紫薯布丁紫薯布丁紫薯布丁…..</p><hr><h3 id="段前缩进"><a href="#段前缩进" class="headerlink" title="段前缩进"></a>段前缩进</h3><p>在Markdown里，在一个空格或者TAB之后的其他缩进会默认被无视，因此需要使用<code>&amp;ensp;</code> - 半角空格 或者 <code>&amp;emsp;</code> - 全角空格来实现缩进<br><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这&amp;ensp;中&amp;ensp;间&amp;ensp;有&amp;ensp;半&amp;ensp;角&amp;ensp;空&amp;ensp;格</span><br><span class="line">&amp;emsp;&amp;emsp;这之前有全角空格</span><br></pre></td></tr></table></figure></p><p><strong>实例效果</strong></p><p>这&ensp;中&ensp;间&ensp;有&ensp;半&ensp;角&ensp;空&ensp;格</p><p>&emsp;&emsp;这之前有全角空格</p><hr><h3 id="加强代码块"><a href="#加强代码块" class="headerlink" title="加强代码块"></a>加强代码块</h3><p>将需要高亮的代码块包裹在如下的格式内即可：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;```语言名</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>Python效果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> somefunc(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><p>在hexo中的 <code>front-matter</code> 中填入 <code>toc: true</code> 即可</p><p>目录生成效果如本文所示</p><hr><h3 id="插入公式-MathJax方法"><a href="#插入公式-MathJax方法" class="headerlink" title="插入公式 MathJax方法"></a>插入公式 MathJax方法</h3><p>网上有很多教程的方法，大多数都是在hexo中安装上MathJax，这里介绍一种较为简洁的方法，在你文章的<code>front-matter</code>中插入一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/x-mathjax-config"</span>&gt;</span><br><span class="line">MathJax.Hub.Config(&#123;</span><br><span class="line">tex2jax: &#123;<span class="attr">inlineMath</span>: [[<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">'\\('</span>,<span class="string">'\\)'</span>]]&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">" async</span></span><br><span class="line"><span class="string">  src="</span>https:<span class="comment">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"&gt;</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>之后，文中的公式两边加上$符号即可显示出公式，如下的<code>$E=mc^2$</code>和<code>$f(x) = x^2$</code>分别显示出了两个公式：</p><p>$E=mc^2$</p><p>$f(x) = x^2$</p><hr><h3 id="插入LaTeX公式"><a href="#插入LaTeX公式" class="headerlink" title="插入LaTeX公式"></a>插入LaTeX公式</h3><p>首先一个简单的示例，下述公式写法为：<code>$f&#39;(x\_0)=\lim_{\Delta x\to 0} \frac{f(x\_0+\Delta x) - f(x\_0)}{\Delta x}$</code></p><p>$f’(x_0)=\lim_{\Delta x\to 0} \frac{f(x_0+\Delta x) - f(x_0)}{\Delta x}$</p><p>常见的总结如下：</p><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center"><code>\\(x^y\\)</code></td><td style="text-align:center">\(x^y\)</td></tr><tr><td style="text-align:center"><code>\\(x^{y^z}\\)</code></td><td style="text-align:center">\(x^{y^z}\)</td></tr><tr><td style="text-align:center"><code>\\(x_i\\)</code></td><td style="text-align:center">\(x_i\)</td></tr><tr><td style="text-align:center"><code>\\(\alpha\\)</code></td><td style="text-align:center">\(\alpha\)</td></tr><tr><td style="text-align:center"><code>\\(\beta\\)</code></td><td style="text-align:center">\(\beta\)</td></tr><tr><td style="text-align:center"><code>\\(\Delta\\)</code></td><td style="text-align:center">\(\Delta\)</td></tr><tr><td style="text-align:center"><code>$$\sum_{i=0}^n$$</code></td><td style="text-align:center">$$\sum_{i=0}^n$$</td></tr><tr><td style="text-align:center"><code>$\frac{x}{y}$</code></td><td style="text-align:center">$\frac{x}{y}$</td></tr><tr><td style="text-align:center"><code>\\(\sqrt 3\\)</code></td><td style="text-align:center">\(\sqrt 3\)</td></tr><tr><td style="text-align:center"><code>\\(\sqrt[3] 5\\)</code></td><td style="text-align:center">\(\sqrt[3] 5\)</td></tr><tr><td style="text-align:center"><code>$$\lim_{x \to 0}$$</code></td><td style="text-align:center">$$\lim_{x \to 0}$$</td></tr><tr><td style="text-align:center"><code>$$f(x): \begin{cases} x, x&gt;0 \\\ \\\ -x,x&lt;0 \end{cases}$$</code></td><td style="text-align:center">$$f(x): \begin{cases} x, x&gt;0 \\ \\ -x,x&lt;0 \end{cases}$$</td></tr></tbody></table><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="http://daniellaah.github.io/2016/Mathmatical-Formula-within-Markdown.html" target="_blank" rel="noopener">http://daniellaah.github.io/2016/Mathmatical-Formula-within-Markdown.html</a></li><li><a href="https://www.jianshu.com/p/0b257de21eb5" target="_blank" rel="noopener">https://www.jianshu.com/p/0b257de21eb5</a></li><li><a href="https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener">https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/</a></li><li><a href="http://blog.mobing.net/content/hexo/hexo-mathjax.html" target="_blank" rel="noopener">http://blog.mobing.net/content/hexo/hexo-mathjax.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      简单的学习一波Markdown，将自己平时写博客用的比较多的Markdown语法做做记录
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="个人" scheme="https://296245482.github.io/tags/%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="blog" scheme="https://296245482.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Page的个人博客搭建</title>
    <link href="https://296245482.github.io/2018/04/18/Hexo-Github-Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://296245482.github.io/2018/04/18/Hexo-Github-Page的个人博客搭建/</id>
    <published>2018-04-18T08:03:21.000Z</published>
    <updated>2018-04-18T08:03:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近开始各种地方准备春招，投递了不少简历，经历了不少面试，着实感觉自己很多地方的积累还是不够，后端研发或者是Java研发这一块，还有太多的细节没有弄清楚，很多框架的一些原理没有很好的理解，因此决定开一个博客，在平时的学习过程中不断积累，不断总结知识点。</p><p>除去hexo配置完成后的“Hello World”文章，个人博客的第一篇文章就以“Hexo+Github Page配置个人博客”为主题了。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>配置过程参考了很多现有的网站的一些过程</p><p>完成的效果是在本地创建了一份Hexo工程，通过MarkDown创作，每次生成博客网站的内容，通过SSH方式远程部署到自己的USERNAME.GitHub.io的repo上。</p><p>Hexo的初步配置参考： <a href="https://www.jianshu.com/p/e5f95eb990ad" target="_blank" rel="noopener">Mac下使用Hexo+Github搭建个人博客</a> 。</p><p>初步完成后使用了 <a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">Maupassant</a> 主题，该主题很简洁，算是我比较喜欢的类型。</p><p>初步配置完成之后，后期有很多主题内评论、语言等配置，参考了<a href="https://github.com/handsdirty/hexo_blog" target="_blank" rel="noopener">Zhesong的配置过程</a> 。</p><p><strong>详细的步骤在上述几个教程中都已经有了完备的描述</strong></p><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd [hexo本地工程路径下]</span><br><span class="line">hexo new post &apos;文章标题&apos;</span><br></pre></td></tr></table></figure><p>打开工程路径下的<code>/source/_posts/</code>路径，找到自己刚新建出来的文章，打开编辑内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate / hexo g</span><br><span class="line">hexo deploy / hexo d</span><br></pre></td></tr></table></figure></p><p>这样的操作即可将新文章内容更新到个人的博客网站上。</p><p>PS: 有一种方法可以在deploy之前预览到更新后的样子，执行完 <code>hexo generate</code> 后执行 <code>hexo server / hexo s</code> ，在浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看预览结果</p><h2 id="立个Flag"><a href="#立个Flag" class="headerlink" title="立个Flag"></a>立个Flag</h2><p>每隔几天学习完一段时间后，坚持写个人的技术博客，在详细理解之后坚持原创，记录好自己的思路和理解，坚持！</p>]]></content>
    
    <summary type="html">
    
      本文介绍了本博客的搭建方法，基于GitHub的免费page服务搭建Hexo项目，有任何问题欢迎留言讨论~
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="个人" scheme="https://296245482.github.io/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://296245482.github.io/2018/04/17/hello-world/"/>
    <id>https://296245482.github.io/2018/04/17/hello-world/</id>
    <published>2018-04-17T14:26:19.245Z</published>
    <updated>2018-04-18T08:04:58.298Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
