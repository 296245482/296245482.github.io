<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jackie&#39;s blogs</title>
  
  <subtitle>佛系更新，欢迎交流</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://296245482.github.io/"/>
  <updated>2019-09-21T14:29:18.000Z</updated>
  <id>https://296245482.github.io/</id>
  
  <author>
    <name>Long Cheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Java并发编程实战》并发编程基础</title>
    <link href="https://296245482.github.io/2019/09/21/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://296245482.github.io/2019/09/21/《Java并发编程实战》并发编程基础/</id>
    <published>2019-09-21T14:29:18.000Z</published>
    <updated>2019-09-21T14:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：并发编程的线程安全性、对象的共享、对象的组合和基础构建模块</p><h2 id="一、线程安全性"><a href="#一、线程安全性" class="headerlink" title="一、线程安全性"></a>一、线程安全性</h2><p>线程安全的代码核心在于要对状态访问操作进行管理，特别是共享（Shared）和可变的（Mutable）状态的访问。共享意味着可由多个线程同时访问，可变意味着变量的值在其生命周期内可以发生变化，我们的讨论将会侧重于如何防止在数据上发生不受控的并发访问。</p><h3 id="1-线程安全性"><a href="#1-线程安全性" class="headerlink" title="1.线程安全性"></a>1.线程安全性</h3><p>当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。</p><p>在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。</p><p>无状态对象一定是线程安全的，既不包括任何域，也不包括任何对其他类中域的引用。</p><h3 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2.原子性"></a>2.原子性</h3><p>“++count”这类递增操作不是原子性的，包含三个步骤，读取-修改-写入，三个独立的操作，不会作为一个不可分割的操作来执行。</p><h4 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h4><p>当某个计算结果的正确性取决于多个线程交替执行时序时就会发生竞态条件，也就是说竞态条件下正确的结果要取决于运气。最常见的竞态条件类型就是“先检查后执行”，即通过一个可能失效的观测结果来决定下一步的动作。</p><h4 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h4><p>要避免竞态条件问题就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，确保其他线程只能在修改操作完成之前或之后读取和修改。可以将整个“读取-修改-写入”操作统称为复合操作，除了加锁之外，还可以使用java.util.concurrent.atomic包中的一些原子变量类来实现。</p><h3 id="3-加锁机制"><a href="#3-加锁机制" class="headerlink" title="3.加锁机制"></a>3.加锁机制</h3><h4 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h4><p>Java提供了一种内置的锁机制来支持原子性，也即同步代码块。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。</p><p>每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock），Java中的内置锁相当于一种互斥锁，最多只有一个线程能持有这种锁。</p><h4 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h4><p>内置锁是可重入的，也就是说某个线程试图获取一个已经由它自己持有的锁时可以成功的获取到，重入意味着获取锁的操作的粒度是线程而不是调用。</p><p>重入的实现方式是为每个锁关联一个获取计数值和一个所有者线程，当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1，同一个线程继续获取这个锁时计数器递增，当线程退出同步代码块时计数器会相应递减，直到计数器为0时锁释放。</p><p>重入进一步加深了锁行为的封装性，简化了面向对象并发代码的开发，解决了不可重入锁容易出现死锁的问题。</p><hr><h2 id="二、对象的共享"><a href="#二、对象的共享" class="headerlink" title="二、对象的共享"></a>二、对象的共享</h2><p>上述提到的同步代码块和同步方法确保了原子性，也就是防止了某个线程正在使用对象而另一个线程正在同时修改的情况，除此之外，我们还希望当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p><h3 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1.可见性"></a>1.可见性</h3><p>为了确保多个线程对内存写入操作的可见性，必须使用同步机制。在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。</p><p>在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断几乎无法得到正确的结论。</p><h4 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h4><p>在缺乏同步的程序中可能产生读到失效数据的情况，除非在每次访问变量是都使用同步，否则很有可能获得该变量的一个失效值。</p><h4 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h4><p>Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。（多线程操作非volatile的long时会发生独到某个值的高32位和另一个值的低32位）。不考虑失效数据的问题，多线程中使用共享且可变的long和double是不安全的，除非使用volatile声明或者用锁保护。</p><h4 id="加锁与可见性"><a href="#加锁与可见性" class="headerlink" title="加锁与可见性"></a>加锁与可见性</h4><p>内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果，加锁的含义不仅仅局限于护持行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p><h4 id="Volatile变量"><a href="#Volatile变量" class="headerlink" title="Volatile变量"></a>Volatile变量</h4><p>volatile是一种稍弱的同步机制，用来确保将变量的更新操作通知到其他线程。线程在读取volatile类型的变量时总会返回最新写入的值，编译器不会将该变量上的操作与其他内存操作一起重排序，该类型变量也不会被缓存在寄存器或者对其他处理器不可见的地方。</p><p>在访问volatile变量时不会执行加锁操作，即不会使执行线程阻塞，因此比sychronized关键字更轻量。</p><p>volatile变量通常用做某个操作完成、发生中断或者状态的标志。加锁机制可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，当且仅当满足以下所有条件时才应该使用volatile变量：</p><ul><li>对变量的写入操作不依赖变量的当前值</li><li>该变量不会与其他状态变量一只纳入不变性条件中</li><li>在访问变量时不需要加锁</li></ul><h3 id="2-发布与逸出"><a href="#2-发布与逸出" class="headerlink" title="2.发布与逸出"></a>2.发布与逸出</h3><p>“发布”指的是是对象能够在当前作用域之外的代码中使用，当某个不应该发布的对象被发布，这种情况就成为“逸出”。当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。</p><p>构造过程中使用this可能会导致引用逸出，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。</p><h3 id="3-线程封闭"><a href="#3-线程封闭" class="headerlink" title="3.线程封闭"></a>3.线程封闭</h3><p>当某个对象封闭在一个线程中时，虽然说是可变数据，但仅在单线程内访问，为了防止一些不必要的同步措施，线程封闭（Thread Confinement）技术将自动实现线程安全性，把对象封闭在线程中，即使被封闭的对象本身不是线程安全的。</p><ul><li>Ad-hoc线程封闭<br>维护线程封闭性的职责完全由程序实现来承担，因为没有任何一种语言特性能将对象封闭到目标线程上，所以Ad-hoc线程封闭是脆弱的，</li><li>栈封闭<br>栈封闭是线程封闭的一种特例，只能通过局部变量才能访问对象，局部变量的固有属性之一就是封闭在执行线程中。</li><li><strong>ThreadLocal类</strong><br>维持线程封闭性的一种更规范的方法是使用ThreadLocal，能使线程中的某个值与保存值的对象关联起来，它为每个使用该变量的线程都存有一份独立的副本，提供了get/set方法，操作的值都是当前执行线程的。ThreadLocal常用于防止对可变的单实例变量或全局变量进行共享。</li></ul><h3 id="4-不变性"><a href="#4-不变性" class="headerlink" title="4.不变性"></a>4.不变性</h3><p>满足同步的另一种方法是使用不可变对象，如果某个对象在创建后其状态就不能被修改，那么这个对象就称为不可变对象，线程安全性是不可变对象的固有属性之一，不可变对象一定是线程安全的。不可变不等于将对象所有域都声明为final类型。</p><h3 id="5-安全发布"><a href="#5-安全发布" class="headerlink" title="5.安全发布"></a>5.安全发布</h3><p>以上讨论的都是如果确保对象不被发布，但在某些情况下，我们希望在多线程间共享对象，此时必须确保对象安全地进行共享。</p><p>要安全的发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确构造的对象可以通过以下方式来安全的发布：</p><ul><li>在静态初始化函数中初始化一个对象引用。</li><li>将对象的引用保存到volatile类型的域或者AtomicReferance对象中。</li><li>将对象的引用保存到某个正确构造对象的final类型域中。</li><li>将对象的引用保存到一个由锁保护的域中。</li></ul><p>如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象”，在没有额外的同步情况下，任何线程都可以安全的使用被安全发布的事实不可变对象。</p><p>线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有借口来进行访问。被保护的对象只能通过持有特定的锁来访问，保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</p><hr><h2 id="三、对象的组合"><a href="#三、对象的组合" class="headerlink" title="三、对象的组合"></a>三、对象的组合</h2><p>掌握了一些线程安全与同步的基础知识，我们总会希望一些现有的线程安全组件组合为更大规模的状态的组件和程序。</p><h3 id="1-设计线程安全的类"><a href="#1-设计线程安全的类" class="headerlink" title="1.设计线程安全的类"></a>1.设计线程安全的类</h3><p>需要确保它的不变性条件不会在并发访问的情况下被破坏，需要对其状态进行推断，（对象的状态-&gt;对象的域-&gt;构成对象状态的所有变量）</p><p>要防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象应该要么是线程的对象，要是事实不可变的对象，或者由锁来保护的对象。</p><h3 id="2-实例封闭"><a href="#2-实例封闭" class="headerlink" title="2.实例封闭"></a>2.实例封闭</h3><p>封闭简化了线程安全类的实现过程，提供了一种实例封闭机制，将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据是总能持有正确的锁。</p><p>实例封闭是构建线程安全类的一个最简单的方式，它还使得在锁策略的选择上有了更多的灵活性。</p><p>封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。</p><h3 id="3-线程安全性委托"><a href="#3-线程安全性委托" class="headerlink" title="3.线程安全性委托"></a>3.线程安全性委托</h3><p>某些情况下，多个线程安全类组合而成的类是线程安全的，而在某些情况下，还需要再增加一个额外的线程安全层。</p><p>如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。</p><p>如果一个状态变量是线程安全的，并且没有任何不变性条件来约束他的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全的发布这个变量。</p><h3 id="4-现有线程安全类中添加功能"><a href="#4-现有线程安全类中添加功能" class="headerlink" title="4.现有线程安全类中添加功能"></a>4.现有线程安全类中添加功能</h3><p>某些情况现有的线程安全类能支持我们所需要的大部分操作，如果需要继续重用的话就需要在不破坏线程安全性的情况下添加一个新的操作。</p><ul><li>客户端加锁机制<br>对于某个对象X的客户端代码，使用X本身用于保护其状态的锁来保护这段客户代码，要使用客户端加锁，必须知道对象X使用的是哪一种锁。</li><li>组合<br>现有类通过将原有代码的操作委托给原有代码的实例来实现原有的功能，同时再添加一个原子的方法，通过自身的内置锁增加了一层额外的加锁，并不关心底层的原有代码是否是线程安全的，他依靠自身提供的一致加锁机制来实现线程安全性。但这额外的同步可能导致轻微的性能损失。</li></ul><hr><h2 id="四、基础构建模块"><a href="#四、基础构建模块" class="headerlink" title="四、基础构建模块"></a>四、基础构建模块</h2><p>上一部分介绍了构造线程安全类时采用的一些技术。同时，Java平台类库包含了丰富的并发基础构建模块，本部分将介绍其中一些最有用的并发构建模块。</p><h3 id="1-同步容器类"><a href="#1-同步容器类" class="headerlink" title="1.同步容器类"></a>1.同步容器类</h3><p>包括Vector和Hashtable，它们实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。</p><p>同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。例如Vector中的getLast()和deleteLast()，两个线程同时操作获取和删除，可能出现获取被删除元素的情况。如下：<br><a href="https://sm.ms/image/oZpfDAsHmKt1acX" target="_blank"><img src="https://i.loli.net/2019/09/11/oZpfDAsHmKt1acX.png"></a><br>交替调用getLast和deleteLast时将抛出ArrayIndexOutOfBoundsException<br>这些同步容器支持同步策略，即支持客户端加锁，因此为了让两个操作成为原子操作，就需要对该对象进行加锁处理。</p><h4 id="迭代器与ConcurrentModificationException"><a href="#迭代器与ConcurrentModificationException" class="headerlink" title="迭代器与ConcurrentModificationException"></a>迭代器与ConcurrentModificationException</h4><p>使用迭代器无法避免在迭代期间对容器加锁，在设计同步容器类的迭代器时并没有考虑到并发修改的问题，当容器在迭代过程中被修改时，就会表现出“及时失败（fail-fast）”就会抛出一个ConcurrentModificationException异常。</p><p>这种“及时失败”的迭代器并不是一种完备的处理机制，只能作为并发问题的预警指示器，实现方式是将计数器的变化与容器关联起来，迭代期间计数器被修改hasNext或者next将抛出异常，这种设计也是为了降低并发修改操作的检测代码对程序性能带来的影响。</p><h4 id="隐藏迭代器"><a href="#隐藏迭代器" class="headerlink" title="隐藏迭代器"></a>隐藏迭代器</h4><p>加锁可以防止迭代器抛出ConcurrentModificationException，但是必须要在所有的共享容器进行迭代的地方进行加锁，但实际可能会出现迭代器隐藏起来的情况。</p><p>如果出现状态与保护它的同步代码之间相隔较远，那么开发人员就容易忘记在访问状态时使用正确的同步。和封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保试试同步策略。</p><h3 id="2-并发容器"><a href="#2-并发容器" class="headerlink" title="2.并发容器"></a>2.并发容器</h3><ul><li>ConcurrentHashMap<br>Java7基于分段锁，数据结构是数组+链表，Java8基于CAS，数据结构是数组+链表+红黑树，具体可以看<a href="http://www.jasongj.com/java/concurrenthashmap/" target="_blank" rel="noopener">ConcurrentHashMap演进</a></li><li>CopyOnWriteArrayList<br>用于替代同步List，在某些情况提供更好的并发性能，在迭代期间不需要对容器进行加锁或复制。写入时复制容器的线程安全性在于：只要正确的发布一个事实不可变的对象，那么在访问该对象时就不再需要进一步的同步。在每次修改时都会创建并重新发布一个新的容器副本，从而实现可变性。在迭代操作远多于修改操作时我们才应该使用“写入时复制”，节省开销。</li></ul><h3 id="3-阻塞队列和生产者-消费者模式"><a href="#3-阻塞队列和生产者-消费者模式" class="headerlink" title="3.阻塞队列和生产者-消费者模式"></a>3.阻塞队列和生产者-消费者模式</h3><p>阻塞队列支持生产者-消费者这种设计模式，简化开发过程，消除生产者类和消费者类之间的代码依赖性，解耦生产数据和使用数据的过程。</p><p>在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具，它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。</p><h3 id="4-阻塞方法与中断方法"><a href="#4-阻塞方法与中断方法" class="headerlink" title="4.阻塞方法与中断方法"></a>4.阻塞方法与中断方法</h3><p>线程阻塞时，它通常被挂起，并处于某种阻塞状态（BLOCKED、WAITING或TIMED_WAITING）。被阻塞的线程必须等待某个不受它控制的时间发生后才能继续执行，例如等到I/O操作完成、等待锁可用、等待外部计算的结束。</p><p>每个线程都有一个布尔类型的属性，表示线程的中断状态。中断是一种协作机制，一个线程不能强制其他线程停止正在执行的操作而去执行其他操作，一个线程只能要求另一个线程执行到某个可以暂停并且愿意暂停的地方来停止操作。</p><p>要处理对中断的响应有两种基本选择：</p><ul><li>传递InterruptedException<br>不捕获该异常，或者捕获该异常，然后在执行某种简单的清理工作后再次抛出这个异常</li><li>恢复中断<br>有时候不能抛出InterruptedException，例如代码是Runnable的一部分时，这样如果必须捕获异常，就要调用当前线程的interrupt方法恢复中断。</li></ul><h3 id="5-同步工具类"><a href="#5-同步工具类" class="headerlink" title="5.同步工具类"></a>5.同步工具类</h3><p>同步工具类可以是任何一个对象，只要它根据自身的状态来协调线程的控制流。所有的同步工具类都包含一些特定的结构化属性：它们封装了一些状态，这些状态用来决定执行同步工具类的线程是继续执行还是等待，还提供一些方法对状态进行操作，以及另一些方法用于高效地等待同步工具类进入预期状态。</p><h4 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h4><p>闭锁是一种同步工具类，可以延迟线程的进度直到到达终止状态。将闭锁比作一扇门，在它到达结束状态之前，这扇门一直是关闭的，没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。闭锁到达结束状态后，将不会再改变状态，闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。</p><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>FutureTask也可以用做闭锁，它表示的计算是通过Callable来实现的，相当于一种可生成结果的Runnable，并可以处于这三种状态：等待运行（Waiting to run），正在运行（Running）和运行完成（Completed）。</p><p>运行完成表示所有可能结束的方式，包括正常、取消或异常，FutureTask进入结束状态后将永远停止在这个状态上。Future.get在任务已经完成时会立即返回结果，否则get将阻塞直到任务进入完成状态。</p><p>FutureTask在Executor框架中表示异步任务，还可以用来表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p><h4 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h4><p>栅栏（Barrier）类似于闭锁，与闭锁的区别在于：所有线程必须同时到达栅栏位置才能继续执行，闭锁用于等待事件，而栅栏用于等待其他线程，必须所有线程齐了才进一步操作。</p><hr><h2 id="第一部分小结"><a href="#第一部分小结" class="headerlink" title="第一部分小结"></a>第一部分小结</h2><ul><li>可变状态是至关重要的。<br>所有的并发问题都可以归结为如何协调对并发状态的访问，可变状态越少，就越容易确保线程安全性。</li><li>尽量将域声明为final类型，除非需要它们是可变的。</li><li>不可变对象一定是线程安全的。<br>不可变对象能极大的降低并发编程的复杂性，更简单并且安全，可以任意共享并且无需加锁或保护复制等机制。</li><li>封装有助于管理复杂性。<br>将数据封装在对象中，更易于维持不变性条件，将同步机制封装在对象中，更易于遵循同步策略。</li><li>用锁来保护每个可变变量。</li><li>保护同一个不变性条件的所有变量需要使用同一个锁。</li><li>在执行复合操作期间要持有锁。</li><li>在设计过程中考虑线程安全，或者在文档中明确指出它不是线程安全的。</li></ul><hr><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>Briangoetz. Java并发编程实战[M]. 机械工业出版社, 2012.</p>]]></content>
    
    <summary type="html">
    
      前言：并发编程的线程安全性、对象的共享、对象的组合和基础构建模块
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="Java" scheme="https://296245482.github.io/tags/Java/"/>
    
      <category term="Concurrent" scheme="https://296245482.github.io/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》阅读笔记-第五部分 高效并发</title>
    <link href="https://296245482.github.io/2019/08/30/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    <id>https://296245482.github.io/2019/08/30/《深入理解Java虚拟机》阅读笔记-第五部分-高效并发/</id>
    <published>2019-08-30T15:11:36.000Z</published>
    <updated>2019-08-30T15:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：了解虚拟机Java内存模型的结构及操作，讲解原子性、可见性、有序性在Java内存模型中的体现。线程安全所涉及的概念和分类、同步实现的方式及虚拟机的底层运作原理，并且介绍了虚拟机实现高效并发所做的一系列锁优化措施。</p><h2 id="一、Java内存模型与线程"><a href="#一、Java内存模型与线程" class="headerlink" title="一、Java内存模型与线程"></a>一、Java内存模型与线程</h2><p>衡量一个服务性能好坏，每秒事务处理数（Transactions Per Second，TPS）是最重要的指标，代表着一秒内服务端平均能响应的请求数，与程序的并发能力有这非常密切的关系。</p><h3 id="1-硬件的效率与一致性"><a href="#1-硬件的效率与一致性" class="headerlink" title="1. 硬件的效率与一致性"></a>1. 硬件的效率与一致性</h3><p>为了存储设备的读写速度能和处理器的运算速度匹配，在内存和处理器之间加入了一层缓存来进行缓冲，很好的解决了处理器与内存的速度矛盾，但也带了缓存一致性的问题。每个处理器都有自己的高速缓存，当多个处理器的运算任务涉及同一块内存区域是，将可能导致各自缓存数据不一致的情况。为了保证一致性，缓存的读写需要根据协议来进行操作，或者对指令进行乱序执行优化。</p><h3 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2. Java内存模型"></a>2. Java内存模型</h3><p>Java虚拟机规范试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台下都能达到一致的并发效果。而类似C/C++直接使用物理内存，会在不同的平台的内存模型上产生不一样的运行结果。</p><h4 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h4><p>Java内存模型所有变量都存储在主内存，每条线程还有自己的工作内存，工作内存保存该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都是在工作内存中完成，不能直接读写主内存，线程各自的工作内存独立，线程之间的值传递均需要通过主内存来完成。三者关系如下图：</p><p><a href="https://sm.ms/image/APMyUaIecD3Wukq" target="_blank"><img src="https://i.loli.net/2019/08/23/APMyUaIecD3Wukq.png"></a></p><p>这里的主、工作内存和Java内存区域中的Java堆、栈、方法区并不是同一层次的内存划分。从低层次的理解，主内存就是硬件的内存，而工作内存会优先存储于寄存器和高速缓存中。</p><h4 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h4><p>即主内存和工作内存之间的交互协议，实现细节有八大操作来完成：Lock、Unlock、Read、Load、Use、Assign、Store、Write，变量从主内存复制到工作内存为顺序执行read和load，变量同步回主内存为store和write，顺序执行并且不能单一出现。</p><h4 id="volatile型变量的特殊规则"><a href="#volatile型变量的特殊规则" class="headerlink" title="volatile型变量的特殊规则"></a>volatile型变量的特殊规则</h4><p>一个变量被定义为volatile后具备两种特性，一是可见性，指一条线程修改了这个变量的值，新值对于其他线程来说是立即得知的，只保证可见性不保证原子性，因此也适合作为并发的控制，volatile字段改变时所有线程都可以感知到该变量发生了改变；第二个是禁止指令排序优化，前后代码的执行顺序不会被打乱。</p><h4 id="long和double型变量的特殊规则"><a href="#long和double型变量的特殊规则" class="headerlink" title="long和double型变量的特殊规则"></a>long和double型变量的特殊规则</h4><p>long和double有非原子性协定，即允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位操作来进行。如果多个进程共享一个未声明为volatile的long或double变量，那么有些线程可能会独到一个既不是原值，也不是其他线程修改值的“半个变量”，但在实际中各大平台下的虚拟机厂商都会把64位数据的读写操作作为原子操作来对待。</p><h4 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h4><p>原子性：Java内存模型直接保证原子性的操作包括read、load、assign、use、store和write操作，大体上也可以认为基本数据类型的访问读写是具备原子性的。</p><p>可见性：即一个线程修改了共享变量的值，其他线程能够立即得知这个修改，volatile依靠修改后立即同步到主内存，使用主内存作为传递媒介方式来实现可见性。</p><p>有序性：线程内表现为串行的语义，但是线程之间来看，指令会存在重排序，也可说是工作内存和主内存同步延迟现象。</p><h4 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h4><p>“先行发生”也就是说内存模型中定义的两项操作之间的偏序关系，在先的操作的影响能够被在后的操作观察到，包括共享变量的值、发送了消息、调用了方法等。</p><p>衡量并发安全时都以先行发生原则为准，先行发生原则简单来说有：程序控制流顺序、管程锁定（lock/unlock）、volatile变量、线程启动（start方法比线程内所有动作先行）、线程终止（线程内所有操作都先于线程的终止检测）、线程中断（中断先行发生于中断线程代码检测到的中断事件）、对象终结（初始化先于finalize）、传递性（A先于B + B先于C -&gt; A先于C），时间上的先后顺序和先行原则之间基本没有太大关系。</p><h3 id="3-Java与线程"><a href="#3-Java与线程" class="headerlink" title="3. Java与线程"></a>3. Java与线程</h3><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>使用内核线程实现、使用用户线程实现、使用用户线程加轻量级进程混合实现。</p><ul><li>内核线程实现<br>是直接由操作系统内核支持的线程，由内核来完成线程切换、通过操纵调度器对线程进行调度。程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程，每个轻量级进程都有一个内核线程支持。</li><li>用户线程实现<br>广义上讲一个线程不是内核线程就可以认为是用户线程，狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到线程存在的实现。线程的操作完全在用户态完成，因此快速且低消耗，支持更大规模的线程数量。但缺点在于使用用户线程实现的程序一般都比较复杂，实际上主流语言都不会采用。</li><li>用户线程加轻量级进程混合实现<br>混合实现下，既存在用户线程也存在轻量级进程，线程的操作快速、低消耗、支持大规模并发，同时又可以使用内核提供的线程调度功能及处理器映射。</li></ul><p>对Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型，一条Java线程映射到一条轻量级进程之中。</p><h4 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h4><p>调度过程即为线程分配处理器使用权的过程，主要有两种，协同式线程调度和抢占式线程调度。</p><p>协同式调度的线程执行时间由线程本身来控制，自己的工作完成后主动通知系统切换到另一个线程上去，实现较为简单，好处是切换操作是可知的，坏处是执行时间不可控。</p><p>抢占式调度的执行时间由系统分配，线程切换不由线程本身决定，线程本身可以让出，不能获取执行时间，这样不至于导致系统崩溃。</p><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>Java语言定义了5种进程状态，任意一个时间点，一个进程有且只有其中一种状态：</p><ul><li>新建（New）<br>尚未启动</li><li>运行（Runable）<br>包括了操作系统中的Running和Ready，可能正在执行或者等待CPU为它分配执行时间。</li><li>无限期等待（Waiting）<br>这种状态的进程不会被分配CPU执行时间，要等待被其他线程显式的唤醒。</li><li>限期等待（Timed Waiting）<br>同上不会被分配CPU时间，但会在一定时间后由系统自动唤醒。</li><li>阻塞（Blocked）<br>阻塞是等待获取一个排它锁，在另一个线程放弃这个锁的时候发生。对比等待，等待是等一段时间或者唤醒动作。</li><li>结束（Terminated）<br>已终止，结束执行。</li></ul><hr><h2 id="二、线程安全与锁优化"><a href="#二、线程安全与锁优化" class="headerlink" title="二、线程安全与锁优化"></a>二、线程安全与锁优化</h2><p>这部分主要描述的是HotSpot虚拟机内的即时编译器（Just In Time Compiler）的行为，与多数主流的虚拟机中的即时编译器的行为有很多相似相通之处。</p><h3 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1. 线程安全"></a>1. 线程安全</h3><p>线程安全的代码都具备一个特征：本身封装了所有必要的正确性保障手段，例如互斥同步等，令调用者无须关心多线程的问题，更无须自己实现任何措施来保证多线程的正确调用，</p><h4 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h4><p>可以将Java语言中各种操作共享数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><ul><li>不可变<br>在Java语言中不可变的对象一定是线程安全的。</li><li>绝对线程安全<br>一个类达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”，这通常需要付出很大，甚至是不切实际的代价。大多数Java API中标注线程安全的类都不是绝对的线程安全。</li><li>相对线程安全<br>单独的操作是线程安全的，不需要额外的保障措施，但是一些特定顺序的连续调用，就可能在调用端使用额外的同步手段来保证调用的正确性。例如Vector、HashTable等。</li><li>线程兼容<br>指对象本身不是线程安全的，但是可以通过调用端正确的使用同步手段来保证对象在并发环境中安全的使用。</li><li>线程对立<br>不管是否采取了同步措施，都无法在多线程环境中并发使用的代码。</li></ul><h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><p>虚拟机提供的同步和锁机制对实现线程安全提供了便利。</p><ul><li>互斥同步<br>互斥是方法，同步是目的，互斥是实现同步的一种手段。最基本的互斥同步手段就是synchronized关键字。除了synchronized外，还可以使用可重入锁ReentrantLock来实现同步，ReentrantLock与synchronized很相似，都具备一样的线程重入特性，可重入锁相对来说多了一些高级功能，有以下三项：<br>等待可中断：持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<br>可实现公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized是非公平的，ReentrantLock可以通过带布尔值的构造函数要求使用公平锁。<br>锁绑定多个条件：可重入锁可以绑定多个Condition对象，而synchronized可以通过wait/notify/ntifyAll实现一个隐含条件。</li><li>非阻塞同步<br>互斥同步也被称为阻塞同步，是一种悲观的并发策略，而非阻塞同步是一种乐观的并发策略，先进行操作，没有其他线程争用共享数据就操作成功，产生了冲突就改为重试。</li><li>无方案同步<br>可重入代码：不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用不可重入的方法。一个方法只要输入了相同的数据，就能返回相同的结果，那么就满足可重入要求，是线程安全的。<br>线程本地存储：一段代码所必需的的数据必须与其他代码共享，但也可以保证这些共享数据在同一个线程中执行，这样无须同步也能保证线程之间不出现数据争用的问题。</li></ul><h3 id="2-锁优化"><a href="#2-锁优化" class="headerlink" title="2. 锁优化"></a>2. 锁优化</h3><h4 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h4><p>互斥同步对性能造成最大的影响时阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，给系统的并发性能带来很大的压力。</p><p>但实际上共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，如果物理机有一个以上的处理器，能够让两个或以上的线程同时并行执行，那么就可以让后面请求锁的那个线程“稍等一会”，不放弃处理器的执行时间，看看持有锁的线程是否很快会释放锁，这样一个让线程等待，即让线程执行一个忙循环的技术，就是自旋锁。</p><p>自适应自旋锁意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。选择是否自旋是一个不断适应的过程，自旋后成功获得锁的与否都会对后来的自旋时间做出帮助，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状态预测就会越来越准确。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>指的是虚拟机即时编译器在运行时对一些代码上要求同步，但是被检测不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据来源于逃逸分析数据支持，也就是一段代码在堆上所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当做栈上数据对待，认为是线程私有的，即同步加锁也无须进行。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>一般原则下，我们总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样也是为了让锁相关操作性能更高。</p><p>但是有时候也会出现一系列连续操作都对同一个对象反复加锁和解锁，例如加锁操作出现在循环体里，即使没有竞争，频繁的互斥同步操作也会导致不必要的性能损耗，锁粗化技术就是会把加锁同步的范围扩展到整个操作序列的外部，这样只需要加锁一次就可以了。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>传统的锁机制被称为重量级锁，轻量级锁的目的不是代替重量级锁的，本意是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。</p><p>解释轻量级锁需要先了解虚拟机对象的内存布局，对象头的第一部分用于存储对象自身的运行时数据，也被称为“Mark Word”，使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的锁记录空间（Lock Record），如果更新成功，则轻量级锁获取成功，否则，说明已有线程获得了轻量级锁，即当前情况下已经发生了锁竞争，不适宜继续使用轻量级锁，接下来膨胀为重量级锁。</p><p>缺点是对于锁竞争激烈的场景，维持轻量级锁的过程就造成了浪费。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的目的是消除无竞争情况下的同步原语，进一步提高程序的运行性能。轻量级锁时在无竞争的情况下使用CAS操作去消除同步使用的互斥量，偏向锁就是在无竞争状态下把整个同步都消除掉，连CAS操作都不做了。</p><p>偏向锁的“偏”的意思是指会偏向于第一个获得它的线程，只有第一个申请锁的线程会使用锁，在Mark Word中CAS记录所有者，如果接下来的执行过程中该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步，偏向锁获取成功。否则，说明有其他线程竞争，膨胀为轻量级锁。</p><p>偏向锁无法使用自旋锁优化，一旦有其他线程申请锁，就破坏了偏向锁的假定。</p><hr><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>周志明. 深入理解Java虚拟机[M]. 机械工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      了解虚拟机Java内存模型的结构及操作，讲解原子性、可见性、有序性在Java内存模型中的体现。线程安全所涉及的概念和分类、同步实现的方式及虚拟机的底层运作原理，并且介绍了虚拟机实现高效并发所做的一系列锁优化措施。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="java" scheme="https://296245482.github.io/tags/java/"/>
    
      <category term="jvm" scheme="https://296245482.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》阅读笔记 第四部分 程序编译与代码优化</title>
    <link href="https://296245482.github.io/2019/08/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>https://296245482.github.io/2019/08/05/《深入理解Java虚拟机》阅读笔记-第四部分-程序编译与代码优化/</id>
    <published>2019-08-05T15:16:50.000Z</published>
    <updated>2019-08-05T15:16:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：介绍Java程序从源码编译成字节码和从字节码编译成本地机器码的过程，Javac字节码编译器和虚拟机内的JIT编译器的执行过程合并起来其实就等同于一个传统的编译器所执行的编译过程。</p><h2 id="一、编译期优化"><a href="#一、编译期优化" class="headerlink" title="一、编译期优化"></a>一、编译期优化</h2><ul><li>前端编译器：把*.java文件转变成*.class文件的过程。常见有Sun的Javac、Eclipse JDT的增量是编译器（ECJ）。</li><li>后端运行期编译器：JIT编译器（Just In Time Compiler），字节码转换为机器码。常见有HotSpot VM的C1、C2编译器。</li><li>静态提前编译器：AOT编译器（Ahead Of Time Compiler），直接把*.java文件编译成本地机器代码。常见的有GNU Compiler for the Java（GCJ）、Excelsior JET。</li></ul><p>第一类<strong>前端编译器</strong>是最符合普遍对Java程序编译器的认知。Javac做了许多针对编码过程的优化措施来改善程序员的编码风格和提高编码效率。Java中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译器优化过程对于程序编码来说关系更加密切。</p><h3 id="1-Javac编译器"><a href="#1-Javac编译器" class="headerlink" title="1. Javac编译器"></a>1. Javac编译器</h3><p>Javac由Java语言编写，编译过程大致分为三个过程：</p><ul><li>解析与填充符号表过程。</li><li>插入式注解处理器的注解处理过程。</li><li>分析与字节码生成过程。</li></ul><p><img src="https://i.loli.net/2019/08/01/5d42ba26e028269755.png" alt="Javac的编译过程.png" title="Javac的编译过程.png"></p><h4 id="解析和填充符号表"><a href="#解析和填充符号表" class="headerlink" title="解析和填充符号表"></a>解析和填充符号表</h4><ul><li>词法、语法分析：<br>词法分析将源代码的字符流转变为标记（Token）集合，标记时编译过程的最小元素，语法分析是根据Token序列来构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式。后续的操作都建立在抽象语法树之上。</li><li>填充符号表：<br>符号表是一组符号地址和符号信息构成的表格，可以理解为哈希表中的K-V值对的形式，符号表在语义分析中用于语义检查和产生中间代码，在目标代码生成阶段对符号名进行地址分配。</li></ul><h4 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h4><p>JDK 1.5之后Java提供了对注解的支持，注解也是在运行期间发挥作用的。注解处理器可以读取、修改、添加抽象语法书中的任意元素，如果插件在处理注解期间对语法书进行了修改，那么编译器将回到解析及填充符号表的过程重新处理，直到插入式注解处理器没有对语法树进行修改为止。</p><h4 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h4><p>由源程序生成的一个结构正确的抽象语法树后，还是无法保证源程序是符合逻辑的，语义分析主要任务就是对结构上正确的源程序进行上下文有关性质的审查。</p><ul><li>标注检查<br>检查内容包括变量使用前是否被声明、变量与赋值之间的数据类型是否能够匹配。</li><li>数据及控制流分析<br>对程序的上下文逻辑更进一步的验证，例如局部变量使用前是否有赋值、方法是否有返回值、是否所有受查异常都能被正确处理等。</li><li>解语法糖<br>Java中常见的语法糖包括泛型、变长参数、自动装箱拆箱等，虚拟机运行时不支持这些语法，它们在编一阶段被还原回简单的基础语法结构。</li><li>字节码生成<br>把前面各个步骤所生成的信息转化成字节码写到磁盘中，同时也进行了少量的代码添加和转化工作。</li></ul><h3 id="2-Java语法糖"><a href="#2-Java语法糖" class="headerlink" title="2. Java语法糖"></a>2. Java语法糖</h3><p>语法糖虽然没有实质性的功能改进，但能提高效率、提升语法严谨性、减少出错的机会，也有人认为语法糖会让程序员产生依赖，让程序员无法看清语法糖背后的程序代码的真实面目。</p><h4 id="泛型与类型擦出"><a href="#泛型与类型擦出" class="headerlink" title="泛型与类型擦出"></a>泛型与类型擦出</h4><p>泛型的本质是参数化类型（Parameterized Type）的应用，即所操作的数据类型可以被指定为一个参数，可以用在类、接口和方法的创建中，分别为泛型类、泛型接口和泛型方法。</p><p>Java语言的泛型存在于程序源码中，在编译后的字节码文件中就被替换为原来的原生类型，Java中泛型的实现方法被称为<strong>类型擦除</strong>，这种方式实现的泛型也被叫做伪泛型，例如运行期中ArrayList<integer>和ArrayList<string>就是用一个类。不同于C#中泛型在源码、编译后、运行期都是切实存在的真实泛型。</string></integer></p><h4 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h4><p>自动装箱、拆箱在编译之后被转化成了对应的包装盒还原方法，遍历循环则是把代码还原成了迭代器的实现。在实际使用中尽量避免让代码来做一些复杂的自动装箱与拆箱。</p><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>Java语言中的条件编译不同于C、C++使用预处理器指示符来完成条件编译，Java中的条件编译使用条件为常量的if语句，这样的if语句在编译阶段就会被“运行”。这样的语法糖会在编译阶段将分支不成立的代码块消除掉。</p><p>Java中除了这些语法糖之外，还有内部类、枚举类、断言语句、支持枚举和字符串的switch、在try中定义和关闭资源等。</p><hr><h2 id="二、运行期优化"><a href="#二、运行期优化" class="headerlink" title="二、运行期优化"></a>二、运行期优化</h2><p>这部分主要描述的是HotSpot虚拟机内的即时编译器（Just In Time Compiler）的行为，与多数主流的虚拟机中的即时编译器的行为有很多相似相通之处。</p><h3 id="1-HotSpot虚拟机内的即时编译器"><a href="#1-HotSpot虚拟机内的即时编译器" class="headerlink" title="1. HotSpot虚拟机内的即时编译器"></a>1. HotSpot虚拟机内的即时编译器</h3><p>主流的商用虚拟机都同时包含解释器与编译器，当程序需要迅速启动和执行的时候，解释器首先发挥作用，省去编译的时间，立即执行，当程序运行时，编译器逐渐发挥作用，把越来越度的代码编译成本地代码，可以获得更高的执行效率。</p><p>当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”，会把这些代码编译成本地平台相关的机器码提高热点代码的执行效率。HotSpot中使用的是基于计数器的热点探测方法来进行热点代码的判断。</p><h3 id="2-编译优化技术"><a href="#2-编译优化技术" class="headerlink" title="2. 编译优化技术"></a>2. 编译优化技术</h3><p>以编译方式执行本地代码要比解释方式更快，很重要的一个原因就是有很多的优化措施都集中在了即时编译器之中。</p><p>即时编译优化技术有很多，详细的了解可以查阅<a href="https://blog.csdn.net/en_joker/article/details/80178974" target="_blank" rel="noopener">即时编译器优化一览</a>。这些技术大部分理解起来并不困难，比如一些很常见的冗余存储消除、复写传播、无用代码消除等，简单点就是将一些复杂的语句提取重点改写的更优雅。</p><p>编译器也会进行<strong>公共子表达式消除</strong>的操作，如果一个表达式E已经被计算过，并且先前的计算到现在E中所有变量的值都没有改变，那么E再次出现直接用前面计算过的表达式结果就可以了。并且对表达式还会进行另一种优化：代数化简，即一些代数上的交换结合变换。</p><p>除了这些，编译器还会做简单情况的数组边界检查消除、方法内联和逃逸分析。</p><p>逃逸分析的基本行为就是分析对象的动态作用域，当一个对象在方法里被定义后，它可能被外部方法所引用。作为调用参数传递到其他方法中，甚至还有可能被外部线程访问到，称为方法逃逸；赋值给类变量或可以再其他线程中访问的实体变量，称为线程逃逸。对于这些不会发生逃逸的情况有一些虚拟机优化措施，例如不会线程逃逸的对象分配到栈上、不会逃逸的变量消除掉同步措施、一个对象不会被外部访问就会被拆解为多个原始数据类型进行访问。</p><h3 id="3-Java与C-C-的编译器对比"><a href="#3-Java与C-C-的编译器对比" class="headerlink" title="3. Java与C/C++的编译器对比"></a>3. Java与C/C++的编译器对比</h3><p>Java和C/C++的对比实际上也就是最经典的即时编译器和静态编译器的对比，编译器的对比很大程度上也就是他们之间性能的对比。</p><p>即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力，能提供的优化手段也受制于编译成本。</p><p>Java语言是动态的类型安全语言，需要虚拟机来确保程序不会出现违反语义或者非结构化内存的情况，也就是虚拟机必须频繁地进行动态检查，例如实例方法访问时检查空指针、数组元素访问时检查上下界范围、类型转换时检查继承关系等。</p><p>Java中使用虚方法的频率要远大于C/C++，即运行时对方法接收者进行多态选择的频率要更大，也意味着即时编译器在进行一些优化时的难度要远远大于C/C++的静态优化编译器。</p><p>Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，使得全局的优化都难以进行，如果激进优化的话随着类型的变化会在运行时撤销或者重新优化。</p><p>Java语言的内存分配在对上进行，只有方法中的局部变量才能在栈上分配，栈上分配的在垃圾回收的压力上要小很多，C/C++的对象就有多种内存分配方式，并且主要由用户程序代码来回收分配的内存，没有对无用对象进行筛选的过程，效率比Java垃圾回收机制要高。</p><p>所有的这些对比也可以发现，Java的性能劣势都是为了换取开发效率上的优势来的，例如动态安全、动态扩展、垃圾回收，并且Java以运行期性能监控为基础的优化措施C/C++的静态编译器都没法实现。</p><hr><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>周志明. 深入理解Java虚拟机[M]. 机械工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      介绍Java程序从源码编译成字节码和从字节码编译成本地机器码的过程，Javac字节码编译器和虚拟机内的JIT编译器的执行过程合并起来其实就等同于一个传统的编译器所执行的编译过程。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="java" scheme="https://296245482.github.io/tags/java/"/>
    
      <category term="jvm" scheme="https://296245482.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》阅读笔记 第三部分 虚拟机执行子系统</title>
    <link href="https://296245482.github.io/2019/08/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://296245482.github.io/2019/08/04/《深入理解Java虚拟机》阅读笔记-第三部分-虚拟机执行子系统/</id>
    <published>2019-08-04T05:42:14.000Z</published>
    <updated>2019-08-04T05:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：JVM的自动内存管理机制</p><h2 id="一、类文件结构"><a href="#一、类文件结构" class="headerlink" title="一、类文件结构"></a>一、类文件结构</h2><p>Class文件时Java虚拟机执行引擎的数据入口，了解Class文件的结构对后面进一步了解虚拟机执行引擎有重要意义。</p><h3 id="1-基础概述"><a href="#1-基础概述" class="headerlink" title="1. 基础概述"></a>1. 基础概述</h3><p><img src="https://i.loli.net/2019/07/02/5d1b1ee57964371473.png" alt="Java虚拟机的语言无关性.png" title="Java虚拟机的语言无关性.png"></p><p>Java语言中的各种变量、运算符最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定比Java语言本身更强大。</p><h3 id="2-Class类文件的结构"><a href="#2-Class类文件的结构" class="headerlink" title="2. Class类文件的结构"></a>2. Class类文件的结构</h3><h4 id="魔数与Class文件版本"><a href="#魔数与Class文件版本" class="headerlink" title="魔数与Class文件版本"></a>魔数与Class文件版本</h4><p>每个Class文件头4个字节称为魔数，唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p><p>紧跟着的4个字节存储的是Class文件的版本号，第5-6字节是次版本号，第7-8字节是主版本号。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>紧接着主次版本号之后的是常量池入口，是Class文件结构中与其他项目关联最多的数据类型，也是占空间最大的数据项目之一。</p><h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p>在常量池结束之后，紧接着两个字节代表访问标志，这个标志用于识别一些类或接口层次的访问信息。</p><h4 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h4><p>按顺序排在访问标志后，这三项来确定类的继承关系类索引就是这个类的全限定名，父类索引是这个类的父类全限定名，接口索引集合描述这个类实现了哪些接口。</p><h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p>描述接口或类中声明的变量，字段包括了类级变量或实例级变量，但不包括在方法内部声明的变量。</p><h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>对方法的描述和对字段的描述几乎采用了完全一致的方式，方法表的结构同字段表一样，包含访问标志、名称索引、描述符索引、属性表集合几项。</p><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>字段表和方法表都可以携带自己的属性表集合，用以描述某些场景专有的信息。不像其他的数据项目要求严格的顺序、长度和内容，属性表几个的限制稍微宽松一点，不要求顺序，并且任何人实现的编译器都可以向属性表写入自己定义的属性信息。</p><h3 id="3-字节码指令简介"><a href="#3-字节码指令简介" class="headerlink" title="3. 字节码指令简介"></a>3. 字节码指令简介</h3><p>Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字+跟随其后的零至多个代表此操作所需参数构成。简单来说就是操作码+操作数组成。</p><ul><li>字节码和数据类型</li></ul><p>大多数的指令都包含了其操作所对应的的数据类型信息</p><ul><li>加载和存储指令</li></ul><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。</p><ul><li>运算指令</li></ul><p>对两个操作数栈上的值进行特定的运算，并把结果重新存到操作栈顶，算术指令使用的都是Java虚拟机的数据类型，没有直接支持byte、short、char、boolean的算术指令，因此都是操作int类型代替。</p><ul><li>类型转换指令</li></ul><p>实现代码中的显示类型转换操作。转换或多或少会出现上限溢出、下限溢出和精度丢失等情况，并且不会导致虚拟机抛出异常。</p><ul><li>对象创建和访问指令</li></ul><p>类实例和数组都是对象，但它们使用了不同的字节码指令。</p><ul><li>操作数栈和管理指令</li></ul><p>Java虚拟机提供了一些用于直接操作操作数栈的指令。</p><ul><li>控制转移指令</li></ul><p>让Java虚拟机有条件或无条件的从指定的位置指令的下一条指令继续执行程序</p><h3 id="4-Class文件结构的发展"><a href="#4-Class文件结构的发展" class="headerlink" title="4. Class文件结构的发展"></a>4. Class文件结构的发展</h3><p>Class文件的主体结构几乎没有发生过变化，主要改进都在访问标志、属性表这些设计上本就可扩展的数据结构中添加内容。</p><p>改进主要为了支持Java的新的语言特性，例如枚举、变长参数、泛型、动态注解等。</p><hr><h2 id="二、虚拟机类加载机制"><a href="#二、虚拟机类加载机制" class="headerlink" title="二、虚拟机类加载机制"></a>二、虚拟机类加载机制</h2><h3 id="1-本章概述"><a href="#1-本章概述" class="headerlink" title="1. 本章概述"></a>1. 本章概述</h3><p>虚拟机类加载机制简单来说就是把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p><p>Java语言里类型的加载和连接过程都是在程序运行期间完成的，Java的运行期动态加载和动态连接这个特点使得Java具备可以动态扩展的特性，虽然增加了类加载时的性能开销，但是提供了高度的灵活性。</p><h3 id="2-类加载的时机"><a href="#2-类加载的时机" class="headerlink" title="2. 类加载的时机"></a>2. 类加载的时机</h3><p>类的生命周期如下，从被加载到虚拟机内存到卸载出内存为止，包括有：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载，其中验证+准备+解析统称为连接。</p><p><img src="https://i.loli.net/2019/07/23/5d3677cb33c0e87593.png" alt="类的生命周期.png" title="类的生命周期.png"><br>类的生命周期</p><p>加载、验证、准备、初始化、卸载的“开始”顺序是确定的，解析不一定，有可能会发生在初始化之后，注意这里说的是“开始”，因为这些阶段都是互相交叉的混合式进行。</p><p>有且只有四种情况需要立即对类进行“初始化”（加载、验证、准备在这之前已经开始）：</p><ul><li>遇到new、getstatic、putstatis或invokestatic这4条字节码指令时</li><li>使用java.lang.reflect包的方法对类进行反射调用时</li><li>初始化一个类发现其父类还没有初始化，初始化他的父类</li><li>虚拟机启动时，包含main()方法的那个类</li></ul><p>这四种场景称为对一个类进行主动引用，除此之外的引用都不会触发初始化，称为被动引用。</p><h3 id="3-类加载的过程"><a href="#3-类加载的过程" class="headerlink" title="3. 类加载的过程"></a>3. 类加载的过程</h3><p>类加载过程包含：加载、验证、准备、解析和初始化五个阶段</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>虚拟机在加载过程主要完成三件事：①通过类的全限定名获取定义此类的二进制字节流 ②将这个字节流代表的静态存储结构转化为方法区的运行时数据结构 ③在Java堆中生成一个代表这个类的对象，作为方法区数据的访问入口。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是确保类文件的字节流符合当前虚拟机的要求，不会危害虚拟机自身的安全。</p><p>不同虚拟机对类验证的实现可能会有所不同，大致上都会完成以下四个阶段的检验：</p><ul><li>文件格式验证：魔数、常量池索引值和常量类型、数据的编码等等，保证输入的字节流能正确的解析并存储于方法区之中。</li><li>元数据验证：语义检验，保证其描述信息符合Java语言规范要求，验证点包括是否有父类、继承关系是否合法、是否实现了父类或接口中的方法、是否有不合规的重载等等。</li><li>字节码验证：数据流和控制流分析，保证被校验类不会在运行时危害虚拟机安全。</li><li>符号引用验证：虚拟机将符号引用转化为直接引用时，也就是解析阶段时发生，对类自身以外的信息进行匹配性校验。目的是确保解析正确执行。</li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>正式为类变量分配内存并设置类变量初始值，类变量的内存都在方法去中进行分配。内存分配仅包括类变量（static），不包括实例变量，并且准备阶段设置的初始值通常情况是数据类型的零值。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>这阶段虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用是用一组符号描述引用的的目标，只要使用时能够无歧义的定位到目标即可，直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄，直接引用与虚拟机实现的内存布局相关。</p><p>解析的动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>这是类加载过程中的最后一步，初始化阶段是执行类构造器\&lt;clinit>()方法的过程，该方法是编译器自动收集类中所有的<strong>类变量的赋值动作</strong>和<strong>静态语句块中的语句</strong>合并产生的。</p><p>父类的\&lt;clinit>()方法不需要子类显示调用，子类该方法执行之前会确保父类的该方法执行完毕，因此在虚拟机中第一个被执行的\&lt;clinit>()方法的类肯定是java.lang.Object。如果一个类没有静态语句块也没有对变量的复制操作，那么可以不生成该方法。</p><h3 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4. 类加载器"></a>4. 类加载器</h3><p>类加载器是一个代码模块，完成“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作。不同的类加载器加载的类即使来源于同一个Class文件他们也不相同（equal()、isInstance()）。</p><p>因此，对于任意一个类，都需要由<strong>加载它的类加载器和这个类本身</strong>来一同确立其在Java虚拟机中的<strong>唯一性</strong>。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>绝大多数Java程序都会使用到以下三种系统提供的类加载器：</p><ul><li>启动加载器（Bootstrap ClassLoader）</li><li>扩展类加载器（Extension ClassLoader）</li><li>应用程序类加载器（Application ClassLoader）</li></ul><p>上述三种加载器互相配合进行加载，有时也会有自己定义的类加载器，类加载器的层次关系如下图：</p><p><img src="https://i.loli.net/2019/07/25/5d396b53bedca53492.png" alt="类加载器双亲委派模型.png" title="类加载器双亲委派模型.png"><br>类加载器双亲委派模型（Parents Delegation Model）</p><p>除了启动加载器其他的都有自己的父类加载器，父子以组合关系来让子加载器复用父加载器的代码。</p><p><strong>双亲委派的工作过程</strong>是：一个类加载器收到了类加载请求，会把这个请求委派给父类加载器去完成，所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子类加载器才会尝试自己去加载。</p><p>双亲委派模型是的类加载器具备了优先级的层次关系，使得不同地方的同一个类都是由同一个类加载器加载，不会出现类不同的情况。</p><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>为什么要破坏双亲委派：某些特殊情况，父类加载器受限于加载范围的限制，无法加载需要的文件，需要委托子类加载器去加载Class文件。常见的例子有JDBC中的DriverManager使用上下文类加载器作为默认的系统加载器、Tomcat每个webappClassLoader加载自己目录下的Class文件，不会传递给父类加载器。</p><p>双亲委派并不是一个强制性约束的模型：<br>第一次被破坏是发生在JDK1.2之前。<br>第二次被破坏，为了解决一些基础类不在启动类加载器的加载范围内的情况，Java设计团队引入了线程上下文类加载器（Thread Context ClassLoader），它打通了双亲委派的层次结构，逆向使用类加载器，例如JNDI、JDBC、JCE、JAXB、JBI。<br>第三次被破坏，为了实现热插拔、热部署、模块化，把这些模块连同类加载器一起换掉实现代码的热替换。</p><hr><h2 id="三、-虚拟机字节码执行引擎"><a href="#三、-虚拟机字节码执行引擎" class="headerlink" title="三、 虚拟机字节码执行引擎"></a>三、 虚拟机字节码执行引擎</h2><p>从表面来看，所有Java虚拟机的执行引擎都是一致的：输入字节码文件，处理过程是字节码解析的等效过程，输出是执行结果。本章从概念模型的角度讲解虚拟机的方法调用和字节码执行，分析虚拟机在执行代码是如何找到正确的方法，如何执行方法内的字节码，以及执行代码是涉及的内存结构。</p><h3 id="1-运行时栈帧结构"><a href="#1-运行时栈帧结构" class="headerlink" title="1. 运行时栈帧结构"></a>1. 运行时栈帧结构</h3><p>栈帧用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。</p><p>每一个方法从调用开始到执行完成的过程，就对应着栈帧在虚拟机栈里从入栈到出栈的过程。每一个栈帧包括局部变量表、操作数栈、动态链接、方法返回和一些额外信息。局部变量表大小和操作数栈深度取决于虚拟机的实现，是一个固定值不受运行期变量数据影响。</p><p><img src="https://i.loli.net/2019/07/29/5d3e9127d843289904.png" alt="栈帧的概念结构.png" title="栈帧的概念结构.png"></p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>一组变量值存储空间，存放方法参数和方法内部定义的局部变量。以变量槽（Variable Slot）为最小单位。</p><p>一个Slot存放32位以内的数据，对象的引用也可以存进来获取对象在Java堆的起始地址和方法区的对象类型数据。局部变量不同于类变量有一个默认值，局部变量定义了但没有赋初始值是不能使用的。</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，这句话里的“栈”指的就是操作数栈。</p><p>操作数栈的每一个元素可以是任意的Java数据类型，32位占栈容量1，64位数据占栈容量2。操作数栈中的元素的数据类型必须和字节码指令的序列严格匹配。</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。</p><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>一个方法被执行后，两种方式退出这个方法，一是正常完成出口：执行引擎遇到任意一个方法返回的字节码指令；二是异常完成出口，执行过程中遇到了异常，并且没有搜索到匹配的异常处理器，导致方法退出。</p><p>正常情况下，方法退出时，调用者PC计数器的值作为返回地址，把当前栈帧出栈，恢复上层方法的局部变量和操作数栈，如果是异常退出返回地址是要通过异常处理器来确定，栈帧中不会保存这部分信息。</p><h3 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h3><p>这里说的方法调用不是方法执行，惟一的任务就是确定调用哪一个方法，不涉及方法内部的运行过程。一切方法调用在Class文件里面存储的都只是符号引用，不是方法在实际运行内存布局中的入口地址，这就需要Java在类加载期间甚至是运行期间才能确定目标方法的直接引用。</p><h4 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h4><p>方法在Class中都是符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，也就是调用目标在编译时就确定了下来，调用版本在运行期是不可改变的，符合“编译器可知，运行期不可变”，这类方法称为解析。</p><p>符合解析条件的有静态方法（invokestatic）、私有方法、实例构造方法、父类方法（这三个都是invokespecial）两大类，他们都会在解析阶段确定惟一的调用版本，都适合在加载阶段进行解析。</p><h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><p>分派围绕继承、封装、多态，帮助虚拟机正确地确定目标方法。</p><ul><li>静态分派</li></ul><p>依赖静态类型定位方法执行的动作称为静态分派，典型应用就是重载，重载时在编译阶段定位最合适的方法。</p><p>虚拟机在重载时是通过参数的静态类型作为判断依据的，而不是使用实际类型。并且静态类型在编译器就是可知的，Javac编译器就根据参数的静态类型决定使用哪个重载版本。</p><p>静态分派和解析不是二选一关系，是在不同层次上的筛选确定。</p><ul><li>动态分配</li></ul><p>Java虚拟机根据实际类型来分派方法执行版本，动态分配的典型应用是重写，主要依赖与Java虚拟机的invokevirtual指令，在运行期确定接收对象的实际类型。</p><ul><li>单分派和多分派</li></ul><p>Java语言是一个静态多分派、动态单分派的语言。</p><ul><li>虚拟机动态分派的实现</li></ul><p>在方法区中建立一个虚方法表，通过使用方法表的索引来代替元数据查找以提高性能，虚方法表中存放着各个方法的实际入口地址，方法表在类加载的连接阶段进行初始化，准备了子类的初始化值后，虚拟机会把该类的虚方法表也进行初始化。</p><h3 id="3-基于栈的字节码解释执行引擎"><a href="#3-基于栈的字节码解释执行引擎" class="headerlink" title="3. 基于栈的字节码解释执行引擎"></a>3. 基于栈的字节码解释执行引擎</h3><p>探讨虚拟机是如何执行方法里面的字节码指令。</p><h4 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h4><p>对Java来说，是解释执行还是编译执行，只有确定了Java实现版本和执行引擎运行模式时描述才会比较确切。Java语言中，Javac编译器完成了程序代码的经过词法分析、语法分析到抽象语法书，再遍历语法树生成线性字节码指令流的过程。</p><h4 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h4><p>Java编译器输出的指令流基本上是基于栈的指令集架构，以来操作数栈进行工作，与之相对的另外一套常用的指令集架构师基于寄存器的指令集，也是主流PC中直接支持的指令集架构，依赖寄存器进行工作。</p><p>栈指令集的优点有可移植，不像寄存器受硬件约束，编译器实现更简单，缺点在于执行速度相对慢一些。</p><h4 id="基于栈的解释器的执行过程"><a href="#基于栈的解释器的执行过程" class="headerlink" title="基于栈的解释器的执行过程"></a>基于栈的解释器的执行过程</h4><p>基于栈的解释器执行过程简单来说就是，根据具体的指令，先将数据放到局部变量表中，然后将局部变量表中的数据放到操作数栈中，从栈中取出数进行计算。整个运算过程的中间变量都以操作数栈的出栈和入栈为信息交换途径。</p><hr><h2 id="四、-类加载及执行子系统的案例"><a href="#四、-类加载及执行子系统的案例" class="headerlink" title="四、 类加载及执行子系统的案例"></a>四、 类加载及执行子系统的案例</h2><h3 id="1-Tomcat：正统的类加载器架构"><a href="#1-Tomcat：正统的类加载器架构" class="headerlink" title="1. Tomcat：正统的类加载器架构"></a>1. Tomcat：正统的类加载器架构</h3><p>一个功能健全的Web需要解决：①两个Web应用使用的Java类库版本可能不一致，需要相互隔离。②两个Web应用使用到Java类库可以相互共享。③服务器要尽可能保证自身安全不受部署的应用影响。④支持JSP应用的Web服务器，大多都需要支持HotSwap功能。</p><p>Tomcat按照经典的双亲委派模型实现，加上自定义的多个类加载器，如下图：</p><p><img src="https://i.loli.net/2019/07/31/5d40fe87e288f38004.png" alt="Tomcat类加载器.png" title="Tomcat类加载器.png"></p><p>Tomcat的目录结构中，“/common”-Tomcat和所有应用共同使用，“/server”-Tomcat使用，应用不可见，“/shared”-应用共同使用，Tomcat不可见，“/WEB_INF”-仅仅此应用使用的类库。这四个目录下的类库分别由上图的Common、Catalina、Shared、Webapp类加载器加载。前三个目录现在已经合并成一个“/lib”目录。被CommonClassLoader或SharedClassLoader加载的Spring通过上下文加载器访问不在其范围内的WebAppClassLoader加载的bean。</p><h3 id="2-OSGi：灵活的类加载器架构"><a href="#2-OSGi：灵活的类加载器架构" class="headerlink" title="2. OSGi：灵活的类加载器架构"></a>2. OSGi：灵活的类加载器架构</h3><p>OSGi有一个灵活的类加载器架构，Bundle类加载器之间只有规则，没有固定的委派关系，一个Bundle声明了一个它依赖的Package，之后这个Package所有的类加载动作都会委派给发布它的Bundle类加载器去完成。各个Bundle加载器是平级关系，只有具体使用到某个Package和Class的时候，才会根据Package导入导出定义来构造Bundle间的委派和依赖。</p><p>OSGi描绘了一个模块化开发的目标，可以实现模块级的热插拔功能，当程序升级更新或调试除错时，可以只停用、重新安装然后启用程序其中的一部分。</p><h3 id="3-字节码生成技术与动态代理的实现"><a href="#3-字节码生成技术与动态代理的实现" class="headerlink" title="3. 字节码生成技术与动态代理的实现"></a>3. 字节码生成技术与动态代理的实现</h3><p>字节码生成技术的例子有很多，javac命令就是一种很原始的字节码生成技术，还有比如Web服务器中的JSP编译器、编译时织入的AOP框架，还有很常见的动态代理技术，甚至是使用反射的时候虚拟机都有可能会在运行时生成字节码来提高执行速度。</p><p>这里用动态代理简述下字节码编程技术，动态代理实质是动态字节码与反射机制结合，运行期根据不同的入参生成不同的字节码文件，继承于Proxy对象，基于实现被代理对象的接口实现代理的功能，因此从这个角度来说，JDK的动态代理无法对非实现接口的类做代理。</p><hr><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>周志明. 深入理解Java虚拟机[M]. 机械工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      JVM的自动内存管理机制。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="java" scheme="https://296245482.github.io/tags/java/"/>
    
      <category term="jvm" scheme="https://296245482.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》阅读笔记 第二部分 Java自动内存管理</title>
    <link href="https://296245482.github.io/2019/07/03/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-Java%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://296245482.github.io/2019/07/03/《深入理解Java虚拟机》阅读笔记-第二部分-Java自动内存管理/</id>
    <published>2019-07-03T15:04:47.000Z</published>
    <updated>2019-07-03T15:04:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：JVM的自动内存管理机制，从理论知识、异常现象、代码、工具、案例和实战多角度讲解。</p><h2 id="一、Java内存区域与内存异常"><a href="#一、Java内存区域与内存异常" class="headerlink" title="一、Java内存区域与内存异常"></a>一、Java内存区域与内存异常</h2><h3 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h3><p>Java虚拟机在执行Java程序过程中会把它管理的内存划分为若干不同的数据区域。</p><p><img src="https://i.loli.net/2019/06/26/5d1356b261d0449635.png" alt="jvm运行时数据区域划分.png" title="jvm运行时数据区域划分.png"></p><p><a href="https://www.cnblogs.com/ityouknow/p/5610232.html" target="_blank" rel="noopener">图源网络</a>，侵删</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>可以看做是当前线程所执行的字节码的行号指示器，计数器的值表明下一条需要执行的字节码指令。</p><p>因为所有线程都是轮流使用处理器，计数器的存在可以在线程得到处理器时间时能够恢复到正确的执行位置，每个线程都有自己独立的程序计数器，属于线程私有内存。</p><p>（程序计数器是唯一一个没有OOM的区域）</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>也是线程私有，虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会创建一个栈帧（栈帧是方法运行期的基础数据结构），用来存储局部变量表等信息，每个方法被调用直至执行完成对应着虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表存放各种基本数据类型、对象引用和字节码指令地址。需要的空间在编译期间完成分配，大小已经确定不会在运行期间改变。</p><p>虚拟机栈的异常分两种：StackOverflowError是栈深度大于JVM允许的最大深度，某个线程的栈内存超过了JVM的限制；OutOfMemoryError是无法向操作系统申请更多的物理内存给JVM栈使用。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行Java方法，本地方法栈为虚拟机使用到的Native方法服务。</p><p>有点虚拟机会把本地方法栈和虚拟机栈合二为一。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java堆是最大的一块，在虚拟机启动时创建，是被所有线程共享的一块内存区域，此内存区域的唯一目的就是<strong>存放对象示例</strong>。所有的对象示例以及数组都要在堆上分配。</p><p>Java堆内存可以分为新生代和老年代，再细致一点有Eden空间，From Survivor空间，To Survivor空间。</p><p>Java堆可以处于物理上不连续的内存空间中，只需要逻辑上是连续的即可。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区也是线程共享的内存区域，用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>方法区的回收主要是对常量池的回收和对类型的卸载，这部分区域很容易造成未完全回收导致内存泄漏。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分，常量池主要存放一些编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>除了会保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>并不是虚拟内存的一部分，不属于JVM规范定义的内存区域。</p><h3 id="2-对象访问"><a href="#2-对象访问" class="headerlink" title="2. 对象访问"></a>2. 对象访问</h3><p>不同的虚拟机实现的对象访问方式会有所不同，主流的方式有两种：使用句柄和直接指针。</p><ul><li>句柄方式</li></ul><p>Java堆中将会划出一块内存来作为句柄池，reference存储的就是对象的句柄地址，句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p><p><img src="https://i.loli.net/2019/06/27/5d14b52781fb784879.png" alt="通过句柄访问对象.png" title="通过句柄访问对象.png"></p><ul><li>直接指针</li></ul><p>直接指针的话Java堆对象布局中就必须考虑如何放置访问类型数据的相关信息，reference存的就是对象的地址。</p><p><img src="https://i.loli.net/2019/06/27/5d14b5c8b027414744.png" alt="通过直接指针访问对象.png" title="通过直接指针访问对象.png"></p><p>句柄方式在对象移动时不需要修改reference，只需要修改句柄中的示例数据指针；直接指针访问速度快。</p><h3 id="3-实战OutOfMemoryError"><a href="#3-实战OutOfMemoryError" class="headerlink" title="3. 实战OutOfMemoryError"></a>3. 实战OutOfMemoryError</h3><p>除了程序计数器外，其他虚拟机内存区域都有可能发生OOM。</p><h4 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h4><p>OOM产生原因：不断的创建对象，并且保证GC Roots到对象之间有可达路径。设置参数：堆最小值-Xms、堆最大值-Xmx</p><p>如果是内存泄漏，查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的路径与GC Roots相关联并导致无法自动回收的。如果是内存溢出，就应该检查虚拟机的堆参数，看看是否可以继续调大，或从代码检查是否存在某些对象生命周期过长、持有状态时间过长的情况。</p><h4 id="虚拟机栈和本地方法栈的溢出"><a href="#虚拟机栈和本地方法栈的溢出" class="headerlink" title="虚拟机栈和本地方法栈的溢出"></a>虚拟机栈和本地方法栈的溢出</h4><p>栈容量由-Xss参数设定，虚拟机栈和本地方法栈有如下两种异常：</p><ul><li>线程请求的栈深度大于虚拟机所允许的最大深度，StackOverflowError</li><li>虚拟机在扩展栈时无法申请到足够的内存空间，抛出OutOfMemoryError</li></ul><p>如果是建立多线程导致内存溢出，在不能减少内存数和更换64位虚拟机的情况下，只能通过减少最大堆和减少栈容量来换取更多的线程。</p><h4 id="运行时常量池溢出"><a href="#运行时常量池溢出" class="headerlink" title="运行时常量池溢出"></a>运行时常量池溢出</h4><p>常量池在方法区中，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制常量池的容量。不断新建有引用的常量，可以导致OOM，提示信息为：PermGen space，也说明运行时常量池属于方法区。</p><h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><p>方法区存放Class相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当运行时产生大量的类填满方法区时会产生溢出的情况。</p><p>实际应用中，如果在Spring或者Hibernate中经常对类增强时，会用到动态生成的Class保证可以加载到内存。在经常动态生成大量Class的应用中需要多加注意。</p><h4 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h4><p>直接内存通过-XX:MaxDirectMemorySize指定，如果不指定就和Java堆最大值（-Xmx）一样。直接内存异常时并没有真正去申请分配内存，而是通过计算的值没有内存分配手动抛出异常。</p><hr><h2 id="二、垃圾回收器与内存分配策略"><a href="#二、垃圾回收器与内存分配策略" class="headerlink" title="二、垃圾回收器与内存分配策略"></a>二、垃圾回收器与内存分配策略</h2><h3 id="1-对象是否存活"><a href="#1-对象是否存活" class="headerlink" title="1. 对象是否存活"></a>1. 对象是否存活</h3><p>堆中几乎放着所有Java对象的实例，垃圾收集器对堆进行回收时首先要确定哪些对象还在被使用着。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>给对象加一个引用计数器，每当一个地方引用时计数器值+1，引用失效时计数器值-1，为零时表示不可能再被使用。</p><p>引用计数算法不能解决对象之间相互循环引用的问题。</p><h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>通过一系列GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，表明此对象是不可用的。</p><p>GC Roots的对象包括以下几种：①虚拟机栈的栈帧中的本地变量表 ②方法区的类静态属性 ③方法区中的常量引用对象 ④本地方法栈中Native方法引用的对象</p><h4 id="引用的类型"><a href="#引用的类型" class="headerlink" title="引用的类型"></a>引用的类型</h4><ul><li>强引用<br>最普遍存在，类似“Object obj = new Object()”这类，强引用存在就不会被回收掉</li><li>软引用<br>还有用、但非必需的对象，在系统发生内存溢出之前，将这些对象进行回收，还是没有足够的内存才会抛出内存溢出异常。</li><li>弱引用<br>非必需对象，强度比软引用更弱，当垃圾回收工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li><li>虚引用<br>最弱的一种引用关系，一个对象的虚引用不会对起生存时间构成影响，也无法通过虚引用来取得一个对象实例，唯一作用是希望这个对象被回收时收到一个系统通知。</li></ul><h4 id="finalize-自我救活"><a href="#finalize-自我救活" class="headerlink" title="finalize()自我救活"></a>finalize()自我救活</h4><p>GC Roots搜索中的不可达对象要经历两次标记过程才会被回收。第一次标记时会进行一次筛选，查看对象是否有必要执行的finalize()方法，如果有要执行的finalize()，该对象会被放入一个队列中。虚拟机会执行该方法，但不会等待它运行结束。这里的finalize()中是自我救活的最后一次机会，该方法内将自己和引用链上的任何对象重新建立关联即可。</p><p>任何一个对象的finalize()方法都只会被系统自动调用一次，调用过以后再面临下一次回收时finalize()方法不会再次被执行。</p><p>任何时候都不推荐finalize()，这是Java向C/C++析构函数的妥协，应当使用try-finally实现类似功能。</p><h4 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h4><p>满足以下三个条件的类才能算是废弃的常量： ①Java堆中不存在该类的任何实例 ②加载该类的ClassLoader已经被回收 ③类的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类方法。</p><h3 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h3><p>各大平台的虚拟机操作内存的方法各不相同，本部分只介绍部分算法思想。</p><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>最基础的收集算法，标记需要回收的对象，标记完成统一回收。该方法存在有有效率低下、回收后产生大量不连续的内存碎片的问题。</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>可用内存划分为大小相同两块，每次使用一块，一块用完时将存活的对象复制到另一块，这样解决了内存碎片化问题。</p><p><img src="https://i.loli.net/2019/07/01/5d197f958629d41741.png" alt="复制回收算法.png" title="复制回收算法.png"><br>复制算法示意图</p><p>这种算法被广泛应用于新生代的回收中，实际使用中，新生代将内存划分为较大的Eden空间和两个较小的Survivor空间。对象被创建时先放到Eden，执行垃圾回收时Eden中还存活的对象放到ToSurvivor中，FromSurvivor中还存活的对象也拷贝到ToSurvivor上，然后To和From互换身份。这个过程也被称为Minor GC。</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p>和“标记-清除”算法过程大体一样，只是在标记完成后不直接对可回收的对象进行清理，而是让所有存活的对象都向一端移动。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象的生存周期不同将内存划分为几块，一般是新生代和老年代，根据各个年代的特点采用不同的收集算法。</p><p>新生代存活率低，采用复制算法；老年代存活率高，存勇标记-清除或者标记-整理。</p><h3 id="3-HotSpot的算法实现"><a href="#3-HotSpot的算法实现" class="headerlink" title="3. HotSpot的算法实现"></a>3. HotSpot的算法实现</h3><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>从GC Roots节点找引用链这个操作比较耗时，要逐个检查方法区中的引用，HotSpot的实现中，把对象内什么偏移量上是什么类型的数据计算出来（一组称为OopMap的数据结构），在JIT编译过程中也会在特定的位置记录下栈和寄存器中哪些位置是引用，使得GC扫描时可以直接获取这些信息</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>HotSpot只在特点的位置记录OopMap信息，这些位置叫做安全点，安全点的选取不能太少增大GC等待时间，也不能太多增大运行负荷；还有一个问题是如何保证每个线程在GC发生时都能“跑”到最近的安全点再停顿下来。</p><h3 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4. 垃圾收集器"></a>4. 垃圾收集器</h3><p>垃圾收集器可以理解为垃圾回收算法的具体实现。</p><p><img src="https://i.loli.net/2019/07/02/5d1abbc6e2bbe84464.png" alt="HotSpot垃圾收集器.png" title="HotSpot垃圾收集器.png"></p><p>这是七种作用于不同分代的收集器，上半部分是年轻代，下半部分是老年代部分，如果两个收集器之间存在连线，那也就是说明它们可以搭配使用。</p><p>没有任何一个收集器能放之四海皆准，只有对具体应用最合适的收集器。</p><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>原来是新生代的唯一选择，单线程收集器，这里的单线程意思是进行垃圾回收时会停止掉其他所有的工作线程。</p><p>Serial收集器的优点在于简单而高效，专心做垃圾回收，停顿时间一般不会超过一百多毫秒。</p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>可以理解为Serial收集器的多线程版本，除了使用多条线程进行垃圾回收外其余均和Serial收集器一致，实际上共用了很多代码。</p><p>ParNew收集器在单CPU环境中绝对不会比Serial收集器效果更好。</p><p>除了Serial之外，ParNew是新生代中唯一可以和CMS搭配使用的收集器。</p><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>新生代收集器，使用复制算法，并行的多线程收集器。Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。高吞吐量也就是高效率地利用CPU时间，尽快完成程序的运行任务。</p><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial收集器老年代版本，单线程收集器，使用“标记-整理”算法。</p><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Scavenge收集器的老年代版本，使用多线程的“标记-整理”算法。</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>目标是获取最短回收停顿时间，也可以说是重视服务的响应速度，基于“标记-清除”算法实现。</p><p>运作过程相对更加复杂，过程分为4个步骤：初始标记、并发标记、重新标记和并发清除。初始标记和重新标记会停掉其他所有工作线程，初始是标记一下GC Roots直接关联的对象，重新标记修正并发标记期间标记产生变动的部分。</p><p>优点在于：并发收集、低停顿。</p><p>缺点在于：对CPU资源敏感，不同数量的CPU上的利用率差异大；无法处理浮动垃圾；基于“标记-清除”会产生大量空间碎片。</p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>当前最前沿成果，对比CMS的改进在于：基于“标记-整理”；非常精准的控制停顿。</p><p>G1是Garbage First的简称，因为能避免全区域的垃圾收集，将Java堆氛围多个大小固定的独立区域（包括新生、老年代），维护一个优先列表，优先回收垃圾最多的区域。</p><h3 id="5-内存分配与回收策略"><a href="#5-内存分配与回收策略" class="headerlink" title="5. 内存分配与回收策略"></a>5. 内存分配与回收策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象分配在新生代Eden区上，当没有足够的内存时，会发起一次新生代的Minor GC。</p><h4 id="对象直接进老年代"><a href="#对象直接进老年代" class="headerlink" title="对象直接进老年代"></a>对象直接进老年代</h4><p>大对象就是指需要大量连续内存空间的Java对象，要避免代码中存在很多“朝生夕灭”的“短命大对象”。</p><h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><p>JVM给每个对象定义了一个对象年龄计数器，对象在一次次Minor GC后每存活一次对象年龄加一，年龄到一定程度（默认15岁）就会被晋升到老年代中。</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>并不一定是到达设置的年龄后才能进入老年代，当Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半是，年龄大于改年龄的对象就直接进入老年代。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>Minor GC时，虚拟机会检查晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于进行一次Full GC。</p><p>当出现大量对象在Minor GC后仍然存活的情况时，需要老年代进行担保，让Survivor无法容纳的对象直接进入老年代。</p><hr><h2 id="三、-虚拟机性能监控与故障处理"><a href="#三、-虚拟机性能监控与故障处理" class="headerlink" title="三、 虚拟机性能监控与故障处理"></a>三、 虚拟机性能监控与故障处理</h2><h3 id="1-JDK的命令行工具"><a href="#1-JDK的命令行工具" class="headerlink" title="1. JDK的命令行工具"></a>1. JDK的命令行工具</h3><p><strong>jps</strong>(JVM Process Status Tool)，虚拟机进程状况工具，可以列出正在运行的虚拟机进程，显示虚拟机执行主类。</p><p><strong>jstat</strong>(JVM Statistic Monitoring Tool)，虚拟机统计信息监视工具，监事虚拟机各种运行状态信息，运行期间定位虚拟机性能。</p><p><strong>jinfo</strong>(Configuration Info for Java)，Java配置信息工具，实时查看和调整虚拟机的各项参数。</p><p><strong>jmap</strong>(Memory Map for Java)，Java内存映像工具，用于生成对转出快照。jmap的作用还可以查询finalize执行队列，Java堆和永久代的详细信息。</p><p><strong>jhat</strong>(JVM Heap Analysis Tool)，虚拟机堆转储亏按照分析工具，与jmap搭配使用，来分析生成的堆转储快照。</p><p><strong>jstack</strong>(Stack Trace for Java)，Java堆栈跟踪工具，用于生成虚拟机当前时刻的线程快照，也就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成快照的目的是定位线程出现长时间停顿的原因。</p><h3 id="2-JDK的可视化工具"><a href="#2-JDK的可视化工具" class="headerlink" title="2. JDK的可视化工具"></a>2. JDK的可视化工具</h3><p><strong>JConsole</strong>，一个基于JMX的可视化监视和管理工具。</p><p><strong>VisualVM</strong>，强大的运行监视和故障处理程序。</p><hr><h2 id="四、-调优案例分析与实战"><a href="#四、-调优案例分析与实战" class="headerlink" title="四、 调优案例分析与实战"></a>四、 调优案例分析与实战</h2><h3 id="1-常见情况分析"><a href="#1-常见情况分析" class="headerlink" title="1. 常见情况分析"></a>1. 常见情况分析</h3><ul><li>高性能硬件上的程序部署策略</li></ul><p>两种主流方式： ①通过64位JDK来使用大内存 ②适用若干32位虚拟机建立逻辑集群。</p><p>方案①的缺点：内存回收耗时长、性能低于方案②、程序需要足够稳定、消耗的内存更大。</p><p>因此更多人选择方案②搭配一个负载均衡器。但方案②也有如下缺点：磁盘竞争导致IO异常、很难高效的利用某些资源池、32位内存限制、大量使用缓存的应用会造成每个节点上的内存浪费。</p><ul><li>集群建同步导致的内存溢出</li></ul><p>当网络情况不能满足集群间频繁的数据传输要求时，重发数据在内存中不断的堆积，很容易出现内存溢出。</p><ul><li>堆外内存导致的溢出错误</li></ul><p>除了Java堆和永久代内存外有：Direct Memory（直接内存），线程堆栈，Socket缓存区，JNI代码，虚拟机和GC。</p><ul><li>服务器JVM进程崩溃</li></ul><p>客户端与服务器调用采用异步方式，速度上的不对等是的web服务堆积越来越多，超过承受能力产生崩溃。</p><h3 id="2-常见运行速度调优"><a href="#2-常见运行速度调优" class="headerlink" title="2. 常见运行速度调优"></a>2. 常见运行速度调优</h3><p>通过参数的设置可以实现以下优化：</p><ul><li>编译时间和类加载时间优化</li><li>调整内存设置垃圾回收频率</li><li>选择收集器降低延迟</li></ul><hr><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>周志明. 深入理解Java虚拟机[M]. 机械工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      JVM的自动内存管理机制，从理论知识、异常现象、代码、工具、案例和实战多角度讲解。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="java" scheme="https://296245482.github.io/tags/java/"/>
    
      <category term="jvm" scheme="https://296245482.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》阅读笔记 第十-十二章 MySQL的复制、可扩展、高可用</title>
    <link href="https://296245482.github.io/2019/06/21/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81-%E5%8D%81%E4%BA%8C%E7%AB%A0-MySQL%E7%9A%84%E5%A4%8D%E5%88%B6%E3%80%81%E5%8F%AF%E6%89%A9%E5%B1%95%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>https://296245482.github.io/2019/06/21/《高性能MySQL》阅读笔记-第十-十二章-MySQL的复制、可扩展、高可用/</id>
    <published>2019-06-21T15:07:41.000Z</published>
    <updated>2019-06-21T15:07:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL内建的复制功能是大规模、高性能应用的基础，应用“水平扩展”的架构，<strong>为服务器配置一个或多个备库</strong>，建设支持高性能、可扩展、灾难恢复、备份以及数据仓库的应用，这也是MySQL快速流行的关键原因。</p><p>MySQL的高可扩展是当应用的规模变得越来越庞大时还能<strong>保证快速、高效并且经济</strong>，可扩展能力也就是表明该系统当需要增加资源以执行更多工作时系统能够获得划算的等同的提升，不会出现系统收益递减转折点之后无法进一步增长。</p><hr><h2 id="第十章-复制"><a href="#第十章-复制" class="headerlink" title="第十章 复制"></a>第十章 复制</h2><h2 id="MySQL复制概述"><a href="#MySQL复制概述" class="headerlink" title="MySQL复制概述"></a>MySQL复制概述</h2><p>简单说就是一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另一台主库，主库和备库之间可以由多种组合方式。</p><p>MySQL的复制是通过在主库上记录二进制日志，在备库重放日志的方式来实现异步的数据复制，这意味着主备库一致性不能保证，存在一致延迟。</p><p>复制过程可以简述为：首先主库把数据更改记录到二进制日志，然后备库将主库上的日志复制到自己的中继日志中，备库读取中继日志中的事件，将其重放到备库数据上。</p><p><img src="https://i.loli.net/2019/06/12/5d009ae486dd641514.png" alt="MySQL的复制.png" title="MySQL的复制.png"></p><h2 id="复制的原理"><a href="#复制的原理" class="headerlink" title="复制的原理"></a>复制的原理</h2><ul><li>基于语句的复制</li></ul><p>主库会记录那些造成数据更改的查询，备库实际上只是把主库上执行过的SQL再执行一遍</p><ul><li>基于行的复制</li></ul><p>实际数据记录在二进制日志中，可以正确的复制数据库中的每一行。</p><p>MySQL能够在这两种复制模式间动态切换，默认情况下使用的是基于语句的复制，但如果语句无法被正确复制时，就会切换到基于行的复制模式。</p><h2 id="复制拓扑"><a href="#复制拓扑" class="headerlink" title="复制拓扑"></a>复制拓扑</h2><p>复制拓扑的主要原则：</p><ul><li>一个MySQL备库实例只能有一个主库</li><li>每个备库都有一个唯一的服务器ID</li><li>一个主库可以有多个备库</li><li>如果打开了log_slave_updates选项，备库直接可以传递主库的变更</li></ul><h3 id="现有的常见的复制拓扑结构："><a href="#现有的常见的复制拓扑结构：" class="headerlink" title="现有的常见的复制拓扑结构："></a>现有的常见的复制拓扑结构：</h3><ul><li>一主库多备库</li><li>主动-主动模式，互为主库备库<br>同时修改数据时容易产生数据一致，无法正常复制的问题，很难做好数据划分和权限。</li><li>主动-被动模式下的主-主复制<br>执行ALTER TABLE时会锁住整个表，阻塞读写甚至导致服务中断，这时可以选择在被动库上操作，停止主动服务器上的备库复制线程，然后在被动服务器上执行修改，然后交换主被动角色，在先前的服务器上启动复制线程，在不影响正常业务的情况下完成大规模修改。</li><li>各自都拥有备库的主-主结构</li><li>环形复制<br>双主的结构实际上就是环形结构的一种特例，环形结构是三个或更多的主库，每个服务器都是它之前服务器的备库，是它之后服务器的备库。环形结构要求每个节点都可用，所以非常脆弱，不应该得到提倡。</li><li>主库、分发主库以及备库<br>主库和备库之间有一个分发主库来管理</li><li>树形或金字塔形<br>主库分发到几个备库，这几个备库又各自分发到更多备库。</li></ul><h2 id="复制和容量规划"><a href="#复制和容量规划" class="headerlink" title="复制和容量规划"></a>复制和容量规划</h2><p>如果要增加数据库的性能到原来的两倍，不是简单的线性扩两倍机器那么简单，因为补充了备库，每一台备库做复制操作都是要消耗部分性能的，只有剩下的性能才能用来进行读操作，因此可能存在性能要求翻倍服务器翻三四倍的情况，并且随着要求越高需要新增的服务器远远不是线性扩展。</p><p>上述情况发生时就要考虑增加集群的写入能力，惟一的办法也就是对数据进行分区，这将会在后续的内容中讲到。</p><p>在构建大型应用时，有意让服务器不被充分使用，构建这样冗余容量也是实现高可用性的最佳方式之一，当然也可以让应用在降级模式下运行，第12章将会介绍更多。</p><h2 id="复制的问题及解决方案"><a href="#复制的问题及解决方案" class="headerlink" title="复制的问题及解决方案"></a>复制的问题及解决方案</h2><p>MySQL中的复制实现简单、配置容易，所以面对因为各种意外情况可能会导致停止，陷入混乱并中断，导致数据不一致等等。</p><p><strong>常见的一些复制问题例如</strong>：</p><p>主备库关闭，主备库二进制日志损坏，备库中继日志损坏，使用了非事务型表，事务型和非事务型表混合使用，通过一些不确定的方式更改数据（例如带LIMIT的更新或者）可能会导致主备不一致，主备库使用的不同的存储引擎，不唯一的服务器ID，未定义的服务器ID，主-主的复制结构，过大的复制延时，受限制的复制带宽等等问题。</p><p>上述的复制过程中可能存在的问题在以后设计中都应该尽量避免出现，及时无法避免也应该仔细调研寻找一个较为平衡的方法解决。</p><hr><h2 id="第十一章-可扩展的MySQL"><a href="#第十一章-可扩展的MySQL" class="headerlink" title="第十一章 可扩展的MySQL"></a>第十一章 可扩展的MySQL</h2><p>在MySQL扩展策略上，典型的应用在增长到非常庞大时，通常是从单个服务器转移到向外扩展的拥有读备库的架构，再到数据分片/或者按照功能分区。</p><h2 id="可扩展性概述"><a href="#可扩展性概述" class="headerlink" title="可扩展性概述"></a>可扩展性概述</h2><p>从较高层次说，可扩展性就是能够通过增加资源来提升容量的能力，系统容量也就是在一定时间内能够完成的工作量，或可以简单的认为是处理负载的能力。</p><p>在进行资源扩充时，升级到两倍所需要的付出常常不只是最初开销的两倍，服务器数量和容量之间的关系远不是线性扩展那么简单，服务器数量到一定程度时甚至投入反而会带来负回报。</p><h2 id="扩展MySQL"><a href="#扩展MySQL" class="headerlink" title="扩展MySQL"></a>扩展MySQL</h2><p>在扩展的过程中，自身使用更强悍的机器称为“向上扩展”，将任务分配到多台计算机上称为“向外扩展”，内部将一些很少使用或者不需要的数据清理或者归档称为“向内扩展”。</p><h3 id="提前规划可扩展性"><a href="#提前规划可扩展性" class="headerlink" title="提前规划可扩展性"></a>提前规划可扩展性</h3><p>①应用的功能完成了多少 ②规划需要承担的负载有多少，预期的最大负载是多少 ③考虑系统依赖了其他部分来分担负载，例如备库，如果他们生效时，是否还能正常运行？是否需要禁用部分功能。</p><h3 id="向上扩展"><a href="#向上扩展" class="headerlink" title="向上扩展"></a>向上扩展</h3><p>也可以叫垂直扩展，替换为性能更强的硬件，简单高效，无需关心一致性等问题。但向上扩展总会是有限制的，会存在性能的天花板，不断增长的业务会使得CPU内存一个个成为瓶颈，触及到向上扩展的天花板时就需要考虑向外扩展。</p><h3 id="向外扩展"><a href="#向外扩展" class="headerlink" title="向外扩展"></a>向外扩展</h3><p>也可以叫水平扩展，策略主要分为三部分：复制、拆分、数据分片。</p><p>复制也就是将数据进行分发，备库用于读查询，另外就是将工作负载分布到多个“节点”，如何分布工作负载是一个复杂的话题。</p><ol><li><p>按功能划分<br>这样划分不能无限地进行扩展，一个功能被捆绑到单个MySQL节点，只能进行垂直扩展。</p></li><li><p>数据分片<br>通常会对一些增长的非常庞大的数据进行分片，把数据分割成一小片或者一小块，存储到不同的节点。<br>（分片一般实现较难，如果不是必要，尽量不要选择分片，尽可能的先通过性能调优或者更好的数据库设计来推迟分片。）</p></li><li><p>选择分区键<br>分区键决定了每一行分配到哪一个分区中，而可扩展性的一大原则就是避免不同分片节点间的交互，因此在保证分片足够小的同时，还要避免跨分片查询的情况出现。<br>一个好的分区键常常是数据库中一个比较重要的实体的主键，尽量把相关联的实体靠的更近，并且一块块之间很少或几乎没有什么关联操作。</p></li><li><p>多个分区键<br>某些应用存在两个或更多个“维度”数据的时候，可能拥有多个分区键，这也意味着某些数据可能在系统中至少需要存储两份。</p></li><li><p>跨分片查询<br>一条查询语句如果需要获取多个分片上的数据的话，就需要将一条查询拆分成多条并行执行的查询，每个分片上执行一条。<br>或者也可以借助汇总表来执行，也就是多一分冗余数据在全局节点中，并使用缓存来分担负载。</p></li><li><p>节点、分片、数据的分配<br>分片和节点不一定是一对一的关系，应尽可能在单个节点上存储多个分片，分片的大小应该是易于管理的足够小，小的分片是的数据备份和恢复更加容易。</p></li></ol><h3 id="通过多实例扩展"><a href="#通过多实例扩展" class="headerlink" title="通过多实例扩展"></a>通过多实例扩展</h3><p>研究和经验表明MySQL并不能完全发挥现代硬件的性能，当扩展到超过24个CPU核心或者是128GB内存时，MySQL的性能趋于平缓不再上升。</p><p>可以在一台服务器上运行多个实例，然后划分服务器的硬件资源分配给每个实例。</p><h3 id="向内扩展"><a href="#向内扩展" class="headerlink" title="向内扩展"></a>向内扩展</h3><p>对不再需要的数据进行归档和清理。将活跃数据和非活跃数据进行隔离。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡主要五个目的：①可扩展 ②高效性 ③可用性 ④透明性 ⑤一致性</p><ul><li><p>直接连接<br>应用直接和MySQL服务器相连，主要可以采用这些方法实现负载均衡：主备库的读/写分离；直接修改应用的配置，例如连接的数据库；为不同的服务器定不同的DNS；利用服务器间转移虚拟地址。</p></li><li><p>引入中间件<br>中间件作为网络通信的代理，一边接受通信请求，一边将这些请求派发到指定的服务器上，中间件可以是硬件设备或者是软件。</p></li></ul><hr><h2 id="第十二章-高可用性"><a href="#第十二章-高可用性" class="headerlink" title="第十二章 高可用性"></a>第十二章 高可用性</h2><p>“高可用性”简单来说意味着更少的宕机时间，容易与冗余、数据完整性，负载均衡混淆。</p><p>从以下两方面思考：</p><ul><li>增加两次故障的正常运行时间<br>防止故障发生，故障根源分析，事后检验。</li><li>减少从故障中恢复的时间<br>建立冗余，让系统具备故障转移能力。</li></ul><h3 id="什么是高可用性"><a href="#什么是高可用性" class="headerlink" title="什么是高可用性"></a>什么是高可用性</h3><p>通常用百分比表示，可用性应该包括服务器正在运行的时间段和是否能以足够好的性能处理请求。</p><p>高可用性实际上是在宕机造成的损失与降低宕机所花费的成本之间去的一个平衡。</p><h3 id="如何实现高可用性"><a href="#如何实现高可用性" class="headerlink" title="如何实现高可用性"></a>如何实现高可用性</h3><p>高可用性的度量维度：平均失效时间、平均恢复时间</p><p>对系统变更保持管理，及时监控核心流程，建设具备提供冗余和故障转移能力的系统架构。</p><p>所有的宕机事件都是有多方面的失效联合到一起导致的，可以利用合适的方法确保单点的安全。</p><h3 id="避免单点失效"><a href="#避免单点失效" class="headerlink" title="避免单点失效"></a>避免单点失效</h3><p>冗余、备用组件的切换机制，或者是优秀的负载均衡器。</p><ul><li>共享存储或磁盘复制</li><li>MySQL主备库同步复制</li><li>基于复制的冗余</li></ul><h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><p>故障转移和故障恢复，分别代表新的服务器替换和修复故障服务器重新再替换回来。</p><p>故障转移最重要的部分是故障恢复，要求服务器之间能够自如切换，也可以说是对称的复制布局。</p><ul><li>提升备库或切换角色</li><li>虚拟IP地址或IP接管</li><li>代理、端口转发、网络地址切换、硬件负载均衡实现故障转移和恢复</li><li>在应用中处理故障转移</li></ul><hr><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>BaronSchwartz, PeterZaitsev, VadimTkachenko, et al. 高性能MySQL[M]. 电子工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      MySQL内建的复制功能是大规模、高性能应用的基础，应用“水平扩展”的架构，为服务器配置一个或多个备库，建设支持高性能、可扩展、灾难恢复、备份以及数据仓库的应用，这也是MySQL快速流行的关键原因。MySQL的高可扩展是当应用的规模变得越来越庞大时还能保证快速、高效并且经济，可扩展能力也就是表明该系统当需要增加资源以执行更多工作时系统能够获得划算的等同的提升，不会出现系统收益递减转折点之后无法进一步增长。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》阅读笔记 第八、九章 服务器、操作系统、硬件优化</title>
    <link href="https://296245482.github.io/2019/06/11/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E3%80%81%E4%B9%9D%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96/"/>
    <id>https://296245482.github.io/2019/06/11/《高性能MySQL》阅读笔记-第八、九章-服务器、操作系统、硬件优化/</id>
    <published>2019-06-11T15:42:50.000Z</published>
    <updated>2019-06-11T15:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL服务器配置的学习应该是从MySQL内核和行为开始，然后利用这些知识来指导配置MySQL。如果配置不单单考察硬件，配置情况应该更加符合服务器的工作负载、数据和应用需求。配置项只需要修改基本项即可，不应该随便修改，否则会引起很多意料外的问题。多数情况下默认的配置项即可。</p><p>一般不建议通过寻找有问题的地方来修改配置项，最好还是从查询语句和相应时间入手开始分析。</p><p><strong><em> 本篇从原书第八、九章展开，省略了很多的内容和章节，只选取了自己感觉日常可能会涉及的部分做了简要的记录。 </em></strong></p><h2 id="MySQL配置原理"><a href="#MySQL配置原理" class="headerlink" title="MySQL配置原理"></a>MySQL配置原理</h2><p>配置信息可以从命令行参数设置或者是在配置文件中设置。</p><p>做动态设置务必小心，在线更改设置可能会导致数据库做大量的工作，例如从缓存中刷新脏块。实际操作中都需要详细了解设置更改的立即后果，了解后果再行动。</p><p>硬件上及时性能翻倍，例如内存大小翻倍了，但是配置的设置不是简单的乘2这么简单，有可能导致超过地址空间等问题。除非是硬件、工作负载和数据是完全静态的，否则都可能需要重新检查配置文件。</p><p>一个完美的配置可能需要不断的通过基准测试迭代验证来获得，需要大量的工作和研究，大部分情况下收益很小，不如把时间花费在检查备份、监控执行计划上。</p><h2 id="MySQL-I-O配置"><a href="#MySQL-I-O配置" class="headerlink" title="MySQL I/O配置"></a>MySQL I/O配置</h2><p>这些配置影响着MySQL怎样同步数据到磁盘以及如何做恢复操作，I/O操作是代价很大的，如果可以冒一点点风险让数据没有立即持久化到磁盘是，就可以增加并发性和减少I/O等待，配置MySQL I/O也就是多大的持久化风险和高并发性的平衡。</p><ul><li>InnoDB事务</li></ul><p>“把日志缓冲写到日志文件”和“把日志刷新到持久化存储”这两者是不同的，写进日志文件只是简单的把数据从InnoDB的内存缓冲转移到操作系统的缓存，并没有把数据写到持久化存储。把日志刷新到持久话存储意味着InnoDB请求操作系统把数据刷出缓存，并且确认写到了磁盘。</p><p>上述日志缓冲刷新到持久化存储中，以求提交的事务全部被持久这一过程，在持久化的实效和性能之间如果有权衡的的话可以通过设置innodb_flush_log_at_trx_commit变量来控制日志缓冲刷新的频繁程度。</p><ul><li>InnoDB表空间</li></ul><p>InnoDB把数据保存在表空间内，本质上是有一个或者多个磁盘文件组成的虚拟文件系统。InnoDB用表空间实现很多功能，不只是存储表和索引，还保存回滚日志、插入缓存、双写缓冲。</p><h2 id="MySQL并发配置"><a href="#MySQL并发配置" class="headerlink" title="MySQL并发配置"></a>MySQL并发配置</h2><ul><li>InnoDB并发设置</li></ul><p>在高并发的场景下，因为并发导致的性能降低，唯一的解决办法是限制并发，升级服务器。InnoDB有自己的“线程调度器”控制线程怎么进入内核访问数据、以及他们在内核中一次可以做什么，这其中限制多少线程进入内核是可配置的。同时还可以设置提交阶段的并发数。</p><ul><li>MyISAM并发配置</li></ul><p>MyISAM不像InnoDB样支持MVCC，虽然也是表级锁，但只有插入操作是在表的末尾才能支持并发插入。MyISAM可以设置一个并发插入变量限制并发程度。</p><h2 id="固态硬盘的优化"><a href="#固态硬盘的优化" class="headerlink" title="固态硬盘的优化"></a>固态硬盘的优化</h2><p>InnoDB的默认配置是为硬盘驱动器定制的，在固态硬盘上使用旧版MySQL时需要作这类改进：增加I/O容量、设置更大的InnoDB文件、把而至今日志文件转移到RAID卷节省更多的闪存设备性能、禁用预读、禁用双写缓存、限制插入缓存大小等。</p><h2 id="硬件优化总结"><a href="#硬件优化总结" class="headerlink" title="硬件优化总结"></a>硬件优化总结</h2><p>MySQL需要的四种资源是：CPU、内存、硬盘、网络资源，网络一般不会作为很严重的瓶颈出现。对CPU而言，一般会选择更快而不是更多。CPU、内存、磁盘三者在性能上的关系错综复杂，某个部分不足的话可能会在其他地方显现出来问题，具体在某些场景下也应该详细分析例如工作集大小等来决定具体的配置方案。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>BaronSchwartz, PeterZaitsev, VadimTkachenko, et al. 高性能MySQL[M]. 电子工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      MySQL服务器配置的学习应该是从MySQL内核和行为开始，然后利用这些知识来指导配置MySQL。如果配置不单单考察硬件，配置情况应该更加符合服务器的工作负载、数据和应用需求。配置项只需要修改基本项即可，不应该随便修改，否则会引起很多意料外的问题。多数情况下默认的配置项即可。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》阅读笔记 第七章 MySQL高级特性</title>
    <link href="https://296245482.github.io/2019/06/04/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://296245482.github.io/2019/06/04/《高性能MySQL》阅读笔记-第七章-MySQL高级特性/</id>
    <published>2019-06-04T15:24:20.000Z</published>
    <updated>2019-06-04T15:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL从5.0和5.1开始引入了很多高级特性，分区、触发器等。除了分区之外大部分功能其实用到的场景都不是很多，从MySQL层面上使用这些高级特性说不定在后期的使用上会大大增加升级重构的成本，实际中这些高级特性的任务都在应用端层面完成了，这里这些高级特性能够做相关的了解。</p><h2 id="7-1-分区表"><a href="#7-1-分区表" class="headerlink" title="7.1 分区表"></a>7.1 分区表</h2><p>分区的主要目的是将数据按照一个较粗粒度、简易的分布在不同的表中。实现方式是对底层表的封装，意味着索引也是按照分区的字表定义的，没有全局的索引。在表创建时使用PARTITION BY子句定义各个分区存放数据。</p><p>分区表的主要应用场景如下：</p><ul><li>没有合适的索引。</li><li>表非常大无法全部放到内存，或者只在表最后有热点数据，其他全是历史数据。</li><li>批量删除大量数据。</li><li>分区表数据可以分布在不同的物理设备上。</li><li>可以避免某些索引互斥访问和锁竞争等。</li><li>独立的备份和恢复分区，在非常大的数据量场景下效果好。</li></ul><h3 id="7-1-1-分区表原理"><a href="#7-1-1-分区表原理" class="headerlink" title="7.1.1 分区表原理"></a>7.1.1 分区表原理</h3><p>分区表由多个底层表实现的，存储引擎管理分区的各个底层表和管理普通表一样，各个底层表使用的也是相同的存储引擎，各个底层表上的索引也是完全相同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p><ul><li>SELECT查询<br>分区别先打开并锁住所有的底层表，优化器判断是否可以过滤部分分区，然后再调用对应存储引擎的接口访问各个分区的数据。</li><li>INSERT操作<br>同上，先锁住，确定哪个分区接收这个数据，再将记录写入底层表。</li><li>DELETE操作<br>同上，先锁住，确定分区，进行删除。</li><li>UPDATE操作<br>同上先锁住所有底层表，找到需要更新的数据的分区，取出更新，判断新数据放在哪个分区，完成写入操作，然后进行原数据的删除。</li></ul><p>大部分操作时支持过滤的，确定了操作分区后无须对其他分区进行操作。虽然操作全都是“先打开并锁住所有底层表”，但如果存储引擎能够自己实现行级锁，则会在分区层释放对应的表锁，这个加锁解锁过程和普通的InnoDB上的查询类似。</p><h3 id="7-1-2-分区表类型"><a href="#7-1-2-分区表类型" class="headerlink" title="7.1.2 分区表类型"></a>7.1.2 分区表类型</h3><p>常见的分区类型：</p><ul><li>根据键值分区，减少互斥量竞争。</li><li>使用数学模函数进行分区，数据轮询放入不同的分区，例如对日期做模7的运算。</li></ul><h3 id="7-1-3-如果使用分区表"><a href="#7-1-3-如果使用分区表" class="headerlink" title="7.1.3 如果使用分区表"></a>7.1.3 如果使用分区表</h3><p>当数据量超大的时候，B-Tree索引就无法起作用了。除非是索引覆盖扫描，否则数据库需要根据索引扫描结果回表，这将会产生大量随机I/O，另外这样索引的维护代价也会非常高。</p><p>这种情况下就应该完全放弃B-Tree索引，选择一些更加粗粒度的方式检索，这也是分区要做的，以小代价定位数据在那一块区域，选定区域后，区域内可以建索引，可以顺序扫描，数据可以缓存到内存，只需要一个简单的表达式可以表达每个分区存放的是什么数据。</p><p>为了保证大数据量的可扩展性，一般有以下的策略：</p><ul><li>全量扫描数据，不需要索引<br>使用简单的分区方式存放表，不用任何索引，根据分区的规则简单运算大致定位需要的数据位置，将数据限制在少数分区中。</li><li>索引数据，分离热点<br>将热点数据单独放在一个分区里，让这个分区数据有机会缓存在内存中，这样很小的分区表能使用索引也能使用缓存。</li></ul><h3 id="7-1-4-分区表的坑"><a href="#7-1-4-分区表的坑" class="headerlink" title="7.1.4 分区表的坑"></a>7.1.4 分区表的坑</h3><ul><li>NULL值会使分区过滤失效<br>如果按照某个列值进行分区时，那么为NULL值或者是非法值的数据将会被存到一个它们不应该出现的分区中。可以创建一个“无用”分区或者直接使用列本身而不是列的函数进行分区。</li><li>分区列和索引列不匹配<br>定义索引的列和分区的列不匹配会导致无法进行分区的过滤。通过索引条件进行扫描时会扫描每一个分区内的索引。</li><li>选择分区的成本可能会很高<br>实现方式有多种，性能各不相同，随着分区数量的增加，成本会越来越高。（键分区和哈希分区就没有这样的问题）</li><li>打开并锁住所有底层表的成本很高<br>当查询分区表时MySQL需要打开并锁住所有的底层表，这个操作发生在分区过滤之前，这个开销无法通过分区过滤和分区类型来改善，对一些本身操作就非常快的操作会带来明显的额外开销。</li><li>维护分区的成本可能很高<br>新增和删除很快，但是例如重组分区或者ALTER会创建一个临时分区，复制然后删除旧分区。</li><li>分区必须使用相同的存储引擎。</li><li>某些引擎不支持分区表。</li><li>在MySQL 5.5分区表才开始趋于稳定。</li></ul><h3 id="7-1-5-查询优化"><a href="#7-1-5-查询优化" class="headerlink" title="7.1.5 查询优化"></a>7.1.5 查询优化</h3><p>分区优化最大的优点就是优化器可以过滤一些分区，当然这是需要在WHERE条件中带入分区列的。</p><p>EXPLAIN PARTITIONS可以观察优化器是否执行了分区过滤。</p><p>MySQL只能根据使用分区的列本身才能过滤分区，不能根据表达式的值来过滤分区（和查询中必须使用独立的列才能使用索引是一样的道理）。</p><h3 id="7-1-6-合并表"><a href="#7-1-6-合并表" class="headerlink" title="7.1.6 合并表"></a>7.1.6 合并表</h3><p>合并表是早期的、简单的分区实现，是一种将要被淘汰的技术，分区表和优化器的紧密结合才是未来的趋势。合并表这里不做过多记录。</p><h2 id="7-2-视图"><a href="#7-2-视图" class="headerlink" title="7.2 视图"></a>7.2 视图</h2><p>MySQL 5.0开始引入了视图，本身是一个虚拟表，数据由MySQL其他表中生成的，大多数地方MySQL对于视图和表是同等对待的。对于好几个表的复杂查询，使用视图有时候会大大简化问题。</p><p>最简单的使用方法是将SELECT语句的结果放到临时表中，当需要访问视图时直接访问这个临时表就可以了。这种情况也有两种处理视图的方算法，一种是合并算法，就视图的定义SQL直接包含进查询的SQL中（SELECT指定的字段）；另一种是临时表算法，先查出结果定一个临时表，再从临时表中选择特定的列。主要都采用合并的算法。</p><p>视图的性能很难预测，需要详细的测试。</p><p>可更新视图是指可以通过更新视图来更新视图涉及的相关表。如果视图中包含GROUP BY、UNION、聚合函数等就不能被更新。</p><p>不支持物化视图，不支持视图中创建索引，</p><h2 id="7-3-外键约束"><a href="#7-3-外键约束" class="headerlink" title="7.3 外键约束"></a>7.3 外键约束</h2><p>外键可以看做是一个确保系统完整性的额外的特性，但是会带来额外的复杂性和额外的索引消耗，一般人都会选择在应用中实现外键功能。</p><p>InnoDB是MySQL最后那个唯一支持外键的内置存储引擎，InnoDB强制外键使用索引。</p><p>外键的好处：如果要确保两个相关表始终有一直的数据，使用外键比在应用程序中检查性能要高得多。不足：外键约束是的查询时需要额外访问一些别的表，意味着其他表也要进行锁等待。</p><p>触发器可以代替外键，如果只是进行数值约束，触发器或者应用内实现该约束会更好</p><p><strong><em>外键会带来很大的额外消耗，使用前要仔细做好基准测试</em></strong></p><h2 id="7-4-在MySQL内部存储代码"><a href="#7-4-在MySQL内部存储代码" class="headerlink" title="7.4 在MySQL内部存储代码"></a>7.4 在MySQL内部存储代码</h2><p>MySQL允许通过触发器、存储过程、函数的形式来存储代码。存储代码帮助应用隐藏复杂性，使得应用开发更简单，不过性能可能更低，存在潜在的风险。</p><p>MySQL允许内部存储代码的形式：</p><ul><li>存储过程和函数</li><li>触发器</li><li>事件</li></ul><h2 id="7-5-游标"><a href="#7-5-游标" class="headerlink" title="7.5 游标"></a>7.5 游标</h2><p>MySQL在服务器端提供只读的、单向的游标，游标中指向的对象都是存储在临时表中。游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制，尽管能遍历结果中的所有行，但他一次只指向一行，主要作用就是对查询数据库所返回的记录进行遍历，以便进行相应的操作。</p><h2 id="7-6-绑定变量"><a href="#7-6-绑定变量" class="headerlink" title="7.6 绑定变量"></a>7.6 绑定变量</h2><p>绑定变量最大的用处在于创建一个绑定变量的SQL，客户端向服务器发送了一个SQL语句原型，服务器端收到这个SQL语句框架后解析并存储这个SQL语句的部分执行计划，返回给客户端一个SQL语句处理句柄。客户端可以通过像服务端发送各个参数取值和SQL语句句柄来执行一个具体的查询。</p><p>这样服务器只需解析一个SQL语句，执行计划会被缓存，发送的句柄和参数可以使用二进制传输，不用发送整个查询语句，效率更高。绑定变量相对更加安全，减少SQL注入。</p><p>服务器端的绑定变量是使用二进制协议将具体的参数值发给服务器端并执行，客户端模拟的绑定变量是客户端驱动程序接收一个带参数的SQL再将指定的值带入其中，最后将完整的查询发送到服务器端。</p><h2 id="7-7-用户自定义函数"><a href="#7-7-用户自定义函数" class="headerlink" title="7.7 用户自定义函数"></a>7.7 用户自定义函数</h2><p>User-define function，UDF是一种对MySQL扩展的途径，其用法与内置函数相同。</p><p>减少数据在数据库和应用服务器上的传输，提高数据处理的效率，在一些简单的操作上优势大。</p><p>MySQL版本升级时要特别注意UDF，有时需要重新编译UDF或者修改。</p><h2 id="7-8-插件"><a href="#7-8-插件" class="headerlink" title="7.8 插件"></a>7.8 插件</h2><p>MySQL支持各种各样的插件，使得无须修改源代码就可以大大扩展相关功能。</p><ul><li>存储过程插件</li><li>后台插件</li><li>全文解析插件</li><li>审计插件</li><li>认证插件</li></ul><h2 id="7-9-字符集和校对"><a href="#7-9-字符集和校对" class="headerlink" title="7.9 字符集和校对"></a>7.9 字符集和校对</h2><p>当服务器和客户端通信时，如果使用了不同的字符集，这时服务器端将进行必要的翻译转换工作。</p><p><img src="https://i.loli.net/2019/05/31/5cf0dae884d5b17964.png" alt="客户端和服务器的字符集.png" title="客户端和服务器的字符集.png"></p><p>MySQL在比较两个字符串大小时会将它们都转成同一个字符集再比较，MySQL 5.0之后支持这样的隐式转换。</p><h2 id="7-10-全文索引"><a href="#7-10-全文索引" class="headerlink" title="7.10 全文索引"></a>7.10 全文索引</h2><p>全文索引的使用场景是通过关键字的匹配来进行查询过滤，基于相似度的查询，而不是原来的精确的数值比较。是四大索引中的一种（普通索引、唯一索引、主键索引、全文索引）。</p><h3 id="7-10-1-自然语言的全文索引"><a href="#7-10-1-自然语言的全文索引" class="headerlink" title="7.10.1 自然语言的全文索引"></a>7.10.1 自然语言的全文索引</h3><p>自然语言上采用的是相关度来度量，基于匹配关键词的个数，以及关键词在文档中出现的次数，在整个索引中出现次数越少的词语，匹配时的相关度越高，例如一个词语在一大半的记录中都出现了，那么自然语言将不会搜索这类词语。</p><p>SQL中由MATCH()来完成，函数MATCH()将返回关键字匹配的相关度，在MATCH()中指定的列必须在和全问索引中指定的列完全相同。</p><h3 id="7-10-2-布尔全文索引"><a href="#7-10-2-布尔全文索引" class="headerlink" title="7.10.2 布尔全文索引"></a>7.10.2 布尔全文索引</h3><p>布尔搜索中可以指定查询中自定义某个词语的相关性，并且可以通过一些前缀修饰符定制搜索，此处不过多详细描述。</p><p>查询时会先把短语拆分成单个词语查询，然后取出这些记录进行精确的匹配短语，比LIKE操作快很多（在关键词不太常见的情况下）。</p><h3 id="7-10-3-全文索引的限制"><a href="#7-10-3-全文索引的限制" class="headerlink" title="7.10.3 全文索引的限制"></a>7.10.3 全文索引的限制</h3><p>关键字和文本的相关性判断只考虑了词频，词在字符串中的位置也就无法用在相关性的计算上。</p><p>内存如果不能装载全部全文索引会导致搜索的速度很慢。全文索引会有很多的碎片，需要做OPTIMIZE TABLE操作。</p><p>全文索引只能做全文搜索匹配，任何其他操作，比如WHERE条件比较都只能在完成全问搜索返回记录后进行。</p><p>全文索引不存储索引列的实际值，也就是没有索引覆盖扫描。</p><p>全文索引除了相关性排序外，如果还需要其他排序操作需要进行文件排序。</p><p>在使用全文索引时通常会产生大量随机I/O，再加上GROUP BY操作等会使用到临时表和文件排序，使用全文索引有时也会使得其他列的普通索引无法使用，在日常使用中多加注意。</p><h3 id="7-10-4-全文索引的配置和优化"><a href="#7-10-4-全文索引的配置和优化" class="headerlink" title="7.10.4 全文索引的配置和优化"></a>7.10.4 全文索引的配置和优化</h3><p>保证索引缓存足够大，是的全文索引都能够缓存在内存中。停用表需要经常更行，对一些高频词语及时更新进停用表中。忽略一些太短的词语，设置索引单词的最小长度。</p><h2 id="7-11-分布式（XA）事务"><a href="#7-11-分布式（XA）事务" class="headerlink" title="7.11 分布式（XA）事务"></a>7.11 分布式（XA）事务</h2><p>略</p><h2 id="7-12-查询缓存"><a href="#7-12-查询缓存" class="headerlink" title="7.12 查询缓存"></a>7.12 查询缓存</h2><p>MySQL有两类缓存，一是缓存查询计划，相同类型的SQL就可以跳过解析和执行计划生成阶段，二是查询结果的缓存，完整的SELECT查询结果将得到缓存。</p><p>很多时候还是推荐默认关闭查询缓存，后续将详细展开。</p><h3 id="7-12-1-MySQL如果判断缓存命中"><a href="#7-12-1-MySQL如果判断缓存命中" class="headerlink" title="7.12.1 MySQL如果判断缓存命中"></a>7.12.1 MySQL如果判断缓存命中</h3><p>缓存存放在一个引用表中，通过一个哈希值引用，所以任何的字符上的不同，空格、注释之类的，都会导致缓存不命中，因此使用缓存必须在SQL上保持统一的编码习惯。</p><p>查询语句包含不确定因素时不会被缓存，例如函数NOW()等，这类查询不会被缓存，除此之外还有用户自定义函数、存储函数、用户变量、临时表、MySQL中的系统表、任何包含列级别权限的表，都不会被缓存。</p><p>打开查询缓存后对数据库的读写操作都会带来额外的消耗，读开始之前就会检查是否命中缓存，读完若没有这个查询会将结果存入缓存，写操作必须将对应表的所有缓存都设置失效。</p><h3 id="7-12-2-查询缓存如果使用内存"><a href="#7-12-2-查询缓存如果使用内存" class="headerlink" title="7.12.2 查询缓存如果使用内存"></a>7.12.2 查询缓存如果使用内存</h3><p>查询结果完全存储在内存中。MySQL用于查询缓存的内存被分成一个个的数据块，大小时变长的，每个数据块存储了自己的类型、大小和存储的数据，外加一个指向前一个后一个数据块的指针。</p><h3 id="7-12-3-查询缓存发挥作用"><a href="#7-12-3-查询缓存发挥作用" class="headerlink" title="7.12.3 查询缓存发挥作用"></a>7.12.3 查询缓存发挥作用</h3><p>缓存是否对系统带来了更好的性能这个主要考察缓存带来的资源节约和其本身资源消耗的关系。</p><p>可参考的数据有缓存命中率，就是查询缓存返回结果占总查询的比例；INSERT/SELECT比例，查多改少较好。还有一个参考是“命中/写入”，当这个比例大于3:1时，最好10:1时，一般推荐以这个比例为准，到达这样的比例才能使得缓存的性能提升大于资源消耗。</p><h3 id="7-12-4-通用的查询缓存优化"><a href="#7-12-4-通用的查询缓存优化" class="headerlink" title="7.12.4 通用的查询缓存优化"></a>7.12.4 通用的查询缓存优化</h3><ul><li>多个小表代替一个大表</li><li>批量写入只需要做一次缓存失效</li><li>缓存空间过大会在过期操作时导致服务器僵死，可以对缓存空间大小稍作控制</li><li>写密集型应用应该禁用查询缓存</li><li>可以针对某些查询设置走查询缓存</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>BaronSchwartz, PeterZaitsev, VadimTkachenko, et al. 高性能MySQL[M]. 电子工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      MySQL从5.0和5.1开始引入了很多高级特性，分区、触发器等。除了分区之外大部分功能其实用到的场景都不是很多，从MySQL层面上使用这些高级特性说不定在后期的使用上会大大增加升级重构的成本，实际中这些高级特性的任务都在应用端层面完成了，这里这些高级特性能够做相关的了解。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》阅读笔记 第六章 查询性能优化</title>
    <link href="https://296245482.github.io/2019/05/25/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://296245482.github.io/2019/05/25/《高性能MySQL》阅读笔记-第六章-查询性能优化/</id>
    <published>2019-05-24T21:00:59.000Z</published>
    <updated>2019-05-24T21:00:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-慢查询原因"><a href="#6-1-慢查询原因" class="headerlink" title="6.1 慢查询原因"></a>6.1 慢查询原因</h2><p>查询任务由无数个子任务组成，需要优化或者消除其中的一些子任务，或者减少执行次数。这就需要我们了解查询的生命周期、清楚查询的时间消耗。这其中的时间消耗可能在网络、CPU计算、统计信息和执行计划的生成、锁等待，需要对查询进行剖析才能定位到优化点。</p><h2 id="6-2-慢查询基础：优化数据访问"><a href="#6-2-慢查询基础：优化数据访问" class="headerlink" title="6.2 慢查询基础：优化数据访问"></a>6.2 慢查询基础：优化数据访问</h2><p>分析低效查询从两个角度来看：①应用程序是否检索了大量的超过需要的数据量；②MySQL服务器是否分析了大量的超过需要的数据量。</p><h3 id="6-2-1-请求了不需要的数据"><a href="#6-2-1-请求了不需要的数据" class="headerlink" title="6.2.1 请求了不需要的数据"></a>6.2.1 请求了不需要的数据</h3><ul><li>尽量在查询后面加上limit限制；</li><li>多表关联查询时只返回特点的列；</li><li>减少使用SELECT *，让优化器能够实现索引覆盖扫描，减少修改带来的问题；</li><li>应用中多次查询同一个数据，可以改为初次查询时将数据缓存起来</li></ul><h3 id="6-2-2-MySQL扫描了额外的数据"><a href="#6-2-2-MySQL扫描了额外的数据" class="headerlink" title="6.2.2 MySQL扫描了额外的数据"></a>6.2.2 MySQL扫描了额外的数据</h3><ol><li>响应时间 = 服务时间 + 等待时间；</li><li>最理想的情况是扫描行数和返回行数相同。EXPLAIN语句中的type反映了访问类型，有全表扫描、扫描索引、范围访问、单值访问等；rows反映了预估访问行数。</li><li>MySQL应用WHERE的三种方式，从好到坏：①存储引擎层过滤不匹配的记录 ②使用索引覆盖扫描 ③在MySQL服务层先从数据表读出记录然后过滤</li></ol><h2 id="6-3-重构查询的方式"><a href="#6-3-重构查询的方式" class="headerlink" title="6.3 重构查询的方式"></a>6.3 重构查询的方式</h2><p>重构可以理解为转换一种写法，从应用角度完成修改。</p><ol><li>一个复杂的查询还是多个简单的查询？一个复杂的大查询，例如删除操作，一次性完成的话会一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的查询。</li><li>将复杂查询进行分解和切分可以带来很多好处：①单表缓存数据的使用 ②减少锁竞争 ③更容易对数据库进行拆分 ④使用IN ()代替原本的表关联更高效 ⑤关联查询会有冗余记录的查询</li></ol><h2 id="6-4-查询执行的基础"><a href="#6-4-查询执行的基础" class="headerlink" title="6.4 查询执行的基础"></a>6.4 查询执行的基础</h2><p><img src="https://i.loli.net/2019/05/06/5ccfebb488901.png"><br>MySQL执行一个查询的过程：</p><ol><li>客户端发送查询给服务器</li><li>服务器先查询缓存，命中则返回，未命中继续</li><li>解析SQL、预处理，送至查询优化器生成执行计划</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</li><li>结果返回客户端结果</li></ol><h3 id="6-4-1-客户端-服务器通信"><a href="#6-4-1-客户端-服务器通信" class="headerlink" title="6.4.1 客户端/服务器通信"></a>6.4.1 客户端/服务器通信</h3><p>通信是半双工的，双方都可以发送数据，但同一时刻只有一方可以发送。没法进行流量控制，因此会涉及到数据包很大必须全部传完才行的问题。</p><h3 id="6-4-2-查询缓存"><a href="#6-4-2-查询缓存" class="headerlink" title="6.4.2 查询缓存"></a>6.4.2 查询缓存</h3><p>查询缓存若打开会优先检查是否命中缓存中的数据，检查是通过一个大小写敏感的哈希查找实现。在缓存命中的情况下，查询的SQL语句都没有被解析，也不会生成执行计划，缓存中的结果直接返回给了客户端。</p><h3 id="6-4-3-查询优化处理"><a href="#6-4-3-查询优化处理" class="headerlink" title="6.4.3 查询优化处理"></a>6.4.3 查询优化处理</h3><p>这一步主要将SQL转换成一个执行计划，包含了几个子阶段：解析SQL、预处理、优化SQL的执行计划。</p><h4 id="6-4-3-1-语法解析器和预处理"><a href="#6-4-3-1-语法解析器和预处理" class="headerlink" title="6.4.3.1 语法解析器和预处理"></a>6.4.3.1 语法解析器和预处理</h4><p>通过关键字将SQL解析成一颗“解析树”，这一部主要检查解析树是否合法，例如表列是否存在等等。</p><h4 id="6-4-3-2-查询优化器"><a href="#6-4-3-2-查询优化器" class="headerlink" title="6.4.3.2 查询优化器"></a>6.4.3.2 查询优化器</h4><p>基于成本，预测多种执行计划的成本，并选择成本最小的那一个，计算依据有：表或索引的页面数、索引基数、索引和数据行的长度、索引分布情况；</p><p>优化策略又分为静态、动态优化，静态直接对解析树进行分析，只需要做一次，动态优化和上下文有关，每次执行时都需要评估。</p><p>MySQL能够处理的一些优化类型：重新定义关联表顺序；将外连接转化为内连接；等价条件变化，比较的合并和减少；MIN、MAX等可以依靠B-Tree索引特点快速获取，COUNT根据存储引擎单独存储的值直接获取；预估并参数化表达式；覆盖索引返回；条件得到满足就立即停止查询；关联查询的条件可以扩展到多个表上；IN条件进行二分查找优化。</p><h4 id="6-4-3-3-数据和索引的统计信息"><a href="#6-4-3-3-数据和索引的统计信息" class="headerlink" title="6.4.3.3 数据和索引的统计信息"></a>6.4.3.3 数据和索引的统计信息</h4><p>查询优化器在MySQL架构中的服务器层，但是服务器层没有保存数据和索引统计信息，存储引擎会提供给优化器表或索引的页面数、索引基数、数据行、索引长度和索引分布等等。</p><h4 id="6-4-3-4-MySQL如何关联查询"><a href="#6-4-3-4-MySQL如何关联查询" class="headerlink" title="6.4.3.4 MySQL如何关联查询"></a>6.4.3.4 MySQL如何关联查询</h4><p>关联查询不一定要两个表，每个查询都是一次关联，读取结果临时表也是一次关联。MySQL对任何关联都执行嵌套循环关联操作，也就是先从一个表中取出单条数据，嵌套到下一个表中寻找匹配的，直到找出所有的行，然后返回查询中需要的各个列，整体上都是一个”嵌套循环关联“。</p><p>可以通过如下很好的了解：</p><p><img src="https://i.loli.net/2019/05/13/5cd93e4dea4b168903.png" alt="多表关联的一种方式.png" title="多表关联的一种方式.png"></p><p>例如如上查询，MySQL实际执行时总是从一个表开始一直嵌套循环、回溯所有关联：</p><p><img src="https://i.loli.net/2019/05/13/5cd93e4dd8da082671.png" alt="MySQL如何多表关联.png" title="MySQL如何多表关联.png"></p><p>实际表之间的关联顺序也可以被MySQL优化，表的关联顺序不一定按照自己定的顺序决定，MySQL会根据索引、扫描的行数选出最合适的顺序来进行更少的嵌套循环和回溯操作。</p><h3 id="6-4-4-查询执行引擎"><a href="#6-4-4-查询执行引擎" class="headerlink" title="6.4.4 查询执行引擎"></a>6.4.4 查询执行引擎</h3><p>MySQL的查询计划是一个数据结构，不是其他关系型数据库那样的字节码。</p><h3 id="6-4-5-返回结果给客户端"><a href="#6-4-5-返回结果给客户端" class="headerlink" title="6.4.5 返回结果给客户端"></a>6.4.5 返回结果给客户端</h3><p>如果查询可以被缓存那么MySQL这个阶段也会将结果放到查询缓存中，返回过程是一个增量、逐步的过程，</p><h2 id="6-5-查询优化的局限性"><a href="#6-5-查询优化的局限性" class="headerlink" title="6.5 查询优化的局限性"></a>6.5 查询优化的局限性</h2><ul><li>关联子查询</li></ul><p>对于Exists和In中的子查询采用如下策略：</p><p>Exists执行顺序如下：①首先执行一次外部查询 ②对于外部查询中的每一行分别执行一次子查询，而且每次执行子查询时都会引用外部查询中当前行的值。 ③使用子查询的结果来确定外部查询的结果集。</p><p>IN的执行过程如下： ①首先运行子查询，获取子结果集 ②主查询再去结果集里去找符合要求的字段列表，符合要求的输出,反之则不输出。</p><p>一般情况下，自己在选择的时候子查询表相对较大时选择exist，相对小时选择in。但这肯定不是绝对的，在实际中要测试验证执行计划和相应时间的假设。</p><ul><li>UNION的限制</li></ul><p>MySQL无法将限制条件从“外层”推到“内层”，例如两表UNION操作，外层有一个limit操作，实际运行两表读取的行数不受limit影响，再两表组合成一个巨大的临时表后才会进行limit操作。</p><p>需要在UNION的两个子查询分别加上limit来解决。</p><ul><li>索引合并优化</li></ul><p>合并索引的特性在于查询一个表时，AND和OR条件两边对应的是两个不同的索引，MySQL会分别利用两个索引查出结果，然后相应的做交集并集操作。</p><p>当两个索引的值选择性较高时，各自返回的数据较少，交集并集的操作成本也低，但是如果选择性不高，各自数据量大，合并索引也会带来效率的负增长。实际工作上，多数会选择关闭合并索引功能，在实际需要使用时改写SQL，将需要合并索引的地方写为UNION操作。</p><ul><li>等值传递</li></ul><p>如果有一个非常大的IN()列表，当优化器发现存在WHERE、ON或者USING子句时，会将这个列表的值和另一个表的某个列相关联，会将IN()列表都复制应用到关联的各个表中，列表很大时会导致优化和执行都变慢。（问题出现很少见）</p><ul><li>并行执行</li></ul><p>MySQL无法利用多核并行执行查询</p><ul><li>哈希关联</li></ul><p>MySQL不支持哈希关联，MySQL所有的关联都是嵌套循环关联。</p><ul><li>松散索引</li></ul><p>MySQL不支持松散索引扫描，无法按照不连续的方式扫描一个索引。简单来说也就是不支持跳过组合索引的前部分，必须使用全表扫描来获取数据。</p><ul><li>最大值和最小值化</li></ul><p>例如在查询一个主键的最小值时，在全表扫描的情况下，理论上读到的第一个满足条件的数据就是主键的最小值，因为主键是严格按照大小顺序排列，但是MySQL这时只会做全表扫描。</p><ul><li>在同一个表上查询和更新</li></ul><p>MySQL不允许同一张表同时做查询和更新，但有一种情况可以解决这样的问题，将此表作为一个临时表，在查询之后和需要更新的表做关联操作，使得更新到表只是一个临时表。</p><h2 id="6-6-查询优化器的提示"><a href="#6-6-查询优化器的提示" class="headerlink" title="6.6 查询优化器的提示"></a>6.6 查询优化器的提示</h2><p>这部分介绍了若干的执行计划调整方法，如果对优化器给出的执行计划不满意的话可以在SQL语句上加上一些提示语句，通过提示提供给优化器一些特殊情况下选择某种查询计划的指导，规划一个比优化器自己选择的更好的执行计划。</p><h2 id="6-7-优化特定类型的查询"><a href="#6-7-优化特定类型的查询" class="headerlink" title="6.7 优化特定类型的查询"></a>6.7 优化特定类型的查询</h2><h3 id="6-7-1-优化COUNT"><a href="#6-7-1-优化COUNT" class="headerlink" title="6.7.1 优化COUNT()"></a>6.7.1 优化COUNT()</h3><p>统计行数时COUNT(*)的性能会优于括号内指定了一个列。</p><p>COUNT在统计列值时要求列值不能为null。</p><p>偶尔也可以考虑使用近似值，例如统计COUNT值时采用EXPLAIN的优化器扫描值，或者去掉一些DISTINCT之列的约束来大大减少运行时间，得到几乎相同的运行结果。</p><p>更好的优化点还有选择索引覆盖扫描，新增加一个汇总表，增加一个外部缓存等等。</p><h3 id="6-7-2-优化关联查询"><a href="#6-7-2-优化关联查询" class="headerlink" title="6.7.2 优化关联查询"></a>6.7.2 优化关联查询</h3><p>表A，B关联时，如果优化器的关联顺序是B、A，那么在ON或者USING上的列就只需要在A表上创建索引。</p><p>GROUP BY和ORDER BY尽可能只使用一个列，这样才有可能使用索引优化。</p><p>注意关联类型。</p><p>对于存在子查询的情况是，记得同时考察下转化为使用关联查询替代，说不定会有更好的效率。</p><h3 id="6-7-3-优化GROUP-BY和DISTINCT"><a href="#6-7-3-优化GROUP-BY和DISTINCT" class="headerlink" title="6.7.3 优化GROUP BY和DISTINCT"></a>6.7.3 优化GROUP BY和DISTINCT</h3><p>当GROUP BY无法使用索引时会使用临时表或者文件排序来完成分组。</p><p>如果GROUP BY后没有通过ORDER BY显示指定排序列，默认排序会使用文件排序自动按照分组的字段进行排序，如果不需要排序可以使用ORDER BY NULL不使用文件排序。</p><h3 id="6-7-4-LIMIT分页优化"><a href="#6-7-4-LIMIT分页优化" class="headerlink" title="6.7.4 LIMIT分页优化"></a>6.7.4 LIMIT分页优化</h3><p>如果在进行分页查询时，如果偏移量非常大（翻页翻到非常后面的页），代价会非常大。较简单的方法就是尽可能使用索引覆盖扫描，然后做一次关联操作，这样就避免了前面在翻页时查询所有的列，也叫做“延迟关联”，先定位到要访问的记录然后关联列会原表查询所有的列。</p><h3 id="6-7-5-优化UNION操作"><a href="#6-7-5-优化UNION操作" class="headerlink" title="6.7.5 优化UNION操作"></a>6.7.5 优化UNION操作</h3><p>UNION操作都是创建并填充临时表的方式来操作，如果不是确定要取出重复的行话可以使用UNION ALL代替，因为没有ALL的话MySQL会给临时表加上DISTINCT操作，代价会非常高。</p><h3 id="6-7-6-语句中的自定义变量"><a href="#6-7-6-语句中的自定义变量" class="headerlink" title="6.7.6 语句中的自定义变量"></a>6.7.6 语句中的自定义变量</h3><p>有这些场景不能使用自定义变量：</p><ul><li>使用了自定义变量不能查询缓存</li><li>不能在常量或者标示符的地方使用自定义变量（表、列名，LIMIT子句中）</li><li>自定义变量的生命周期是一个数据库连接中</li><li>自定义变量在MySQL 5.0之前对大小写敏感</li></ul><p>如果用MySQL构建队列表，历史已完成消息归档、和未处理的消息分表。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好好理解解析优化过程的知识，可以帮助更好的理解表和索引的内容。优化的三点建议：不做、少做、快速的做。例如，不做-查缓存，少做-减少扫描等等这些。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>BaronSchwartz, PeterZaitsev, VadimTkachenko, et al. 高性能MySQL[M]. 电子工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      第五章主要介绍了怎么设计良好的库表结构、如何建立良好的索引，这些只是高性能的前提，完整的高效还需要优秀的查询。本章主要将会介绍MySQL优化器的内部机制，如何执行查询，介绍查询的执行计划，同时也讨论了MySQL优化器的不足。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》阅读笔记 第五章 创建高性能索引</title>
    <link href="https://296245482.github.io/2019/04/30/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/"/>
    <id>https://296245482.github.io/2019/04/30/《高性能MySQL》阅读笔记-第五章-创建高性能索引/</id>
    <published>2019-04-30T15:50:17.000Z</published>
    <updated>2019-04-30T15:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-1-索引基础"><a href="#5-1-索引基础" class="headerlink" title="5.1 索引基础"></a>5.1 索引基础</h2><p>索引类型：B-Tree，哈希索引，空间数据索引，全文索引….</p><ol><li><p>同样是使用B-Tree索引，MyISAM使用前缀压缩技术使得索引更小，但InnoDB按原数据进行存储。MyISAM索引通过数据的物理位置引用被索引的行，InnoDB根据主键引用被索引的行。</p></li><li><p>对于多个索引，必须严格按从左到右顺序使用，缺一不可，并且， 如果中间某个列使用的是范围查询，其索引右边的列都无法使用到索引。</p></li><li><p>哈希索引主要基于哈希表的实现，只有精确匹配索引所有列的查询才有效。</p></li><li><p>哈希索引数据不是按照索引值顺序存储的，无法用于排序。</p></li><li><p>哈希索引不支持部分索引列匹配查找，哈希索引始终是使用索引列的全部内容来计算哈希值，例如（A,B）上的索引，如果查询条件只有A则无法使用索引。</p></li><li><p>哈希索引同样也只支持等值比较，范围查找无法使用哈希索引。</p></li></ol><h2 id="5-2-索引的优点"><a href="#5-2-索引的优点" class="headerlink" title="5.2 索引的优点"></a>5.2 索引的优点</h2><p>略</p><h2 id="5-3-高性能索引策略（重点阅读）"><a href="#5-3-高性能索引策略（重点阅读）" class="headerlink" title="5.3 高性能索引策略（重点阅读）"></a>5.3 高性能索引策略（重点阅读）</h2><h3 id="5-3-1-独立的列："><a href="#5-3-1-独立的列：" class="headerlink" title="5.3.1 独立的列："></a>5.3.1 独立的列：</h3><p>查询中索引不能是表达式的一部分，不能是函数的参数，应该始终将索引单独放在比较符号一侧。</p><h3 id="5-3-2-前缀索引："><a href="#5-3-2-前缀索引：" class="headerlink" title="5.3.2 前缀索引："></a>5.3.2 前缀索引：</h3><p>索引的选择性 = 不重复的值（distinct后的值） / 数据表的总记录数，在选择前缀索引时这个比值越大说明性能越接近全字段索引，效果最优。</p><p>在处理BLOB、TEXT或者VARCHAR类型的列时，如果他们本身的长度很长，MySQL是不允许索引这些列的完整长度的，这里必须使用前缀索引，所以我们只选取这些值的前缀建立索引，具体选择多长的长度需要考察这个前缀的选择性，让其尽量接近完整列的选择性。</p><p>前缀索引可以使索引更小、更快，但是使用前缀索引后就不能对该列做ORDER BY和GROUP BY了。</p><p>不同的情况下也可以考虑后缀索引，依靠MySQL内的字符串转向实现。</p><p>总结来说使用前缀索引的情况有： ①字符串的列 ②字符串本身就比较长，并且字符串开始的几个字符差异比较大，能够进行很好的区分 ③只是前一半的字符的选择性就已经接近了全字段索引的选择性了。</p><h3 id="5-3-3-多列索引"><a href="#5-3-3-多列索引" class="headerlink" title="5.3.3 多列索引"></a>5.3.3 多列索引</h3><p>在多个列上分别建立索引，然后一起使用实际都可能会是全盘扫描。例如：SELECT xxx FROM xxx WHERE a = 1 OR b = 1; 但在新版本的MySQL中会自动处理好这两个单列索引，OR条件转化为union、AND查询转化为intersection的两表查询(这种合并的优化策略并不可取，只是说明索引建的很糟糕，MySQL会稍作修正)。</p><p>查询之前explain看看是否有索引合并，看看自己的索引是否建的足够好。</p><h3 id="5-3-4-索引的组合顺序"><a href="#5-3-4-索引的组合顺序" class="headerlink" title="5.3.4 索引的组合顺序"></a>5.3.4 索引的组合顺序</h3><p>对于一个单个查询，查询条件是A=1和B=2，创建索引应该是(A,B)还是(B,A)呢？单单对这条SQL，可以考察WHERE条件中列的选择性，选择性越高、数据基数越少越靠前。</p><p>这里定的顺序只是针对这单条SQL，并且是特定的查询值，这样对其他查询不公平，可能会使得某些查询不如预期，甚至影响服务器的整体性能。</p><p>具体在实际中如何选择顺序我们主要依靠经验，往往选择性更高的列放在前面，如果对于WHERE子句中的数据固定就考察数据基数，当然这些方法也不是一概而论，都需要具体分析。</p><h3 id="5-3-5-聚簇索引"><a href="#5-3-5-聚簇索引" class="headerlink" title="5.3.5 聚簇索引"></a>5.3.5 聚簇索引</h3><p>这里谈论InnoDB中的聚簇索引，简单理解就是数据行实际上存在索引的叶子页上，所以一个表只能有一个聚簇索引,也可以理解为聚簇索引就是“表”。InnoDB通过主键建立聚簇索引，没有定义主键则选择一个唯一的为空索引替代，如果没有唯一非空索引就会隐式定义一个主键。InnoDB的每一个叶子页占的空间是指定的。</p><p>聚簇索引优点：①数据查询时只需要一次的磁盘I/O。 ②索引和数据保存在一起，因此获取数据的速度会更快。 ③如果使用覆盖索引，就可以直接在取到的页中值，不需要再次回表查询。</p><p>缺点：①聚簇索引的分页设计，对于I/O密集的有性能提升，但是数据存在内存中就没有优势了。 ②数据插入如果不是按照主键顺序插入会慢。 ③更新聚簇索引的代价大。 ④插入一条数据到一个满页时，会导致页分裂，占用更多空间。 ⑤页分裂多了数据不连续带来查询慢的问题。 ⑥非聚簇索引访问需要两次索引查找，因为这类索引叶子中保存的不是指向物理地址的指针，而是行的主键值。</p><p>和MyISAM引擎的区别主要在于：MyISAM的索引和普通索引没有太大区别，叶子节点上就是索引值；InnoDB的叶子节点包含主键值、事务ID、事务和MVCC的回滚指针、以及剩余的列，相当于包含了表，还有一点不同上面也提到过，InnoDB中非聚簇索引叶子指向的是主键值，不是一般索引的“行指针”（设计目的是减少行移动、数据页分裂的维护工作）。</p><p>从下面这张图很容易可以看出区别：</p><div align="center"><img src="https://i.loli.net/2019/04/29/5cc69b670e276.png"></div><p>最好避免随机的聚簇索引，特别是I/O密集的应用，最好是索引数据和应用无关，最简单的方式是使用AUTO_INCREMENT的列。实际中也推荐按照主键顺序插入数据，并且尽可能的使用单条增加的聚簇值来插入新行。</p><p>如下两个图：</p><div align="center"><img src="https://i.loli.net/2019/04/29/5cc69f835877e.png"></div><br><div align="center"><img src="https://i.loli.net/2019/04/29/5cc69f98422c3.png"></div><p>索引值是否是顺序的决定了聚簇索引插入的效率，顺序的话就直接插入到后面，达到页大小时就往后放；非顺序的情况的话就会出现新行随机插入已有的位置之间，这会导致频繁的页分裂，页也会变得稀疏不规则，如果插入过程中目标页已刷到磁盘不在缓存中的话就还需要从磁盘读取到内存中，会有大量的随机I/O。</p><h3 id="5-3-6-覆盖索引"><a href="#5-3-6-覆盖索引" class="headerlink" title="5.3.6 覆盖索引"></a>5.3.6 覆盖索引</h3><p>简单来说就是突破单纯考虑WHERE条件来创建索引，考虑到整个查询，<strong>让MySQL可以使用索引就直接获取到数据</strong>。如果一个索引包含（覆盖）所有需要查询的字段，就可以称为覆盖索引。查询只需要扫描索引不需要回表。</p><p>优势：①I/O数据量减少，数据更容易放入内存 ②聚簇索引是按值顺序存储的，范围查询会有更少的I/O ③如MyISAM引擎，内存只缓存索引，数据要依赖操作系统来缓存，一次数据访问就需要一次系统调用 ④对于聚簇索引如InnoDB中，通过非聚簇索引查询时得到主键，进一步要对主键索引进行查询，如果将二级主键做到覆盖查询，可以减少查询次数。</p><h3 id="5-3-7-使用索引扫描来排序"><a href="#5-3-7-使用索引扫描来排序" class="headerlink" title="5.3.7 使用索引扫描来排序"></a>5.3.7 使用索引扫描来排序</h3><p>EXPLAIN语句中type为index才使用索引，不要被Extra中的“Using index”搞混淆了。</p><p>MySQL有两种方式生成有序的结果，通过排序操作，或者按索引顺序扫描。只有当索引的顺序和ORDER BY子句的顺序完全一致时，MySQL才能够使用索引来对结果排序。</p><h3 id="5-3-8-压缩（前缀压缩）索引"><a href="#5-3-8-压缩（前缀压缩）索引" class="headerlink" title="5.3.8 压缩（前缀压缩）索引"></a>5.3.8 压缩（前缀压缩）索引</h3><p>稍作了解，MyISAM压缩索引的机制是，先保存索引块的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分。</p><p>压缩块使用更少的空间，但是每个索引都依赖于前面的值，所以MyISAM查找时只能从头开始扫描，这也是一个CPU内存资源和磁盘之间的一个资源权衡。</p><h3 id="5-3-9-冗余和重复索引"><a href="#5-3-9-冗余和重复索引" class="headerlink" title="5.3.9 冗余和重复索引"></a>5.3.9 冗余和重复索引</h3><p>MySQL允许创建冗余或者重复索引，但是这是很不推荐的，因为优化器都会单独进行处理，严重影响性能，因此在表创建时要避免这种情况。</p><p>例如已有索引(A,B)再创建(A)就是冗余索引，只要索引效果不同，或者是相同覆盖、不同类型也不算是冗余索引。</p><p>有种特殊情况也需要冗余索引，比如已有索引已经很大了，扩展会影响其他的使用该索引的查询性能。</p><h3 id="5-3-10-未使用的索引"><a href="#5-3-10-未使用的索引" class="headerlink" title="5.3.10 未使用的索引"></a>5.3.10 未使用的索引</h3><p>服务器有一些永远都用不到的索引，一些常见的服务器工具可以帮我们定位，例如Percona Server或者MariaDB中的userstates变量的开启，可以查询每个索引的使用频率，Percona Toolkit中的pt-index-usage了解每天查询的报告。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>大多数情况还是使用B-Tree索引，其他索引都还是要依据特殊情况来考察。</p></li><li><p>总体来看，查询时尽可能选择合适的索引避免单行查询，尽量使用数据的原始顺序避免排序，尽可能使用索引覆盖查询消除回表查询。</p></li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>BaronSchwartz, PeterZaitsev, VadimTkachenko, et al. 高性能MySQL[M]. 电子工业出版社, 2013.</p>]]></content>
    
    <summary type="html">
    
      这个笔记主要是写一些自己原来理解不足、可能在以后可能会遇到的一些点，做下记录，日后自己也能回顾重温。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL单SQL查询剖析</title>
    <link href="https://296245482.github.io/2019/03/28/MySQL%E5%8D%95%E6%9D%A1SQL%E6%80%A7%E8%83%BD%E6%9F%A5%E8%AF%A2/"/>
    <id>https://296245482.github.io/2019/03/28/MySQL单条SQL性能查询/</id>
    <published>2019-03-28T08:32:36.000Z</published>
    <updated>2019-03-28T08:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL单SQL查询剖析"><a href="#MySQL单SQL查询剖析" class="headerlink" title="MySQL单SQL查询剖析"></a>MySQL单SQL查询剖析</h1><h2 id="SHOW-PROFILE"><a href="#SHOW-PROFILE" class="headerlink" title="SHOW PROFILE"></a>SHOW PROFILE</h2><p>SHOW PROFILE命令是在MySQL 5.1之后引入的，相对于通常来说我们使用的EXPLAIN、slow query log指令来说，SHOW PROFILE可以给出SQL语句执行中各个资源的消耗情况，比如CPU、IO等，如果打开会对服务器上执行的所有语句在他们执行的过程中记录服务器的具体工作时间。这个内部工具默认是关闭的，如下指令查询打开状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| @@profiling |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|           0 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>需要如下指令打开：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET profiling = 1;</span><br></pre></td></tr></table></figure><p>开启之后这个工具会将所有的运行信息记录到一张临时表，并且给接下里的查询赋予一个编号，记录的信息包括运行的具体语句，每个语句在各个部分消耗的时间信息。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW PROFILES;</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line">| Query_ID | Duration   | Query                                             |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line">|        1 | 0.02267950 | <span class="keyword">show</span> <span class="keyword">tables</span>                                       |</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.00135350</span> | <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> studentId = <span class="number">1</span> <span class="keyword">limit</span> <span class="number">1</span> |</span><br><span class="line">|        <span class="number">3</span> | <span class="number">0.00134375</span> | <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> studentId = <span class="number">2</span> <span class="keyword">limit</span> <span class="number">1</span> |</span><br><span class="line">|        <span class="number">4</span> | <span class="number">0.00008225</span> | <span class="keyword">show</span> profils                                      |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到，这个工具给每个运行过的查询语句都给了一个编号，并且可以看到精度很高的响应时间，可这样的时间对于分析一个查询的效率来说还是不够的，进一步的话我们有SHOW PROFILE指令，可以进一步确认更加细节的时间消耗：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 3;</span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line">| Status               | Duration |</span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line">| starting             | 0.000092 |</span><br><span class="line">| checking permissions | 0.000008 |</span><br><span class="line">| Opening tables       | 0.000021 |</span><br><span class="line">| init                 | 0.000039 |</span><br><span class="line">| System <span class="keyword">lock</span>          | <span class="number">0.000010</span> |</span><br><span class="line">| optimizing           | <span class="number">0.000011</span> |</span><br><span class="line">| <span class="keyword">statistics</span>           | <span class="number">0.114235</span> |</span><br><span class="line">| preparing            | <span class="number">0.000033</span> |</span><br><span class="line">| executing            | <span class="number">0.000004</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>         | <span class="number">0.019880</span> |</span><br><span class="line">| <span class="keyword">end</span>                  | <span class="number">0.000014</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>            | <span class="number">0.000016</span> |</span><br><span class="line">| closing <span class="keyword">tables</span>       | <span class="number">0.000015</span> |</span><br><span class="line">| freeing items        | <span class="number">0.000036</span> |</span><br><span class="line">| cleaning up          | <span class="number">0.000031</span> |</span><br><span class="line">+<span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>这里仅仅只是运行时间的展示，要获取更加细节的信息展示可以在SHOW PROFILE指令中加入更多的细节部分：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io,memory,swaps for query 3;</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+-------+</span></span><br><span class="line">| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out | Swaps |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+-------+</span></span><br><span class="line">| starting             | 0.000092 | 0.000000 |   0.000000 |            0 |             0 |     0 |</span><br><span class="line">| checking permissions | 0.000008 | 0.000000 |   0.000000 |            0 |             0 |     0 |</span><br><span class="line">| Opening tables       | 0.000021 | 0.000000 |   0.000000 |            0 |             0 |     0 |</span><br><span class="line">| init                 | 0.000039 | 0.000000 |   0.000000 |            0 |             0 |     0 |</span><br><span class="line">| System <span class="keyword">lock</span>          | <span class="number">0.000010</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| optimizing           | <span class="number">0.000011</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| <span class="keyword">statistics</span>           | <span class="number">0.114235</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |          <span class="number">856</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| preparing            | <span class="number">0.000033</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| executing            | <span class="number">0.000004</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>         | <span class="number">0.019880</span> | <span class="number">0.004000</span> |   <span class="number">0.000000</span> |         <span class="number">1248</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| <span class="keyword">end</span>                  | <span class="number">0.000014</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>            | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| closing <span class="keyword">tables</span>       | <span class="number">0.000015</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| freeing items        | <span class="number">0.000036</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">| cleaning up          | <span class="number">0.000031</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |            <span class="number">0</span> |             <span class="number">0</span> |     <span class="number">0</span> |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+-------+</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>这里仅仅只是我的一个示例，详细展示了这条SQL在哪部分花费时间比较多，让我们可以有针对的去优化我们的数据库或者SQL。</p><p>但SHOW PROFILE只告诉了我们哪些活动花费了最多的时间，但并没有告诉我们为什么导致这样，至于怎么优化就要继续进一步研究这个子任务。</p><h2 id="SHOW-STATUS"><a href="#SHOW-STATUS" class="headerlink" title="SHOW STATUS"></a>SHOW STATUS</h2><p>SHOW STATUS命令的作用是计数器，可以从服务器级别看到MySQL从启动开始计算的各类操作的运行次数。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS;</span><br></pre></td></tr></table></figure><p>这么听起来SHOW STATUS并不是一个SQL运行的剖析工具，他无法给出一个操作的具体消耗时间，他的作用在于运行完某条SQL之后，可以观察各个计数器的数量变化，也就是说在运行完一条指令后，可以知道它各类活动的频繁程度，例如读索引、创建临时表等，缺点也就在于无法给出每个的时间消耗。</p><p>重置大多数状态变量到0：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; FLUSH STATUS;</span><br></pre></td></tr></table></figure><p>EXPLAIN指令也可以获取很多类似的信息，但是EXPLAIN只是一个估计的结果，SHOW STATUS是实际结果的统计。</p><p>进一步的用法中，SHOW STATUS还可以对结果进行模糊搜索，例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE 'qcache%';</span><br></pre></td></tr></table></figure><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>慢查询日志是比较常见的剖析单条SQL效率的方法，开启之后在数据库运行过程中，会根据相关的慢查询设置将查询较慢的SQL语句进行记录。</p><p>可以通过查看MySQL变量的方法，查看慢查询的打开关闭情况：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLE LIKE '%slow_query_log&amp;';</span><br></pre></td></tr></table></figure><p>其中slow_query_log表示的慢查询的开关状态，slow_query_log_file表示慢查询日志的记录位置。</p><p>开启慢查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>日志中记录的慢查询是时间低于某个配置的时间来的，配置的时间也是个MySQL的变量值：long_query_time，查看和设置这个配置值。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%long_query_time%'</span><br><span class="line"></span><br><span class="line">mysql&gt; set global long_query_time = 4;</span><br></pre></td></tr></table></figure><h2 id="Performance-Schema"><a href="#Performance-Schema" class="headerlink" title="Performance Schema"></a>Performance Schema</h2><p>Performance Schema是一个功能强大、较为底层的性能监控工具，可以自定义信息收集粒度，对于查找MySQL的性能瓶颈，查找long-SQL原因都有相关帮助。</p><p>这个功能是MySQL自带的，5.6.6版本中默认打开，可以使用如下指令查看打开情况。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'performance_schema'</span><br></pre></td></tr></table></figure><p>关于精细化控制主要通过performance_schema库下的各个setup表来进行配置，具体不在此描述。</p><p>日常可能使用的比较多的功能可能有：</p><ul><li>获取执行最多的SQL语句</li><li>单条执行时间最常的SQL语句</li><li>操作最频繁的表</li><li>从未被使用过的索引</li><li>文件IO消耗</li></ul><p>performance schema的统计数据非常强大，具体在此不展开描述，如有想法进一步了解可以Google相关的文章进一步了解。</p><p>ref:</p><ol><li><a href="http://keithlan.github.io/2015/07/17/22_performance_schema/" target="_blank" rel="noopener">http://keithlan.github.io/2015/07/17/22_performance_schema/</a></li><li><a href="https://cloud.tencent.com/developer/article/1072598" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1072598</a></li><li><a href="https://allenhu0320.iteye.com/blog/2186156" target="_blank" rel="noopener">https://allenhu0320.iteye.com/blog/2186156</a></li></ol>]]></content>
    
    <summary type="html">
    
      在定位了具体需要优化的单条SQL之后，我们可以有针对的对这条查询详细探究，获悉这条SQL为什么慢，这里主要介绍MySQL自带的相关方法，帮助我们很方便的测量各个部分花费的时间，这里简要介绍几个获取方法SHOW STATUS、SHOW PROFILE、慢查询日志、Performance Schema，具体的如何优化优化方法将在其他文章中阐述。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java实现LRU算法</title>
    <link href="https://296245482.github.io/2018/09/24/Java%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95/"/>
    <id>https://296245482.github.io/2018/09/24/Java实现LRU算法/</id>
    <published>2018-09-24T08:09:29.000Z</published>
    <updated>2018-09-24T08:09:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java里自带LinkedHashMap实现"><a href="#Java里自带LinkedHashMap实现" class="headerlink" title="Java里自带LinkedHashMap实现"></a>Java里自带LinkedHashMap实现</h2><p>Java里的LinkedHashMap就是以一个双向链表来实现的，可以制定按查询排序或者是插入排序，使用时继承改集合，初始化时指定好一些参数、重写删除最老元素的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Java自带的LinkedHashMap实现LRU缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseLinkedHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserLinkedHashMap&lt;Integer, String&gt; LRUCache = <span class="keyword">new</span> UserLinkedHashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        LRUCache.put(<span class="number">1</span>, <span class="string">"One"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">4</span>, <span class="string">"four"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        LRUCache.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = LRUCache.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; item = it.next();</span><br><span class="line">            System.out.println(<span class="string">"key: "</span> + item.getKey() + <span class="string">" / value: "</span> + item.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserLinkedHashMap</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.removeEldestEntry(eldest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><p>数组实现比较简单，元素用数组存储，有涉及到顺序修改时，将数组整体移位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组实现的LRU算法，刚使用的放在数组最后，主要考察元素是否已经存在和缓存是否已满这两种情况，使用与否只考察了set，没考察get</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayLRU</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已有元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用数组存储元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] listArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayLRU</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        listArray = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="keyword">this</span>.maxSize = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listArray[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveArrayElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步查看是否已存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> existLocation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item == listArray[i]) &#123;</span><br><span class="line">                exist = <span class="keyword">true</span>;</span><br><span class="line">                existLocation = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分情况查看是否已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; maxSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existLocation &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                    moveArrayElement(listArray, existLocation, size - <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                listArray[size - <span class="number">1</span>] = item;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listArray[size] = item;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!exist || item == listArray[<span class="number">0</span>]) &#123;</span><br><span class="line">                moveArrayElement(listArray, <span class="number">0</span>, maxSize - <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item != listArray[maxSize - <span class="number">1</span>]) &#123;</span><br><span class="line">                moveArrayElement(listArray, existLocation, maxSize - <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            listArray[maxSize - <span class="number">1</span>] = item;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cacheSize = <span class="number">5</span>;</span><br><span class="line">        MyArrayLRU lru = <span class="keyword">new</span> MyArrayLRU(cacheSize);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lru.insert(<span class="number">1</span>);</span><br><span class="line">            lru.insert(<span class="number">2</span>);</span><br><span class="line">            lru.insert(<span class="number">3</span>);</span><br><span class="line">            lru.insert(<span class="number">4</span>);</span><br><span class="line">            lru.insert(<span class="number">5</span>);</span><br><span class="line">            lru.insert(<span class="number">2</span>);</span><br><span class="line">            lru.insert(<span class="number">3</span>);</span><br><span class="line">            lru.insert(<span class="number">5</span>);</span><br><span class="line">            lru.insert(<span class="number">4</span>);</span><br><span class="line">            lru.insert(<span class="number">4</span>);</span><br><span class="line">            lru.insert(<span class="number">5</span>);</span><br><span class="line">            lru.insert(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cacheSize; i++) &#123;</span><br><span class="line">                System.out.println(lru.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"成功插入"</span> + count + <span class="string">"次元素."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><p>上述的数组实现在需要改变顺序的时候需要数组整体复制移位，资源消耗较大，链表在元素的增删上效率较高，对于存储的key-value节点的链表，链表的外部还套了一层key与节点一一对应，这个key可以用来判断元素是否已经存在，用于获取节点，获取链表大小等操作，弥补了链表一定功能的缺失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的实现思路，Node形成的链表外部再加一层，用于弥补链表的随机查找，链表头部为最近使用的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedLRU</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录头尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外层套一层HashMap，内部使用以Node为节点的链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; keyNodeMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedLRU</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        head = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        <span class="keyword">this</span>.keyNodeMap = <span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node node = keyNodeMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">            node = keyNodeMap.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            <span class="keyword">if</span> (keyNodeMap.size() == maxSize) &#123;</span><br><span class="line">                keyNodeMap.remove(removeTail());</span><br><span class="line">            &#125;</span><br><span class="line">            keyNodeMap.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将该节点移动到头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.pre != <span class="keyword">null</span> || node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到尾部节点（最没被使用）的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastKey = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tail.pre != head) &#123;</span><br><span class="line">            Node lastNode = tail.pre;</span><br><span class="line">            lastKey = lastNode.key;</span><br><span class="line">            lastNode.pre.next = tail;</span><br><span class="line">            tail.pre = lastNode.pre;</span><br><span class="line">            lastNode = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写toString()，按链表顺序打印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        Node item = head;</span><br><span class="line">        <span class="keyword">while</span> (item != tail.pre) &#123;</span><br><span class="line">            res += <span class="string">"["</span> + item.next.key + <span class="string">", "</span> + item.next.value + <span class="string">"] "</span>;</span><br><span class="line">            item = item.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLinkedLRU lru = <span class="keyword">new</span> MyLinkedLRU(<span class="number">5</span>);</span><br><span class="line">        lru.set(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lru.set(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        lru.set(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        lru.set(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        lru.set(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        lru.set(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">        lru.set(<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">        lru.set(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lru.set(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        lru.set(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        lru.set(<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">        lru.get(<span class="number">5</span>);</span><br><span class="line">        System.out.println(lru.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node pre;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        key = k;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有任何疑问欢迎随时讨论，关于LRU的算法实现思路肯定不止这么几种，应该还会有效率更高的思路</strong></p>]]></content>
    
    <summary type="html">
    
      操作系统里的LRU算法，Least Recently Used大家都很熟悉，在操作系统里学习过，Java里的LinkedHashMap已经就是LRU的典型应用.
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="Java" scheme="https://296245482.github.io/tags/Java/"/>
    
      <category term="OS" scheme="https://296245482.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>数据库、缓存与事务的一些学习</title>
    <link href="https://296245482.github.io/2018/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%BC%93%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"/>
    <id>https://296245482.github.io/2018/07/31/数据库、缓存与事务的一些学习/</id>
    <published>2018-07-30T16:02:06.000Z</published>
    <updated>2018-07-30T16:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存同步的两个主流策略"><a href="#缓存同步的两个主流策略" class="headerlink" title="缓存同步的两个主流策略"></a>缓存同步的两个主流策略</h2><p>在不同的请求并行的向缓存请求和更新数据时，因为一些诡异的时序安排，很容易引起某一个请求读到脏数据的情况</p><ul><li><h3 id="Set策略"><a href="#Set策略" class="headerlink" title="Set策略"></a>Set策略</h3><blockquote><p>查询时，先查缓存，命中直接返回，不命中查数据库，并将数据库的值<strong>set</strong>到缓存中<br>更新时，先更新数据库，再将值<strong>set</strong>到缓存中</p></blockquote></li></ul><p>这种方法只适合读多写少的情况，保持缓存在大多数时间都是可以取得到值的。其他情况下经常会出现缓存不一致问题，该方法还是需要慎用。</p><ul><li><h3 id="Delete策略"><a href="#Delete策略" class="headerlink" title="Delete策略"></a>Delete策略</h3></li></ul><p>Delete策略分为两种，主要的区别在于淘汰缓存的时机：</p><blockquote><p>查询时，和set策略一致，先查缓存，不命中查数据库，并将值写到缓存</p></blockquote><p>第一种：</p><blockquote><p>更新时，先淘汰缓存，再更新数据库</p></blockquote><p>这种情况下，会有A淘汰缓存后，B缓存不命中，从数据库中将值更新到缓存，A再更新数据库的情况。这种情况下，有一种叫<strong>延时淘汰</strong>机制，在更新情况下，可以设计一个异步操作，休眠1s再次淘汰缓存，但如果第二次淘汰发生错误了，依旧还是会产生不一致的问题。</p><p>第二种：</p><blockquote><p>更新时，先更新数据库，再淘汰缓存</p></blockquote><p>这种策略解决了delete策略第一种提到的问题，但也有新的问题，比如A查询没命中缓存去查数据库，读到一个旧值，此时B将新值写入数据库，然后淘汰缓存，此时A再将读到的值更新到缓存，同样产生了不一致。但此时的情况比上面的情况好很多，因为出现的概率会小很多，A的查询数据库时间是远小于B的写数据库的时间。</p><p>但是，如果一定要解决这个问题，同样可以参考delete策略中的第一种里面的延时删除策略，每次发起更新时，更新数据库并且淘汰缓存后，添加一个异步的消息队列，在一定的延时后再次淘汰缓存即可解决问题。</p><p><strong>值得一提的是，现在比较公认的更新策略最后一种，来自于<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">Cache-Aside pattern</a>，并且有如下缓存数据库同步策略的定义：</strong></p><ol><li>失效：从cache读取，没命中，读数据库，成功后将值放入缓存。</li><li>命中：从cache读取，命中并返回。</li><li>更新：把要更新的数据先存到数据库，成功后让缓存失效。</li></ol><h2 id="缓存的使用事项"><a href="#缓存的使用事项" class="headerlink" title="缓存的使用事项"></a>缓存的使用事项</h2><ul><li><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3></li></ul><p>一个写多读少的业务流程，需要经常更新数据库并且淘汰缓存，在做查询的时候，大多数时候都是缓存未命中，导致大部分请求全部打到数据库上。</p><ul><li><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3></li></ul><p>一批缓存使用了相同的过期时间，导致某一个时刻，一大批缓存过期失效，请求全部转发到数据库，导致数据库压力徒增。</p><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>原子性、一致性、隔离性、持久性</p><h3 id="数据库并发的问题"><a href="#数据库并发的问题" class="headerlink" title="数据库并发的问题"></a>数据库并发的问题</h3><blockquote><h4 id="丢失更新："><a href="#丢失更新：" class="headerlink" title="丢失更新："></a>丢失更新：</h4><p>第一类丢失更新：在没有事务隔离的情况下，AB同时操作某个值，同时读取，B做出修改并且提交更改，A发生异常回滚数据，导致B已完成的数据更新丢失。</p><p>第二类丢失更新：同上述例子，AB同时更新某值，在B提交更新之后，A也提交更新，B提交的更新就被A提交的覆盖。</p></blockquote><blockquote><h4 id="脏读："><a href="#脏读：" class="headerlink" title="脏读："></a>脏读：</h4><p>A对某一数据进行了修改，但是该修改还未提交数据库，这时B也访问该数据，然后使用了这个还没有成功更新的新数据，读到了脏数据。</p></blockquote><blockquote><h4 id="不可重复读："><a href="#不可重复读：" class="headerlink" title="不可重复读："></a>不可重复读：</h4><p>AB同时操作一段数据，A在一次操作中需要多次读取该数据，但是在这期间，B修改了该值并且完成了提交，这样A下次读到的数据就不一样。</p></blockquote><blockquote><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>同样也是AB同时操作一段数据，但和不可重复读不同的是，B不是对某数据的值进行修改，而是新增或者删除了某数据，A在这前后读取到的数据记录数发生了变化，这要区别于不可重复读。</p></blockquote><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>READ_UNCOMMITTED 未提交读</li></ul><p>允许其他事物读到未提交的数据</p><ul><li>READ_COMMITTED 提交读</li></ul><p>保证数据得到提交后才能被另一个事务读取到</p><ul><li>REPEATABLE_READ 可重复读</li></ul><p>保证一个事务在前后两次获取到的数据都是一样的</p><ul><li>SERIALIZABLE 顺序读</li></ul><p>事务的处理串行化</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">第一类丢失更新</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">第二类丢失更新</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">提交读</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">串行化</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><p><strong>MySQL采用的默认隔离级别是可重复读级别</strong></p><h3 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h3><ol><li><a href="https://www.cnblogs.com/johnsblog/p/6426287.html" target="_blank" rel="noopener">https://www.cnblogs.com/johnsblog/p/6426287.html</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=404308725&amp;idx=1&amp;sn=1a25ce76dd1956014ceb8a011855268e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=404308725&amp;idx=1&amp;sn=1a25ce76dd1956014ceb8a011855268e&amp;scene=21#wechat_redirect</a></li><li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside</a></li><li><a href="https://blog.csdn.net/d8111/article/details/2595635" target="_blank" rel="noopener">https://blog.csdn.net/d8111/article/details/2595635</a></li></ol>]]></content>
    
    <summary type="html">
    
      在前段时间的开发中，遇到了关于数据库与缓存更新策略上的问题，在我的项目中可能不涉及多线程的高频读写和高一致性要求，但了解数据库的这些相关知识还是很有必要的。文中也包括一些数据库的事务隔离级别，缓存的一些使用等。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
      <category term="MySQL" scheme="https://296245482.github.io/tags/MySQL/"/>
    
      <category term="Redis" scheme="https://296245482.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句写法优化</title>
    <link href="https://296245482.github.io/2018/07/04/SQL%E8%AF%AD%E5%8F%A5%E5%86%99%E6%B3%95%E4%BC%98%E5%8C%96/"/>
    <id>https://296245482.github.io/2018/07/04/SQL语句写法优化/</id>
    <published>2018-07-04T09:26:36.000Z</published>
    <updated>2018-07-04T09:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EXPLAIN用法"><a href="#EXPLAIN用法" class="headerlink" title="EXPLAIN用法"></a>EXPLAIN用法</h2><p>在不清楚索引等情况下，对于自己效率不太确定的SELECT语句，在SQL语句前加入 <code>EXPLAIN</code> 关键字，该语句会返回你这条SQL语句的执行计划，比如有没有用索引，有没有全盘扫描，可供效率参考，<code>EXPLAIN</code>运行返回的结果如下(例如：<code>EXPLAIN SELECT id,name,score FROM student_score</code>)：</p><p><code>id</code>: SELECT编号，出现顺序排序<br><code>select_type</code>: 查询的类型，简单或复杂<br><code>table</code>: 表名，或者其他查询语句ID<br><code>partition</code>: 该表的分区信息<br><code>type</code>: 访问类型<br><code>possible_keys</code>: 查询可能会用到的索引<br><code>key</code>: 实际使用的索引<br><code>key_len</code>: 使用的索引长度<br><code>ref</code>: 哪些列或常量被用于查找索引列上的值<br><code>rows</code>: 估计读取的行数<br><code>filtered</code>: 返回结果的行数占需要度的航的百分比<br><code>Extra</code>: MySQL解决查询的额外信息</p><p>其中，访问类型：ALL, index,  range, ref, eq_ref, const, system, NULL，从左到右性能从差到好，当自己的语句出现靠左侧的type时要考虑优化自己的索引或者查询语句</p><p>注：MYSQL 5.6.3以前只能<code>EXPLAIN SELECT</code>； MYSQL5.6.3以后就可以<code>EXPLAIN SELECT、UPDATE、DELETE</code></p><p><strong>有了<code>EXPLAIN</code>语句，通过SQL语句的执行计划，我们可以很快定位到查询语句过慢的问题。</strong></p><h2 id="NULL与空值"><a href="#NULL与空值" class="headerlink" title="NULL与空值"></a>NULL与空值</h2><p>MySQL中的“空值”和“NULL”是有不同的，并且在对NULL进行 <strong>‘&lt;’、’&gt;’、’=’</strong> 操作时肯定很多人都遇到过坑，在对一些NULL值的判断若理解不到位可能会导致得到的查询结果和你所设想的SQL结果不一致的情况。</p><p>‘’ - 空值在MySQL中不占空间，而NULL是占用空间的，好比一个容器，空值代表容器内是真空的，NULL则代表容器内装满了空气。B树索引时不会存储NULL值，如果索引的字段可以为NULL，索引的效率会下降很多。</p><p><code>IS NOT NULL</code>和<code>!=NULL</code>是不一样的操作，对于 <strong>“=、&lt;、&gt;…”</strong> 等这些判断来说，<code>NULL</code>表示什么都不是，任何运算符的操作结果都是false，对于<code>NULL</code>的计算只能使用<code>IS NULL</code>来判断，一般情况下推荐使用<code>IS NOT NULL</code>，对于<code>!= NULL</code>来说返回的结果永远都是0行，并且不会有任何语法错误。</p><p>但是如果一定要使用<code>!= NULL</code>的话，可以通过set ANSI_NULLS off让<code>IS NOT NULL</code>和<code>!= NULL</code>等价。</p><h2 id="避免查询的全盘扫描，保证索引正确使用"><a href="#避免查询的全盘扫描，保证索引正确使用" class="headerlink" title="避免查询的全盘扫描，保证索引正确使用"></a>避免查询的全盘扫描，保证索引正确使用</h2><ol><li>在所有的SQL中尽量避免type为ALL的全盘扫描，在<code>WHERE</code>和<code>ORDER BY</code>涉及的字段上建立索引，否则数据量过大时经常会导致超时。</li></ol><ol start="2"><li><code>WHERE</code>子句中尽量减少<code>!=</code>和<code>&lt;&gt;</code>操作符，这种情况下索引可能不会被使用进而进行全盘扫描。</li></ol><ol start="3"><li><p>尽量避免将会在<code>WHERE</code>子句中涉及的字段设置可以为null，索引中有NULL值时索引效率会下降很多，例如还有如下情况：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,score <span class="keyword">FROM</span> STUDENT_SCORE <span class="keyword">WHERE</span> score <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p> <code>is null</code>语句的使用会放弃使用索引，进而进行全盘扫描，在设计中可以将null值替换为默认值”0”，上述语句<code>WHERE</code>后的语句可以改为<code>score = 0</code>。</p></li></ol><ol start="4"><li><p>将<code>WHERE</code>子句中的<code>OR</code>条件改写，拆成两条语句的<code>UNION</code>操作，例如下列语句将会进行全表扫描：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score = <span class="number">100</span> <span class="keyword">OR</span> socre = <span class="number">0</span></span><br></pre></td></tr></table></figure><p> 可以改成这样的查询提升查询效率：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score = <span class="number">100</span></span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score = <span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><p>若查询中经常涉及<code>LIKE</code>与通配符<code>%</code>的查询可以考虑在原表中加入全文索引，如下：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%long%'</span></span><br></pre></td></tr></table></figure><p> 这句SQL语句若要考虑优化可以将<code>name</code>字段设置成全文索引，提高效率。全文索引的使用方法参考<a href="https://blog.csdn.net/u011734144/article/details/52817766/" target="_blank" rel="noopener">MySQL使用全文索引</a></p></li></ol><ol start="6"><li><p><code>IN</code>和<code>NOT IN</code>的使用大多也会放弃使用索引，进行全表扫描，对于连续值的情况，使用<code>BETWEEN</code>代替<code>IN</code>,例如：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score <span class="keyword">IN</span> (<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p> 改写为：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score <span class="keyword">BETWEEN</span> <span class="number">98</span> <span class="keyword">and</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></li><li><p>如果在<code>WHERE</code>子句中有参数，也会导致全表扫描，例如：下述SQL语句：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> <span class="keyword">name</span>=@<span class="keyword">name</span></span><br></pre></td></tr></table></figure><p> 因为SQL只有在运行时才会解析局部变量，SQL执行计划在编译时生成，可这个时候变量的值还是未知的，因而无法作为索引的输入项，实际执行时只能进行全表扫描。可以改为强制查询使用索引：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WITH</span>(<span class="keyword">INDEX</span>(<span class="string">"索引名"</span>)) <span class="keyword">WHERE</span> <span class="keyword">name</span>=@<span class="keyword">name</span></span><br></pre></td></tr></table></figure></li><li><p>避免在<code>WHERE</code>子句中进行表达式操作，例如：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score/<span class="number">2</span>=<span class="number">50</span></span><br></pre></td></tr></table></figure><p> 为了避免放弃索引而全表扫描，应改为</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> score=<span class="number">2</span>*<span class="number">50</span></span><br></pre></td></tr></table></figure></li><li><p>避免在<code>WHERE</code>子句中的函数操作，如下：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student_score <span class="keyword">WHERE</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=<span class="string">'cheng'</span> <span class="comment">--name以cheng开头</span></span><br></pre></td></tr></table></figure><p> 为了避免放弃索引，而全表扫描改写为name字段添加全文索引的通配符匹配，或者使用<code>WHERE name LIKE &#39;cheng%&#39;</code>。</p></li></ol><ol start="10"><li>除了上述的8和9外，我们尽量避免在<code>WHERE</code>子句中的<code>=</code>左边进行函数、算数运算或其他表达式的运算，保证索引的正确使用。</li></ol><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><ol><li><code>WHERE</code>子句中的条件是<code>OR</code>关系的话，加索引将不会有任何作用。考虑改写为两条SQL语句的<code>UNION ALL</code>操作。</li></ol><ol start="2"><li>数据重复并且分布均匀的表字段建了索引一般不会对查询效率的提升有很大影响。</li></ol><ol start="3"><li>符合索引从左到右使用索引中的字段，可以只是用一部分，但必须是最左侧的部分。所以复合索引把最常用的字段放在最左边，重要程度一次递减。</li></ol><ol start="4"><li>复合索引中任何字段含有NULL值，那么该字段对复合索引是无效的。</li></ol><ol start="5"><li><code>LIKE &#39;%abc%&#39;</code>不会使用索引而<code>LIKE &#39;abc%&#39;</code>会使用索引。</li></ol><ol start="6"><li>使用<code>EXISTS</code>和<code>NOT EXISTS</code>代替<code>IN</code>和<code>NOT IN</code>，后者不会使用索引而进行全表扫描。</li></ol><h2 id="其他Tips"><a href="#其他Tips" class="headerlink" title="其他Tips"></a>其他Tips</h2><ol><li>能设计成数字型的字段就不设计成字符型。因为在处理查询等操作时字符型会挨个比较没一个字符，而数字型比较一次就够了。</li></ol><ol start="2"><li>使用<code>varchar/nvarchar</code>代替<code>char/nchar</code>，前者是边长字段，可以节省空间，并且字段越小搜索效率越高。</li></ol><h3 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h3><ol><li><a href="https://blog.csdn.net/wendy432/article/details/52319908" target="_blank" rel="noopener">https://blog.csdn.net/wendy432/article/details/52319908</a></li><li><a href="https://blog.csdn.net/u011734144/article/details/52817766/" target="_blank" rel="noopener">https://blog.csdn.net/u011734144/article/details/52817766/</a></li><li><a href="https://www.cnblogs.com/softidea/p/5977860.html" target="_blank" rel="noopener">https://www.cnblogs.com/softidea/p/5977860.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      本文从SQL语句的层面上介绍了SQL语句的优化写法，当数据量达到一定程度时将会提高查询效率。
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="DB" scheme="https://296245482.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>Java容器源码阅读记录</title>
    <link href="https://296245482.github.io/2018/06/12/Java%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>https://296245482.github.io/2018/06/12/Java容器源码阅读记录/</id>
    <published>2018-06-12T02:32:36.000Z</published>
    <updated>2018-06-12T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先还是要放出这张大图，想要详细理解容器源码，他们之间的继承实现关系必须了熟于心。</p><div align="center"><img src="https://i.loli.net/2018/06/12/5b1f39ccf3c6a.png" width="500"></div><h2 id="ArrayList相关"><a href="#ArrayList相关" class="headerlink" title="ArrayList相关"></a>ArrayList相关</h2><h3 id="ArrayList初始化"><a href="#ArrayList初始化" class="headerlink" title="ArrayList初始化"></a>ArrayList初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的EMPTY_ELEMENTDATA值为0，初始化ArrayList时默认长度为零，不拥有默认大小</p><h3 id="ArrayList的扩容"><a href="#ArrayList的扩容" class="headerlink" title="ArrayList的扩容"></a>ArrayList的扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if</span></span><br><span class="line"><span class="comment"> * necessary, to ensure that it can hold at least the number of elements</span></span><br><span class="line"><span class="comment"> * specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if real element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for empty table. It's already supposed to be</span></span><br><span class="line">        <span class="comment">// at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensureCapacity方法可由开发者调用，当调整的容量低于DEFAULT_CAPACITY时，只要有容量扩大需求，都会至少保证DEFAULT_CAPACITY=10的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际扩容时调用的是grow()方法，可以看到，ArrayList在有扩容需求时会将原来的数组中的元素使用Arrays.copyOf方法复制到一个新的数组中，并且每次容量的增长为原来容量的1.5倍。</p><p><strong>因此在使用ArrayList时，因为扩容代价较高，应尽量指定容量</strong></p><h3 id="ArrayList中的modCount"><a href="#ArrayList中的modCount" class="headerlink" title="ArrayList中的modCount"></a>ArrayList中的modCount</h3><p>modCount变量用于记录该ArrayList的变更次数，包括add,remove,addAll,removeRange,clear方法，每操作一次这些方法，modCount的值就++。</p><p>modCount继承自AbstractList，该类中有iterator()方法使用了一个私有内部成员类Itr，Itr中有一个属性expectedModCount，在初始化的时候expectedModCount = modCount。</p><p>在对一个集合对象进行迭代操作时，如果不限制集合元素的操作，那么一些add或者remove操作可能会引起迭代错误，因此在AbstractList中使用了判断modCount和expectedModCount是否相等来规避这些风险。</p><h2 id="HashMap相关"><a href="#HashMap相关" class="headerlink" title="HashMap相关"></a>HashMap相关</h2><h3 id="HashMap容量"><a href="#HashMap容量" class="headerlink" title="HashMap容量"></a>HashMap容量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap的构造函数，参数一是桶容量大小，参数二是扩容阈值，默认0.75，即使只传桶容量，也会调用上述构造方法，loadFactor=0.75。还有一个变量叫threshold，threshold = loadFactor * capacity，就是扩容的阈值，当达到这个容量的时候就需要出发扩容机制，0.75时可以理解为装满四分之三就触发扩容。</p><p>HashMap的初始化在不指定容量大小的时候是16，并且保证初始化时容量大小总是2的n次方大小，根据HashCode查找数组位置的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns index for hash code h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>length设置成2的n次方是有意义的，比如这里和HashCode的“与”运算，和2的n次方-1这样的全1二进制做与，可以保证数组的每个位置的index都有，比如1110，那么HashMap的数组1位置就永远不可能有值能放过来，因为没有数能和1110做“与”结果为1。（）</p><h3 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new entry with the specified key, value and hash code to</span></span><br><span class="line"><span class="comment"> * the specified bucket.  It is the responsibility of this</span></span><br><span class="line"><span class="comment"> * method to resize the table if appropriate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Subclass overrides this to alter the behavior of put method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 大小超过threshold，扩容两倍</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为HashMap的容量设置成2的n次方有利于提高利用率，所以当map中包含的Entry的数量大于等于threshold，触发扩容时扩大的容量倍数也是2倍。</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet底层使用HashMap实现，构造方法上使用HashMap基本也是使用HashMap的，主要的区别在于HashMap存储键值对，HashSet仅仅存储对象，因为HashMap中的key是惟一的，所以这个特性被HashSet使用来保证存储对象的唯一性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span></span><br><span class="line"><span class="comment"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * If this set already contains the element, the call leaves the set</span></span><br><span class="line"><span class="comment"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span></span><br><span class="line"><span class="comment"> * element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在往HashSet里插入元素时，调用HashMap的put方法，如果该元素已经存在就返回false，不存在就返回true。</p><p>在我们日常使用HashSet时，要注意自己重写hashCode()和equal()方法，这样才能确保自己的比较的正确性。</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable基本可以等价于HashMap，大体上只有这些区别：</p><ol><li><p>HashTable是线程安全的，多个线程可以共享一个HashTable，HashMap不是synchronized的，但是ConcurrentHashMap是HashTable的一种替代，并且扩展性比HashTable更好。</p></li><li><p>HashMap的迭代器是Iterator，是fail-fast迭代器，当有其他线程改变HashMap的结构时就会抛出ConcurrentModificationException，而HashTable使用的是enumerator迭代器，不是fail-fast的。</p></li><li><p>单线程环境下，HashMap的性能比HashTable好。</p></li></ol><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h3 id="LinkedHashMap的有序性"><a href="#LinkedHashMap的有序性" class="headerlink" title="LinkedHashMap的有序性"></a>LinkedHashMap的有序性</h3><p>LinkedHashMap和HashMao的主要区别在于前者的Entry是用一个双向链表维护的，这个链接列表定义了迭代的顺序，并且该迭代顺序是由插入顺序或者访问顺序决定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>LinkedHashMap中的accessOrder()来决定迭代顺序，为true则按访问顺序排序，越近访问的位置越靠后，false为按照插入顺序，最近插入的位置越靠后。</p><p>基本的初始化等操作全部与HashMap原理一致，只是多了recordAccess方法，在每次操作时重新排序，将最近操作的Entry放到最后。因为链表的移位操作，增加、删除操作都是常量级别的消耗，所以不会带来性能的损失。</p><h3 id="LinkedHashMap与LRU缓存"><a href="#LinkedHashMap与LRU缓存" class="headerlink" title="LinkedHashMap与LRU缓存"></a>LinkedHashMap与LRU缓存</h3><p>LRU - Last Recent Use，由于LinkedHashMap能存储最近访问的功能，我们可以使用它来设计缓存，LinkedHashMap本身已经把最常读取的放在链表的最后。</p><p>在实现一个简单的LRU缓存功能时，我们只需要设置一个阈值，重写LinkedHashMap的removeEldestEntry方法，去除那些很久没有访问的Entry就行。</p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>继承自HashSet，基于LinkedHashMap，存的内容只有值，并且也维护着一个运行所有条目的双重链接列表。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>基于链表实现，和ArrayList的主要区别就在于访问的性能，LinkedList的插入删除操作更好，但是随即访问操作要比ArrayList差。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><p>看源码过程中看到了很多transient关键字，简单了解了一下：</p><p>Java中的序列化和反序列化：</p><ol><li>序列化：将一个对象转换成一串二进制表示的字节数组，通过保存或转移这些自己数据来达到持久化的目的，例如写到文件中等。</li><li>反序列化：将字节数组重新构造成对象。</li></ol><p>java的transient关键字在序列化过程中为我们提供了便利，对需要通过序列化实现持久化的对象，首先实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><p>这样HashMap等容器在序列化的时候，其容量大小，扩容阈值等这些容器内部变量就不会被序列化存储。</p>]]></content>
    
    <summary type="html">
    
      了解Java中的容器，仅仅了解一些显著的区别和特性是不太够的，更应该了解每个容器的具体实现机制，初始化机制，扩容机制，了解一些常见操作中他们的性能情况，本文在阅读个容器源码的过程中记录下这方面的一些特性
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="Java" scheme="https://296245482.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>避免嵌套条件式</title>
    <link href="https://296245482.github.io/2018/05/31/%E9%81%BF%E5%85%8D%E5%B5%8C%E5%A5%97%E6%9D%A1%E4%BB%B6%E5%BC%8F/"/>
    <id>https://296245482.github.io/2018/05/31/避免嵌套条件式/</id>
    <published>2018-05-31T15:11:36.000Z</published>
    <updated>2018-05-31T15:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="嵌套条件式"><a href="#嵌套条件式" class="headerlink" title="嵌套条件式"></a>嵌套条件式</h2><p>今天在面对一个一般复杂的业务情况时，对着活动图写了一个嵌套三层的逻辑判断，review代码时被别人提醒了，在指导下也将嵌套三层的逻辑判断压缩到约等于两层，顿时代码整体简洁已读，结构也很清晰，不禁感慨如果处处注意代码的优美和易读性，写代码其实也可以是很美的事情。</p><p>写代码经常会遇到逻辑稍微复杂点的情况，比如逻辑分支众多，直接理解来写代码可能会出现嵌套多个 “if-else” 的情况，嵌套层数大于两层以后代码对于后人来看增加了很多成本。</p><p>遇到复杂逻辑的流程时，需要分解成简单易懂的逻辑代码，我能想到的方法有：拆分代码逻辑使功能模块化、使用卫语句。</p><h2 id="使用函数模块化"><a href="#使用函数模块化" class="headerlink" title="使用函数模块化"></a>使用函数模块化</h2><p>对一些嵌套的逻辑，可以提取出其中的一部分代码，封装成一个函数来使用，对于多种情况下可能涉及到的差不多的操作，也可以直接提取出其中相同的部分来模块化实现。</p><h2 id="卫语句"><a href="#卫语句" class="headerlink" title="卫语句"></a>卫语句</h2><p>卫语句的核心在于：在多层逻辑判断中，如果某个分支出现的请看股较于其他分支比较特殊，给它提出来单独处理，如果它真的发生了，做一些必要的整理工作，然后返回退出。</p><p>一下是一个卫语句的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isHuman())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个人"</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(isAlien())&#123;</span><br><span class="line">         System.out.println(<span class="string">"是个外星人"</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(isChenglong())&#123;</span><br><span class="line">            System.out.println(<span class="string">"是成龙"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码如果再多几层嵌套，给他人看起来的时候可能需要花不少时间理清楚你这里面不同情况的分支是什么条件过来的。</p><p>使用卫语句来改造就能在保持逻辑的情况下更加清晰明了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isHuman())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个人"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(isMan())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是个外星人"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(isChenglong())&#123;</span><br><span class="line">      System.out.println(<span class="string">"是成龙"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>卫语句可以把我们的视线从异常处理中解放出来，集中精力到正常处理的代码中。</p><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p><strong>想要自己的代码在复杂逻辑下依旧保持美感和清晰的结构，关键还是理解整个代码逻辑，能清楚的认识到每一个情况的输入输出，充分认识到其中每个情况的条件出现概率，例如提取出出现概率罕见的情况直接单独检查，及早的依据结果返回。</strong></p>]]></content>
    
    <summary type="html">
    
      写代码经常会遇到逻辑稍微复杂点的情况，比如分支众多，直接理解来写代码可能会出现嵌套多个 &quot;if-else&quot; 的情况，嵌套层数大于两层以后代码对于后人来看增加了很多成本，我们要学会让自己的代码保持美感
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="Java" scheme="https://296245482.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP/UDP &amp; 可靠的传输</title>
    <link href="https://296245482.github.io/2018/05/08/TCP:UDP%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BC%A0%E8%BE%93/"/>
    <id>https://296245482.github.io/2018/05/08/TCP:UDP实现可靠的传输/</id>
    <published>2018-05-08T15:58:00.000Z</published>
    <updated>2018-05-08T15:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>春招的面试被问到过UDP怎么实现可靠的传输，当时都是仅仅凭着自己对TCP三次握手四次挥手的理解自己瞎说，面试官的反馈肯定都是不满意，说起来自己其实对TCP的理解也不深入，它是如何保证可靠传输的几个机制都都只知道这几个模糊的概念，花点时间好好看看，写下这篇文章让自己加深印象</p><h1 id="TCP实现可靠传输的几个机制"><a href="#TCP实现可靠传输的几个机制" class="headerlink" title="TCP实现可靠传输的几个机制"></a>TCP实现可靠传输的几个机制</h1><h2 id="确认机制"><a href="#确认机制" class="headerlink" title="确认机制"></a>确认机制</h2><p>序号——序号的增加是和传输的字节相关的。TCP在传输数据时的序列号（Sequence Number）不是以报文段来进行编号的，而是将该连接生存周期内的所有数据当做一个字节流，按照字节流中的每个字节进行编号。每个TCP数据包中的数据大小不一定相同。在三次握手的连接建立之初，双方都会规定好初始的序号x和y，TCP每次传送的序号字段值表示所要传送的本报文中的第一个字节的序号。</p><p>确认——TCP的数据确认送达（ACK），是对接收到的数据的最高序列号的确认，并向发送方返回下一次期望的TCP数据包的序列号。如A-&gt;B，A当前序号是100，数据长度是50，B返回的确认号就是151给A。</p><p>效率提高——提高网络利用率和传输效率，例如TCP可以一次确认多个数据报，如果接收方接收到了151，201，301，那么只需要对301数据报确认即可，收到301意味着前面的都已经确认过。</p><p>不能跳着确认——接收端在确认时，只能确认最大的连续收到的包，例如发送端发了1，2，3，4，接收端收到了1，2，4，只能回3，回复连续收到的最大包+1的序号。</p><p>如果发送方在规定的时间内没有收到返回，超过规定时间后就将未被确认的数据重新发送，接收方如果收到的数据存在差错，也会直接丢弃此报文，不返回确认信息。更多详细的重传机制后面细讲。</p><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>有了前面的确认机制，在数据报传送发生错误时，需要重传机制来保证传输完整。</p><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>如果是阻塞式传输的话，意味着没有收到确认就一直四等，造成巨大的资源浪费，所以设定一个时间timeout，分为两种，一种是只重传超过timeout的包，另一种是重传timeout之后的所有包。</p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>相对于超时重传，这种机制不以时间驱动而以数据驱动，前一种方法是超过一定时间未收到就重传，快速重传是连续收到几次相同的ACK就重传，例如A-&gt;B，连续发1、2、3、4、5，假设期间2数据报因为某些原因没有到达，则B在收到3、4、5的时候继续返回序号为2的ACK，A在连续收到3次序号为2的ACK后，得知序号为2的包没有到达，马上重传2。</p><p><div align="center"><img src="https://i.loli.net/2018/05/19/5affe6a70cfdd.png"></div><br>但也存在问题，A并不知道2之后的是不是被对方收到了其他的数据，不知道三次返回的序号2是谁传回来的。</p><h3 id="Selective-Acknowledgment-SACK"><a href="#Selective-Acknowledgment-SACK" class="headerlink" title="Selective Acknowledgment(SACK)"></a>Selective Acknowledgment(SACK)</h3><p>这种方式基于快速重传的方法，只是在TCP头里加一个叫SACK的东西，接收方在接收缓冲区中记录好我当前缺少的部分，返回时向发送方汇报缺失内容。</p><p><div align="center"><img src="https://i.loli.net/2018/05/19/5affeda69255a.jpg" width="500"></div><br>这种优化的快速重传需要两方协议都支持才行。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>TCP主要解决的是可靠的传输和包乱序的问题，滑动窗口是TCP引入的一种网络控流技术，TCP必须要知道网络传输中实际的数据处理带宽或者说是数据处理速度，这样才不会引起网络拥塞导致丢包。</p><h3 id="AdvertisedWindow"><a href="#AdvertisedWindow" class="headerlink" title="AdvertisedWindow"></a>AdvertisedWindow</h3><p>Sliding Window是一个被设计来做网络流控的技术，TCP头里有一个字段叫Advertised-Window，这个字段是接收端返回给发送端告诉发送端自己还有多少的缓冲区可以接收数据，下次发送端发送数据就会按照这个接收端的处理能力来发送数据。要理解滑动窗口先看一下TCP缓冲区：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0cd52d370b0.jpg" width="400"></div></p><blockquote><p>接收端里的LastByteRead表示上层应用正在读的地方，NextByteExpected表示收到的连续包的最后一个位置，LastByteRcved表示收到的包最后的一个位置，连续包和最后位置的包之间是有间隙的，表示中间还是有数据没有到达</p><p>发送端中LastByteRead表示被接收端Ack过的位置，LastByteSent表示发送出去了，但是还没收到成功确认的Ack，LastByteWritten表示上层应用正在写的地方。</p></blockquote><p>因此，前面说到过的AdvertisedWindows的计算方式为:</p><blockquote><p>AdvertiedWindow = MaxRcvBuffer - LastByteRcvd - 1<br>这个窗口就是用来控制发送数据大小的，确保接收方可以处理</p></blockquote><h3 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h3><p>下面是发送方的滑动窗口的示意图：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0ce040420bf.png" width="600"></div></p><blockquote><p>黑框部分也就是滑动窗口</p><ol><li>Category#1代表的是已经收到Ack确认的数据</li><li>Category#2代表已经发送但是还未收到Ack的数据</li><li>Category#3代表按照接收方缓冲区大小计划发出的数据</li><li>Category#4代表窗口以外的数据，接收方空间不足以现在发送</li></ol></blockquote><p>下面是一个接收端使用滑动窗口控制发送端的过程，结合上述描述和AdvertiedWindow配合理解：</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0ce2072bdd7.png" width="600"></div></p><h3 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h3><p>在上图中，可以看到接收端数据处理很缓慢，返回的Window大小越来越小，最后一次返回的Window = 0，这种情况下，发送端知道接收端缓冲区已经没有地方了就不会再发送数据了，这就有个问题，发送端不发数据了接收方也没法通知发送方Window Size可用了。</p><p>为了解决这个问题，TCP使用了Zero Window Probe技术，在Window = 0之后，发送方会发ZWP包给接收方，让接收方来Ack他现在的Window大小，不同的实现情况下会设置不同的次数和不同的时间。</p><p><strong>PS：*</strong>该技术可能会被DDoS攻击，攻击者在TCP连接建立完成后向发送方不断的发送带有Window = 0的Ack，发送方就停止发送并且发送ZWP包，服务器资源就被渐渐耗尽*</p><h3 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h3><p>像上面的那种情况，如果接收方太忙，不能及时取走Receive Window里的数据，会导致最后只有几个字节的Window来传输数据，而一次传输只传这么少量的数据很不划算，如果数据包用不满整个带宽的话会浪费大量的资源。</p><p>这个问题的解决思路从接收端和发送端两边都有解决思路，接收端设置一个阈值，小于该阈值的情况下都是Ack(0)把Window关了，等到处理后大小够大了以后再重设Window；发送端主要思路是做延时处理，设置阈值，或者是收到Ack才发数据，其他时间段都是做数据积累</p><h2 id="拥塞算法"><a href="#拥塞算法" class="headerlink" title="拥塞算法"></a>拥塞算法</h2><p>TCP利用滑动窗口做到了流控还是不够，还需要知道整个网络上的事。例如如果网络延时增加，导致大量丢包，没有拥塞处理的情况下，TCP只会重传数据，这样只会导致网络的负担更加重，甚至拖垮一个网络。因此TCP必须知道整个网络的情况，而且主体的设计思想为：<strong>TCP不是一个自私的协议，当拥塞发生时，做出自我牺牲，让出资源出来，不抢占少占有。</strong></p><p>拥塞算法主要是四个部分：</p><ol><li>慢启动</li><li>拥塞避免</li><li>拥塞发生时快速重传</li><li>快速恢复</li></ol><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>慢启动的过程很好理解，就是在加入连接的过程中，一点点提速。如下图所示，连接建立好以后，cwnd慢慢增加，每当收到一个Ack，cwnd线性上升，每隔一个RTT，cwnd指数上升。上升也不是无止境的，有一个slow start threshold，当cwnd &gt; ssthresh时进入“拥塞避免算法”。</p><p><div align="center"><img src="https://i.loli.net/2018/05/29/5b0cfaa95150d.jpg" width="500"></div></p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>慢启动在双重递增的情况下可以达到无限增长，因此设置了一个ssthresh，cwnd到达ssthresh后，每当收到一个Ack：cwnd增加一个自己的倒数，每过一个RTT：cwnd自增1。</p><h3 id="拥塞时状态"><a href="#拥塞时状态" class="headerlink" title="拥塞时状态"></a>拥塞时状态</h3><p>当发生丢包时，有两种解决思路：</p><p>第一种是降低sshthresh的值（sshthresh = cwnd / 2），重置cwnd为1，重新开始慢启动的过程；</p><p>第二点是快速重传的方法，cwnd保留一半（cwnd = cwnd / 2），sshthresh = cwnd，进入快速恢复方法。</p><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>快速重传和快速恢复一般一起使用，前面说过快速重传有3次Duplicated Acks。</p><p>当发送方连续收到三个重复确认时，就把慢开始门限减半（cwnd = cwnd / 2），这是为了预防网络发生拥塞。注意，接下来不执行慢开始算法。</p><p>由于发送方现在认为网络很可能没有发生特别严重的阻塞（如果发生了严重阻塞的话，就不会一连有好几个报文段到达接收方，就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口的值不设为1个MSSS），而是把拥塞窗口的值设为慢开始门限减半后的值，而后开始执行拥塞避免算法，线性地增大拥塞窗口。</p><hr><h1 id="UDP实现可靠传输的思路"><a href="#UDP实现可靠传输的思路" class="headerlink" title="UDP实现可靠传输的思路"></a>UDP实现可靠传输的思路</h1><p>UDP不属于连接型协议，且资源消耗小，处理速度快，通常音频、视频传输时用的比较多，因为即使偶尔丢失一两个数据包，也不会对结果产生太大影响。</p><p>UDP要实现可靠传输，在传输层已经无法保证可靠传输了，只能依靠应用层来实现，实现的要点主要是确认机制、重传机制、窗口确认等。目前已经有的开源项目基于UDP实现了可靠的数据传输：RUDP、RTP、UDT。</p><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><p>RUDP：提供拥塞控制的改进、重发机制及淡化服务器算法等机制，允许TCP方式下的流控行为。</p><p>RTP：该协议被用来解决音频和视频传输的功能，解决了TCP在这些应用上“慢”启动带来的问题，传输模型可以单点和多点传输。RTP协议在应用层工作，利用多路复用和校验，消除丢包带来的影响。RTP提供的服务包括有效的负载识别、序列编号、时间戳和投递监听。</p><p>UDT：主要目的是支持高速广域网上的海量数据传输，引入了拥塞控制和数据可靠性控制机制，面向连接的双向应用协议，发送方依据流量控制和速率控制来发送应用数据，接收者接受数据包和控制包，根据接收到的包发送控制包。</p><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>主要解决两个问题：丢包和包的顺序的问题</p><p>解决思路：</p><ol><li>给每个包编号，按照包的顺序接收并存储</li><li>增加确认机制</li><li>重传机制</li><li>窗口流量控制机制</li></ol><p>-&gt; ①UDP数据包+序列号 ②UDP数据包+时间戳 ③应答确认</p><p>TCP已经足够复杂了，用UDP来实现TCP其实是个很没意义的事情，如果不考虑完整实现TCP的功能，从这个角度来想，依据特定的需求来看，如果希望在某些情况下UDP优于TCP，一定是放弃了一些TCP重要的东西，比如以下两种情况：</p><ol><li>业务逻辑上允许信息丢失，例如在同步状态中，状态信息是有实效性，那么过期的信息是可以允许丢失的，每个新的状态信息都可以取代旧的信息，只是允许这样操作的业务场景非常少。</li><li>允许包乱序，只要和TCP一样在每个包上加上个序号即可，这样的复杂程度也很高，和TCP对比起来唯一的优势也就是在即使中间有包晚到了，业务层也可以先开始处理后面先到的包开始处理。</li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://blog.csdn.net/ns_code/article/details/32707721" target="_blank" rel="noopener">https://blog.csdn.net/ns_code/article/details/32707721</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11609.html</a></li><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11564.html</a></li><li><a href="https://blog.csdn.net/pangyemeng/article/details/50387078" target="_blank" rel="noopener">https://blog.csdn.net/pangyemeng/article/details/50387078</a></li><li><a href="https://blog.csdn.net/kennyrose/article/details/7557917" target="_blank" rel="noopener">https://blog.csdn.net/kennyrose/article/details/7557917</a></li></ol>]]></content>
    
    <summary type="html">
    
      春招的面试被问到过两次UDP怎么实现可靠的传输，说起来自己对TCP是如何保证可靠传输的几个机制都不太熟，写下这篇文章让自己加深印象
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="网络" scheme="https://296245482.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown学习，一些常用小技巧</title>
    <link href="https://296245482.github.io/2018/04/24/Markdown%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://296245482.github.io/2018/04/24/Markdown一些不常见的小技巧/</id>
    <published>2018-04-24T07:43:47.000Z</published>
    <updated>2018-04-24T07:43:47.000Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为本博客的创作都是使用的Markdown，把自己平时用的比较多的Markdown语法做一个简单的记录，方便以后的取用。</p><p>本文省略了一些基本的语法，例如标题、文本强调、无序有序列表、表格绘制等内容</p><h2 id="详细技巧"><a href="#详细技巧" class="headerlink" title="详细技巧"></a>详细技巧</h2><h3 id="图片位置大小"><a href="#图片位置大小" class="headerlink" title="图片位置大小"></a>图片位置大小</h3><p>使用标准的图片插入方法<code>![]()</code>不能对图片进行位置和大小进行控制，默认居左并且按图片大小显示。</p><p>使用的方法是借助HTML标签来实现，在<code>&lt;div&gt;</code>标签中使用<code>align</code>、<code>width</code>、<code>height</code>等来控制，如下所示：</p><p><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 默认显示效果</span><br><span class="line">![](../imgs/20180424_1.jpeg)</span><br><span class="line">2. 位置大小控制效果</span><br><span class="line">&lt;div align = &quot;center&quot;&gt;&lt;img src = &quot;https://i.loli.net/2018/04/24/5adf182dd449f.jpeg&quot; width = &quot;100&quot;/&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><strong>默认效果</strong><br><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" alt=""><br><strong>控制后的效果</strong></p><div align="center"><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" width="100"></div><p><em>PS</em>: 在文中插入图片除了可以将照片放在本地直接获取外，可以使用一些免费的CDN，例如<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>，可以将图片传到线上，使用链接获取。</p><hr><h3 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h3><p>图文混合编排也可以使用HTML中的标签来实现，如下所示的文字靠左，图片靠右的实现方式：</p><p><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src = &quot;https://i.loli.net/2018/04/24/5adf182dd449f.jpeg&quot; align = &quot;right&quot; width = &quot;300&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><strong>实例效果</strong></p><div><img src="https://i.loli.net/2018/04/24/5adf182dd449f.jpeg" align="right" width="300"></div><p>描述1</p><p>描述2</p><p>描述3</p><p>描述4</p><p>这是一个表情表的介绍，为了凑字数多写一点，让在不同的屏幕大小的情况下都能看得出他的自动换行效果，紫薯布丁紫薯布丁紫薯布丁…..</p><hr><h3 id="段前缩进"><a href="#段前缩进" class="headerlink" title="段前缩进"></a>段前缩进</h3><p>在Markdown里，在一个空格或者TAB之后的其他缩进会默认被无视，因此需要使用<code>&amp;ensp;</code> - 半角空格 或者 <code>&amp;emsp;</code> - 全角空格来实现缩进<br><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这&amp;ensp;中&amp;ensp;间&amp;ensp;有&amp;ensp;半&amp;ensp;角&amp;ensp;空&amp;ensp;格</span><br><span class="line">&amp;emsp;&amp;emsp;这之前有全角空格</span><br></pre></td></tr></table></figure></p><p><strong>实例效果</strong></p><p>这&ensp;中&ensp;间&ensp;有&ensp;半&ensp;角&ensp;空&ensp;格</p><p>&emsp;&emsp;这之前有全角空格</p><hr><h3 id="加强代码块"><a href="#加强代码块" class="headerlink" title="加强代码块"></a>加强代码块</h3><p>将需要高亮的代码块包裹在如下的格式内即可：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;```语言名</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>Python效果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> somefunc(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><p>在hexo中的 <code>front-matter</code> 中填入 <code>toc: true</code> 即可</p><p>目录生成效果如本文所示</p><hr><h3 id="插入公式-MathJax方法"><a href="#插入公式-MathJax方法" class="headerlink" title="插入公式 MathJax方法"></a>插入公式 MathJax方法</h3><p>网上有很多教程的方法，大多数都是在hexo中安装上MathJax，这里介绍一种较为简洁的方法，在你文章的<code>front-matter</code>中插入一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/x-mathjax-config"</span>&gt;</span><br><span class="line">MathJax.Hub.Config(&#123;</span><br><span class="line">tex2jax: &#123;<span class="attr">inlineMath</span>: [[<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">'\\('</span>,<span class="string">'\\)'</span>]]&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">" async</span></span><br><span class="line"><span class="string">  src="</span>https:<span class="comment">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"&gt;</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>之后，文中的公式两边加上$符号即可显示出公式，如下的<code>$E=mc^2$</code>和<code>$f(x) = x^2$</code>分别显示出了两个公式：</p><p>$E=mc^2$</p><p>$f(x) = x^2$</p><hr><h3 id="插入LaTeX公式"><a href="#插入LaTeX公式" class="headerlink" title="插入LaTeX公式"></a>插入LaTeX公式</h3><p>首先一个简单的示例，下述公式写法为：<code>$f&#39;(x\_0)=\lim_{\Delta x\to 0} \frac{f(x\_0+\Delta x) - f(x\_0)}{\Delta x}$</code></p><p>$f’(x_0)=\lim_{\Delta x\to 0} \frac{f(x_0+\Delta x) - f(x_0)}{\Delta x}$</p><p>常见的总结如下：</p><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center"><code>\\(x^y\\)</code></td><td style="text-align:center">\(x^y\)</td></tr><tr><td style="text-align:center"><code>\\(x^{y^z}\\)</code></td><td style="text-align:center">\(x^{y^z}\)</td></tr><tr><td style="text-align:center"><code>\\(x_i\\)</code></td><td style="text-align:center">\(x_i\)</td></tr><tr><td style="text-align:center"><code>\\(\alpha\\)</code></td><td style="text-align:center">\(\alpha\)</td></tr><tr><td style="text-align:center"><code>\\(\beta\\)</code></td><td style="text-align:center">\(\beta\)</td></tr><tr><td style="text-align:center"><code>\\(\Delta\\)</code></td><td style="text-align:center">\(\Delta\)</td></tr><tr><td style="text-align:center"><code>$$\sum_{i=0}^n$$</code></td><td style="text-align:center">$$\sum_{i=0}^n$$</td></tr><tr><td style="text-align:center"><code>$\frac{x}{y}$</code></td><td style="text-align:center">$\frac{x}{y}$</td></tr><tr><td style="text-align:center"><code>\\(\sqrt 3\\)</code></td><td style="text-align:center">\(\sqrt 3\)</td></tr><tr><td style="text-align:center"><code>\\(\sqrt[3] 5\\)</code></td><td style="text-align:center">\(\sqrt[3] 5\)</td></tr><tr><td style="text-align:center"><code>$$\lim_{x \to 0}$$</code></td><td style="text-align:center">$$\lim_{x \to 0}$$</td></tr><tr><td style="text-align:center"><code>$$f(x): \begin{cases} x, x&gt;0 \\\ \\\ -x,x&lt;0 \end{cases}$$</code></td><td style="text-align:center">$$f(x): \begin{cases} x, x&gt;0 \\ \\ -x,x&lt;0 \end{cases}$$</td></tr></tbody></table><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="http://daniellaah.github.io/2016/Mathmatical-Formula-within-Markdown.html" target="_blank" rel="noopener">http://daniellaah.github.io/2016/Mathmatical-Formula-within-Markdown.html</a></li><li><a href="https://www.jianshu.com/p/0b257de21eb5" target="_blank" rel="noopener">https://www.jianshu.com/p/0b257de21eb5</a></li><li><a href="https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener">https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/</a></li><li><a href="http://blog.mobing.net/content/hexo/hexo-mathjax.html" target="_blank" rel="noopener">http://blog.mobing.net/content/hexo/hexo-mathjax.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      简单的学习一波Markdown，将自己平时写博客用的比较多的Markdown语法做做记录
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="个人" scheme="https://296245482.github.io/tags/%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="blog" scheme="https://296245482.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Page的个人博客搭建</title>
    <link href="https://296245482.github.io/2018/04/18/Hexo-Github-Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://296245482.github.io/2018/04/18/Hexo-Github-Page的个人博客搭建/</id>
    <published>2018-04-18T08:03:21.000Z</published>
    <updated>2018-04-18T08:03:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近开始各种地方准备春招，投递了不少简历，经历了不少面试，着实感觉自己很多地方的积累还是不够，后端研发或者是Java研发这一块，还有太多的细节没有弄清楚，很多框架的一些原理没有很好的理解，因此决定开一个博客，在平时的学习过程中不断积累，不断总结知识点。</p><p>除去hexo配置完成后的“Hello World”文章，个人博客的第一篇文章就以“Hexo+Github Page配置个人博客”为主题了。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>配置过程参考了很多现有的网站的一些过程</p><p>完成的效果是在本地创建了一份Hexo工程，通过MarkDown创作，每次生成博客网站的内容，通过SSH方式远程部署到自己的USERNAME.GitHub.io的repo上。</p><p>Hexo的初步配置参考： <a href="https://www.jianshu.com/p/e5f95eb990ad" target="_blank" rel="noopener">Mac下使用Hexo+Github搭建个人博客</a> 。</p><p>初步完成后使用了 <a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">Maupassant</a> 主题，该主题很简洁，算是我比较喜欢的类型。</p><p>初步配置完成之后，后期有很多主题内评论、语言等配置，参考了<a href="https://github.com/handsdirty/hexo_blog" target="_blank" rel="noopener">Zhesong的配置过程</a> 。</p><p><strong>详细的步骤在上述几个教程中都已经有了完备的描述</strong></p><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd [hexo本地工程路径下]</span><br><span class="line">hexo new post &apos;文章标题&apos;</span><br></pre></td></tr></table></figure><p>打开工程路径下的<code>/source/_posts/</code>路径，找到自己刚新建出来的文章，打开编辑内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate / hexo g</span><br><span class="line">hexo deploy / hexo d</span><br></pre></td></tr></table></figure></p><p>这样的操作即可将新文章内容更新到个人的博客网站上。</p><p>PS: 有一种方法可以在deploy之前预览到更新后的样子，执行完 <code>hexo generate</code> 后执行 <code>hexo server / hexo s</code> ，在浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看预览结果</p><h2 id="立个Flag"><a href="#立个Flag" class="headerlink" title="立个Flag"></a>立个Flag</h2><p>每隔几天学习完一段时间后，坚持写个人的技术博客，在详细理解之后坚持原创，记录好自己的思路和理解，坚持！</p>]]></content>
    
    <summary type="html">
    
      本文介绍了本博客的搭建方法，基于GitHub的免费page服务搭建Hexo项目，有任何问题欢迎留言讨论~
    
    </summary>
    
      <category term="tech" scheme="https://296245482.github.io/categories/tech/"/>
    
    
      <category term="个人" scheme="https://296245482.github.io/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://296245482.github.io/2018/04/17/hello-world/"/>
    <id>https://296245482.github.io/2018/04/17/hello-world/</id>
    <published>2018-04-17T14:26:19.000Z</published>
    <updated>2018-04-18T08:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
